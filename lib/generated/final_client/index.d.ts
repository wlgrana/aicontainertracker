
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ImportLog
 * 
 */
export type ImportLog = $Result.DefaultSelection<Prisma.$ImportLogPayload>
/**
 * Model RawRow
 * 
 */
export type RawRow = $Result.DefaultSelection<Prisma.$RawRowPayload>
/**
 * Model TransitStage
 * 
 */
export type TransitStage = $Result.DefaultSelection<Prisma.$TransitStagePayload>
/**
 * Model Shipment
 * 
 */
export type Shipment = $Result.DefaultSelection<Prisma.$ShipmentPayload>
/**
 * Model Container
 * 
 */
export type Container = $Result.DefaultSelection<Prisma.$ContainerPayload>
/**
 * Model ShipmentContainer
 * 
 */
export type ShipmentContainer = $Result.DefaultSelection<Prisma.$ShipmentContainerPayload>
/**
 * Model ContainerEvent
 * 
 */
export type ContainerEvent = $Result.DefaultSelection<Prisma.$ContainerEventPayload>
/**
 * Model ShipmentEvent
 * 
 */
export type ShipmentEvent = $Result.DefaultSelection<Prisma.$ShipmentEventPayload>
/**
 * Model ACEStatusLog
 * 
 */
export type ACEStatusLog = $Result.DefaultSelection<Prisma.$ACEStatusLogPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model Carrier
 * 
 */
export type Carrier = $Result.DefaultSelection<Prisma.$CarrierPayload>
/**
 * Model Port
 * 
 */
export type Port = $Result.DefaultSelection<Prisma.$PortPayload>
/**
 * Model Forwarder
 * 
 */
export type Forwarder = $Result.DefaultSelection<Prisma.$ForwarderPayload>
/**
 * Model DemurrageRate
 * 
 */
export type DemurrageRate = $Result.DefaultSelection<Prisma.$DemurrageRatePayload>
/**
 * Model CarrierFormat
 * 
 */
export type CarrierFormat = $Result.DefaultSelection<Prisma.$CarrierFormatPayload>
/**
 * Model DCSAEventMap
 * 
 */
export type DCSAEventMap = $Result.DefaultSelection<Prisma.$DCSAEventMapPayload>
/**
 * Model AttentionFlag
 * 
 */
export type AttentionFlag = $Result.DefaultSelection<Prisma.$AttentionFlagPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model StatusOverride
 * 
 */
export type StatusOverride = $Result.DefaultSelection<Prisma.$StatusOverridePayload>
/**
 * Model RiskAssessment
 * 
 */
export type RiskAssessment = $Result.DefaultSelection<Prisma.$RiskAssessmentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ImportLogs
 * const importLogs = await prisma.importLog.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ImportLogs
   * const importLogs = await prisma.importLog.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.importLog`: Exposes CRUD operations for the **ImportLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportLogs
    * const importLogs = await prisma.importLog.findMany()
    * ```
    */
  get importLog(): Prisma.ImportLogDelegate<ExtArgs>;

  /**
   * `prisma.rawRow`: Exposes CRUD operations for the **RawRow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawRows
    * const rawRows = await prisma.rawRow.findMany()
    * ```
    */
  get rawRow(): Prisma.RawRowDelegate<ExtArgs>;

  /**
   * `prisma.transitStage`: Exposes CRUD operations for the **TransitStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransitStages
    * const transitStages = await prisma.transitStage.findMany()
    * ```
    */
  get transitStage(): Prisma.TransitStageDelegate<ExtArgs>;

  /**
   * `prisma.shipment`: Exposes CRUD operations for the **Shipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shipments
    * const shipments = await prisma.shipment.findMany()
    * ```
    */
  get shipment(): Prisma.ShipmentDelegate<ExtArgs>;

  /**
   * `prisma.container`: Exposes CRUD operations for the **Container** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Containers
    * const containers = await prisma.container.findMany()
    * ```
    */
  get container(): Prisma.ContainerDelegate<ExtArgs>;

  /**
   * `prisma.shipmentContainer`: Exposes CRUD operations for the **ShipmentContainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShipmentContainers
    * const shipmentContainers = await prisma.shipmentContainer.findMany()
    * ```
    */
  get shipmentContainer(): Prisma.ShipmentContainerDelegate<ExtArgs>;

  /**
   * `prisma.containerEvent`: Exposes CRUD operations for the **ContainerEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContainerEvents
    * const containerEvents = await prisma.containerEvent.findMany()
    * ```
    */
  get containerEvent(): Prisma.ContainerEventDelegate<ExtArgs>;

  /**
   * `prisma.shipmentEvent`: Exposes CRUD operations for the **ShipmentEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShipmentEvents
    * const shipmentEvents = await prisma.shipmentEvent.findMany()
    * ```
    */
  get shipmentEvent(): Prisma.ShipmentEventDelegate<ExtArgs>;

  /**
   * `prisma.aCEStatusLog`: Exposes CRUD operations for the **ACEStatusLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ACEStatusLogs
    * const aCEStatusLogs = await prisma.aCEStatusLog.findMany()
    * ```
    */
  get aCEStatusLog(): Prisma.ACEStatusLogDelegate<ExtArgs>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs>;

  /**
   * `prisma.carrier`: Exposes CRUD operations for the **Carrier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carriers
    * const carriers = await prisma.carrier.findMany()
    * ```
    */
  get carrier(): Prisma.CarrierDelegate<ExtArgs>;

  /**
   * `prisma.port`: Exposes CRUD operations for the **Port** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ports
    * const ports = await prisma.port.findMany()
    * ```
    */
  get port(): Prisma.PortDelegate<ExtArgs>;

  /**
   * `prisma.forwarder`: Exposes CRUD operations for the **Forwarder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forwarders
    * const forwarders = await prisma.forwarder.findMany()
    * ```
    */
  get forwarder(): Prisma.ForwarderDelegate<ExtArgs>;

  /**
   * `prisma.demurrageRate`: Exposes CRUD operations for the **DemurrageRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DemurrageRates
    * const demurrageRates = await prisma.demurrageRate.findMany()
    * ```
    */
  get demurrageRate(): Prisma.DemurrageRateDelegate<ExtArgs>;

  /**
   * `prisma.carrierFormat`: Exposes CRUD operations for the **CarrierFormat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarrierFormats
    * const carrierFormats = await prisma.carrierFormat.findMany()
    * ```
    */
  get carrierFormat(): Prisma.CarrierFormatDelegate<ExtArgs>;

  /**
   * `prisma.dCSAEventMap`: Exposes CRUD operations for the **DCSAEventMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DCSAEventMaps
    * const dCSAEventMaps = await prisma.dCSAEventMap.findMany()
    * ```
    */
  get dCSAEventMap(): Prisma.DCSAEventMapDelegate<ExtArgs>;

  /**
   * `prisma.attentionFlag`: Exposes CRUD operations for the **AttentionFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttentionFlags
    * const attentionFlags = await prisma.attentionFlag.findMany()
    * ```
    */
  get attentionFlag(): Prisma.AttentionFlagDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.statusOverride`: Exposes CRUD operations for the **StatusOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusOverrides
    * const statusOverrides = await prisma.statusOverride.findMany()
    * ```
    */
  get statusOverride(): Prisma.StatusOverrideDelegate<ExtArgs>;

  /**
   * `prisma.riskAssessment`: Exposes CRUD operations for the **RiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAssessments
    * const riskAssessments = await prisma.riskAssessment.findMany()
    * ```
    */
  get riskAssessment(): Prisma.RiskAssessmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.18.0
   * Query Engine version: 4c784e32044a8a016d99474bd02a3b6123742169
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ImportLog: 'ImportLog',
    RawRow: 'RawRow',
    TransitStage: 'TransitStage',
    Shipment: 'Shipment',
    Container: 'Container',
    ShipmentContainer: 'ShipmentContainer',
    ContainerEvent: 'ContainerEvent',
    ShipmentEvent: 'ShipmentEvent',
    ACEStatusLog: 'ACEStatusLog',
    Facility: 'Facility',
    Carrier: 'Carrier',
    Port: 'Port',
    Forwarder: 'Forwarder',
    DemurrageRate: 'DemurrageRate',
    CarrierFormat: 'CarrierFormat',
    DCSAEventMap: 'DCSAEventMap',
    AttentionFlag: 'AttentionFlag',
    ActivityLog: 'ActivityLog',
    StatusOverride: 'StatusOverride',
    RiskAssessment: 'RiskAssessment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "importLog" | "rawRow" | "transitStage" | "shipment" | "container" | "shipmentContainer" | "containerEvent" | "shipmentEvent" | "aCEStatusLog" | "facility" | "carrier" | "port" | "forwarder" | "demurrageRate" | "carrierFormat" | "dCSAEventMap" | "attentionFlag" | "activityLog" | "statusOverride" | "riskAssessment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ImportLog: {
        payload: Prisma.$ImportLogPayload<ExtArgs>
        fields: Prisma.ImportLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          findFirst: {
            args: Prisma.ImportLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          findMany: {
            args: Prisma.ImportLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>[]
          }
          create: {
            args: Prisma.ImportLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          createMany: {
            args: Prisma.ImportLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>[]
          }
          delete: {
            args: Prisma.ImportLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          update: {
            args: Prisma.ImportLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          deleteMany: {
            args: Prisma.ImportLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          aggregate: {
            args: Prisma.ImportLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportLog>
          }
          groupBy: {
            args: Prisma.ImportLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportLogCountArgs<ExtArgs>
            result: $Utils.Optional<ImportLogCountAggregateOutputType> | number
          }
        }
      }
      RawRow: {
        payload: Prisma.$RawRowPayload<ExtArgs>
        fields: Prisma.RawRowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawRowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawRowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>
          }
          findFirst: {
            args: Prisma.RawRowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawRowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>
          }
          findMany: {
            args: Prisma.RawRowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>[]
          }
          create: {
            args: Prisma.RawRowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>
          }
          createMany: {
            args: Prisma.RawRowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RawRowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>[]
          }
          delete: {
            args: Prisma.RawRowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>
          }
          update: {
            args: Prisma.RawRowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>
          }
          deleteMany: {
            args: Prisma.RawRowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawRowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RawRowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawRowPayload>
          }
          aggregate: {
            args: Prisma.RawRowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawRow>
          }
          groupBy: {
            args: Prisma.RawRowGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawRowGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawRowCountArgs<ExtArgs>
            result: $Utils.Optional<RawRowCountAggregateOutputType> | number
          }
        }
      }
      TransitStage: {
        payload: Prisma.$TransitStagePayload<ExtArgs>
        fields: Prisma.TransitStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransitStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransitStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>
          }
          findFirst: {
            args: Prisma.TransitStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransitStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>
          }
          findMany: {
            args: Prisma.TransitStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>[]
          }
          create: {
            args: Prisma.TransitStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>
          }
          createMany: {
            args: Prisma.TransitStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransitStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>[]
          }
          delete: {
            args: Prisma.TransitStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>
          }
          update: {
            args: Prisma.TransitStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>
          }
          deleteMany: {
            args: Prisma.TransitStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransitStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransitStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransitStagePayload>
          }
          aggregate: {
            args: Prisma.TransitStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransitStage>
          }
          groupBy: {
            args: Prisma.TransitStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransitStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransitStageCountArgs<ExtArgs>
            result: $Utils.Optional<TransitStageCountAggregateOutputType> | number
          }
        }
      }
      Shipment: {
        payload: Prisma.$ShipmentPayload<ExtArgs>
        fields: Prisma.ShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findFirst: {
            args: Prisma.ShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findMany: {
            args: Prisma.ShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          create: {
            args: Prisma.ShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          createMany: {
            args: Prisma.ShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          delete: {
            args: Prisma.ShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          update: {
            args: Prisma.ShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          aggregate: {
            args: Prisma.ShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipment>
          }
          groupBy: {
            args: Prisma.ShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentCountAggregateOutputType> | number
          }
        }
      }
      Container: {
        payload: Prisma.$ContainerPayload<ExtArgs>
        fields: Prisma.ContainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          findFirst: {
            args: Prisma.ContainerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          findMany: {
            args: Prisma.ContainerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          create: {
            args: Prisma.ContainerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          createMany: {
            args: Prisma.ContainerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          delete: {
            args: Prisma.ContainerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          update: {
            args: Prisma.ContainerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          deleteMany: {
            args: Prisma.ContainerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContainerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          aggregate: {
            args: Prisma.ContainerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainer>
          }
          groupBy: {
            args: Prisma.ContainerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerCountAggregateOutputType> | number
          }
        }
      }
      ShipmentContainer: {
        payload: Prisma.$ShipmentContainerPayload<ExtArgs>
        fields: Prisma.ShipmentContainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentContainerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentContainerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>
          }
          findFirst: {
            args: Prisma.ShipmentContainerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentContainerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>
          }
          findMany: {
            args: Prisma.ShipmentContainerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>[]
          }
          create: {
            args: Prisma.ShipmentContainerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>
          }
          createMany: {
            args: Prisma.ShipmentContainerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentContainerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>[]
          }
          delete: {
            args: Prisma.ShipmentContainerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>
          }
          update: {
            args: Prisma.ShipmentContainerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentContainerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentContainerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShipmentContainerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentContainerPayload>
          }
          aggregate: {
            args: Prisma.ShipmentContainerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipmentContainer>
          }
          groupBy: {
            args: Prisma.ShipmentContainerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentContainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentContainerCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentContainerCountAggregateOutputType> | number
          }
        }
      }
      ContainerEvent: {
        payload: Prisma.$ContainerEventPayload<ExtArgs>
        fields: Prisma.ContainerEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>
          }
          findFirst: {
            args: Prisma.ContainerEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>
          }
          findMany: {
            args: Prisma.ContainerEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>[]
          }
          create: {
            args: Prisma.ContainerEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>
          }
          createMany: {
            args: Prisma.ContainerEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>[]
          }
          delete: {
            args: Prisma.ContainerEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>
          }
          update: {
            args: Prisma.ContainerEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>
          }
          deleteMany: {
            args: Prisma.ContainerEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContainerEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerEventPayload>
          }
          aggregate: {
            args: Prisma.ContainerEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainerEvent>
          }
          groupBy: {
            args: Prisma.ContainerEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerEventCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerEventCountAggregateOutputType> | number
          }
        }
      }
      ShipmentEvent: {
        payload: Prisma.$ShipmentEventPayload<ExtArgs>
        fields: Prisma.ShipmentEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>
          }
          findFirst: {
            args: Prisma.ShipmentEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>
          }
          findMany: {
            args: Prisma.ShipmentEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>[]
          }
          create: {
            args: Prisma.ShipmentEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>
          }
          createMany: {
            args: Prisma.ShipmentEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>[]
          }
          delete: {
            args: Prisma.ShipmentEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>
          }
          update: {
            args: Prisma.ShipmentEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShipmentEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentEventPayload>
          }
          aggregate: {
            args: Prisma.ShipmentEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipmentEvent>
          }
          groupBy: {
            args: Prisma.ShipmentEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentEventCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentEventCountAggregateOutputType> | number
          }
        }
      }
      ACEStatusLog: {
        payload: Prisma.$ACEStatusLogPayload<ExtArgs>
        fields: Prisma.ACEStatusLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ACEStatusLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ACEStatusLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>
          }
          findFirst: {
            args: Prisma.ACEStatusLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ACEStatusLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>
          }
          findMany: {
            args: Prisma.ACEStatusLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>[]
          }
          create: {
            args: Prisma.ACEStatusLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>
          }
          createMany: {
            args: Prisma.ACEStatusLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ACEStatusLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>[]
          }
          delete: {
            args: Prisma.ACEStatusLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>
          }
          update: {
            args: Prisma.ACEStatusLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>
          }
          deleteMany: {
            args: Prisma.ACEStatusLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ACEStatusLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ACEStatusLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ACEStatusLogPayload>
          }
          aggregate: {
            args: Prisma.ACEStatusLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateACEStatusLog>
          }
          groupBy: {
            args: Prisma.ACEStatusLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ACEStatusLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ACEStatusLogCountArgs<ExtArgs>
            result: $Utils.Optional<ACEStatusLogCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      Carrier: {
        payload: Prisma.$CarrierPayload<ExtArgs>
        fields: Prisma.CarrierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarrierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarrierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>
          }
          findFirst: {
            args: Prisma.CarrierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarrierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>
          }
          findMany: {
            args: Prisma.CarrierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>[]
          }
          create: {
            args: Prisma.CarrierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>
          }
          createMany: {
            args: Prisma.CarrierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarrierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>[]
          }
          delete: {
            args: Prisma.CarrierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>
          }
          update: {
            args: Prisma.CarrierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>
          }
          deleteMany: {
            args: Prisma.CarrierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarrierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarrierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierPayload>
          }
          aggregate: {
            args: Prisma.CarrierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarrier>
          }
          groupBy: {
            args: Prisma.CarrierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarrierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarrierCountArgs<ExtArgs>
            result: $Utils.Optional<CarrierCountAggregateOutputType> | number
          }
        }
      }
      Port: {
        payload: Prisma.$PortPayload<ExtArgs>
        fields: Prisma.PortFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          findFirst: {
            args: Prisma.PortFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          findMany: {
            args: Prisma.PortFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>[]
          }
          create: {
            args: Prisma.PortCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          createMany: {
            args: Prisma.PortCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>[]
          }
          delete: {
            args: Prisma.PortDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          update: {
            args: Prisma.PortUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          deleteMany: {
            args: Prisma.PortDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortPayload>
          }
          aggregate: {
            args: Prisma.PortAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePort>
          }
          groupBy: {
            args: Prisma.PortGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortCountArgs<ExtArgs>
            result: $Utils.Optional<PortCountAggregateOutputType> | number
          }
        }
      }
      Forwarder: {
        payload: Prisma.$ForwarderPayload<ExtArgs>
        fields: Prisma.ForwarderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForwarderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForwarderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>
          }
          findFirst: {
            args: Prisma.ForwarderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForwarderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>
          }
          findMany: {
            args: Prisma.ForwarderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>[]
          }
          create: {
            args: Prisma.ForwarderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>
          }
          createMany: {
            args: Prisma.ForwarderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForwarderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>[]
          }
          delete: {
            args: Prisma.ForwarderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>
          }
          update: {
            args: Prisma.ForwarderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>
          }
          deleteMany: {
            args: Prisma.ForwarderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForwarderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForwarderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForwarderPayload>
          }
          aggregate: {
            args: Prisma.ForwarderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForwarder>
          }
          groupBy: {
            args: Prisma.ForwarderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForwarderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForwarderCountArgs<ExtArgs>
            result: $Utils.Optional<ForwarderCountAggregateOutputType> | number
          }
        }
      }
      DemurrageRate: {
        payload: Prisma.$DemurrageRatePayload<ExtArgs>
        fields: Prisma.DemurrageRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DemurrageRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DemurrageRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>
          }
          findFirst: {
            args: Prisma.DemurrageRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DemurrageRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>
          }
          findMany: {
            args: Prisma.DemurrageRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>[]
          }
          create: {
            args: Prisma.DemurrageRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>
          }
          createMany: {
            args: Prisma.DemurrageRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DemurrageRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>[]
          }
          delete: {
            args: Prisma.DemurrageRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>
          }
          update: {
            args: Prisma.DemurrageRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>
          }
          deleteMany: {
            args: Prisma.DemurrageRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DemurrageRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DemurrageRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemurrageRatePayload>
          }
          aggregate: {
            args: Prisma.DemurrageRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDemurrageRate>
          }
          groupBy: {
            args: Prisma.DemurrageRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DemurrageRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DemurrageRateCountArgs<ExtArgs>
            result: $Utils.Optional<DemurrageRateCountAggregateOutputType> | number
          }
        }
      }
      CarrierFormat: {
        payload: Prisma.$CarrierFormatPayload<ExtArgs>
        fields: Prisma.CarrierFormatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarrierFormatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarrierFormatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>
          }
          findFirst: {
            args: Prisma.CarrierFormatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarrierFormatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>
          }
          findMany: {
            args: Prisma.CarrierFormatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>[]
          }
          create: {
            args: Prisma.CarrierFormatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>
          }
          createMany: {
            args: Prisma.CarrierFormatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarrierFormatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>[]
          }
          delete: {
            args: Prisma.CarrierFormatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>
          }
          update: {
            args: Prisma.CarrierFormatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>
          }
          deleteMany: {
            args: Prisma.CarrierFormatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarrierFormatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarrierFormatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrierFormatPayload>
          }
          aggregate: {
            args: Prisma.CarrierFormatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarrierFormat>
          }
          groupBy: {
            args: Prisma.CarrierFormatGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarrierFormatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarrierFormatCountArgs<ExtArgs>
            result: $Utils.Optional<CarrierFormatCountAggregateOutputType> | number
          }
        }
      }
      DCSAEventMap: {
        payload: Prisma.$DCSAEventMapPayload<ExtArgs>
        fields: Prisma.DCSAEventMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DCSAEventMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DCSAEventMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>
          }
          findFirst: {
            args: Prisma.DCSAEventMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DCSAEventMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>
          }
          findMany: {
            args: Prisma.DCSAEventMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>[]
          }
          create: {
            args: Prisma.DCSAEventMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>
          }
          createMany: {
            args: Prisma.DCSAEventMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DCSAEventMapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>[]
          }
          delete: {
            args: Prisma.DCSAEventMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>
          }
          update: {
            args: Prisma.DCSAEventMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>
          }
          deleteMany: {
            args: Prisma.DCSAEventMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DCSAEventMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DCSAEventMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DCSAEventMapPayload>
          }
          aggregate: {
            args: Prisma.DCSAEventMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDCSAEventMap>
          }
          groupBy: {
            args: Prisma.DCSAEventMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<DCSAEventMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.DCSAEventMapCountArgs<ExtArgs>
            result: $Utils.Optional<DCSAEventMapCountAggregateOutputType> | number
          }
        }
      }
      AttentionFlag: {
        payload: Prisma.$AttentionFlagPayload<ExtArgs>
        fields: Prisma.AttentionFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttentionFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttentionFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>
          }
          findFirst: {
            args: Prisma.AttentionFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttentionFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>
          }
          findMany: {
            args: Prisma.AttentionFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>[]
          }
          create: {
            args: Prisma.AttentionFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>
          }
          createMany: {
            args: Prisma.AttentionFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttentionFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>[]
          }
          delete: {
            args: Prisma.AttentionFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>
          }
          update: {
            args: Prisma.AttentionFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>
          }
          deleteMany: {
            args: Prisma.AttentionFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttentionFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttentionFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttentionFlagPayload>
          }
          aggregate: {
            args: Prisma.AttentionFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttentionFlag>
          }
          groupBy: {
            args: Prisma.AttentionFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttentionFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttentionFlagCountArgs<ExtArgs>
            result: $Utils.Optional<AttentionFlagCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      StatusOverride: {
        payload: Prisma.$StatusOverridePayload<ExtArgs>
        fields: Prisma.StatusOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>
          }
          findFirst: {
            args: Prisma.StatusOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>
          }
          findMany: {
            args: Prisma.StatusOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>[]
          }
          create: {
            args: Prisma.StatusOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>
          }
          createMany: {
            args: Prisma.StatusOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>[]
          }
          delete: {
            args: Prisma.StatusOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>
          }
          update: {
            args: Prisma.StatusOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>
          }
          deleteMany: {
            args: Prisma.StatusOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatusOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusOverridePayload>
          }
          aggregate: {
            args: Prisma.StatusOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusOverride>
          }
          groupBy: {
            args: Prisma.StatusOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<StatusOverrideCountAggregateOutputType> | number
          }
        }
      }
      RiskAssessment: {
        payload: Prisma.$RiskAssessmentPayload<ExtArgs>
        fields: Prisma.RiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.RiskAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.RiskAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.RiskAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.RiskAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          delete: {
            args: Prisma.RiskAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          update: {
            args: Prisma.RiskAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.RiskAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.RiskAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAssessment>
          }
          groupBy: {
            args: Prisma.RiskAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ImportLogCountOutputType
   */

  export type ImportLogCountOutputType = {
    aceStatusLogs: number
    containerEvents: number
    rawRows: number
    shipmentEvents: number
  }

  export type ImportLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aceStatusLogs?: boolean | ImportLogCountOutputTypeCountAceStatusLogsArgs
    containerEvents?: boolean | ImportLogCountOutputTypeCountContainerEventsArgs
    rawRows?: boolean | ImportLogCountOutputTypeCountRawRowsArgs
    shipmentEvents?: boolean | ImportLogCountOutputTypeCountShipmentEventsArgs
  }

  // Custom InputTypes
  /**
   * ImportLogCountOutputType without action
   */
  export type ImportLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLogCountOutputType
     */
    select?: ImportLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportLogCountOutputType without action
   */
  export type ImportLogCountOutputTypeCountAceStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ACEStatusLogWhereInput
  }

  /**
   * ImportLogCountOutputType without action
   */
  export type ImportLogCountOutputTypeCountContainerEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerEventWhereInput
  }

  /**
   * ImportLogCountOutputType without action
   */
  export type ImportLogCountOutputTypeCountRawRowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawRowWhereInput
  }

  /**
   * ImportLogCountOutputType without action
   */
  export type ImportLogCountOutputTypeCountShipmentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentEventWhereInput
  }


  /**
   * Count Type TransitStageCountOutputType
   */

  export type TransitStageCountOutputType = {
    containers: number
    previousEvents: number
    containerEvents: number
    dcsaEventMaps: number
  }

  export type TransitStageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containers?: boolean | TransitStageCountOutputTypeCountContainersArgs
    previousEvents?: boolean | TransitStageCountOutputTypeCountPreviousEventsArgs
    containerEvents?: boolean | TransitStageCountOutputTypeCountContainerEventsArgs
    dcsaEventMaps?: boolean | TransitStageCountOutputTypeCountDcsaEventMapsArgs
  }

  // Custom InputTypes
  /**
   * TransitStageCountOutputType without action
   */
  export type TransitStageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStageCountOutputType
     */
    select?: TransitStageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransitStageCountOutputType without action
   */
  export type TransitStageCountOutputTypeCountContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerWhereInput
  }

  /**
   * TransitStageCountOutputType without action
   */
  export type TransitStageCountOutputTypeCountPreviousEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerEventWhereInput
  }

  /**
   * TransitStageCountOutputType without action
   */
  export type TransitStageCountOutputTypeCountContainerEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerEventWhereInput
  }

  /**
   * TransitStageCountOutputType without action
   */
  export type TransitStageCountOutputTypeCountDcsaEventMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DCSAEventMapWhereInput
  }


  /**
   * Count Type ShipmentCountOutputType
   */

  export type ShipmentCountOutputType = {
    aceStatusLogs: number
    shipmentContainers: number
    shipmentEvents: number
  }

  export type ShipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aceStatusLogs?: boolean | ShipmentCountOutputTypeCountAceStatusLogsArgs
    shipmentContainers?: boolean | ShipmentCountOutputTypeCountShipmentContainersArgs
    shipmentEvents?: boolean | ShipmentCountOutputTypeCountShipmentEventsArgs
  }

  // Custom InputTypes
  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentCountOutputType
     */
    select?: ShipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountAceStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ACEStatusLogWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountShipmentContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentContainerWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountShipmentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentEventWhereInput
  }


  /**
   * Count Type ContainerCountOutputType
   */

  export type ContainerCountOutputType = {
    aceStatusLogs: number
    events: number
    shipmentContainers: number
    attentionFlags: number
    activityLogs: number
    statusOverrides: number
  }

  export type ContainerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aceStatusLogs?: boolean | ContainerCountOutputTypeCountAceStatusLogsArgs
    events?: boolean | ContainerCountOutputTypeCountEventsArgs
    shipmentContainers?: boolean | ContainerCountOutputTypeCountShipmentContainersArgs
    attentionFlags?: boolean | ContainerCountOutputTypeCountAttentionFlagsArgs
    activityLogs?: boolean | ContainerCountOutputTypeCountActivityLogsArgs
    statusOverrides?: boolean | ContainerCountOutputTypeCountStatusOverridesArgs
  }

  // Custom InputTypes
  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerCountOutputType
     */
    select?: ContainerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountAceStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ACEStatusLogWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerEventWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountShipmentContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentContainerWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountAttentionFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttentionFlagWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountStatusOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusOverrideWhereInput
  }


  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    containerEvents: number
  }

  export type FacilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerEvents?: boolean | FacilityCountOutputTypeCountContainerEventsArgs
  }

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountContainerEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerEventWhereInput
  }


  /**
   * Count Type CarrierCountOutputType
   */

  export type CarrierCountOutputType = {
    carrierFormats: number
    dcsaEventMaps: number
    demurrageRates: number
  }

  export type CarrierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrierFormats?: boolean | CarrierCountOutputTypeCountCarrierFormatsArgs
    dcsaEventMaps?: boolean | CarrierCountOutputTypeCountDcsaEventMapsArgs
    demurrageRates?: boolean | CarrierCountOutputTypeCountDemurrageRatesArgs
  }

  // Custom InputTypes
  /**
   * CarrierCountOutputType without action
   */
  export type CarrierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierCountOutputType
     */
    select?: CarrierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarrierCountOutputType without action
   */
  export type CarrierCountOutputTypeCountCarrierFormatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarrierFormatWhereInput
  }

  /**
   * CarrierCountOutputType without action
   */
  export type CarrierCountOutputTypeCountDcsaEventMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DCSAEventMapWhereInput
  }

  /**
   * CarrierCountOutputType without action
   */
  export type CarrierCountOutputTypeCountDemurrageRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemurrageRateWhereInput
  }


  /**
   * Count Type PortCountOutputType
   */

  export type PortCountOutputType = {
    demurrageRates: number
    facilities: number
  }

  export type PortCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    demurrageRates?: boolean | PortCountOutputTypeCountDemurrageRatesArgs
    facilities?: boolean | PortCountOutputTypeCountFacilitiesArgs
  }

  // Custom InputTypes
  /**
   * PortCountOutputType without action
   */
  export type PortCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortCountOutputType
     */
    select?: PortCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortCountOutputType without action
   */
  export type PortCountOutputTypeCountDemurrageRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemurrageRateWhereInput
  }

  /**
   * PortCountOutputType without action
   */
  export type PortCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }


  /**
   * Count Type CarrierFormatCountOutputType
   */

  export type CarrierFormatCountOutputType = {
    importLogs: number
  }

  export type CarrierFormatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLogs?: boolean | CarrierFormatCountOutputTypeCountImportLogsArgs
  }

  // Custom InputTypes
  /**
   * CarrierFormatCountOutputType without action
   */
  export type CarrierFormatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormatCountOutputType
     */
    select?: CarrierFormatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarrierFormatCountOutputType without action
   */
  export type CarrierFormatCountOutputTypeCountImportLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ImportLog
   */

  export type AggregateImportLog = {
    _count: ImportLogCountAggregateOutputType | null
    _avg: ImportLogAvgAggregateOutputType | null
    _sum: ImportLogSumAggregateOutputType | null
    _min: ImportLogMinAggregateOutputType | null
    _max: ImportLogMaxAggregateOutputType | null
  }

  export type ImportLogAvgAggregateOutputType = {
    rowsProcessed: number | null
    rowsSucceeded: number | null
    rowsFailed: number | null
  }

  export type ImportLogSumAggregateOutputType = {
    rowsProcessed: number | null
    rowsSucceeded: number | null
    rowsFailed: number | null
  }

  export type ImportLogMinAggregateOutputType = {
    fileName: string | null
    fileURL: string | null
    importedBy: string | null
    importedOn: Date | null
    rowsProcessed: number | null
    rowsSucceeded: number | null
    rowsFailed: number | null
    carrierFormatId: string | null
    importType: string | null
    status: string | null
    errorLog: string | null
    aiAnalyzedAt: Date | null
  }

  export type ImportLogMaxAggregateOutputType = {
    fileName: string | null
    fileURL: string | null
    importedBy: string | null
    importedOn: Date | null
    rowsProcessed: number | null
    rowsSucceeded: number | null
    rowsFailed: number | null
    carrierFormatId: string | null
    importType: string | null
    status: string | null
    errorLog: string | null
    aiAnalyzedAt: Date | null
  }

  export type ImportLogCountAggregateOutputType = {
    fileName: number
    fileURL: number
    importedBy: number
    importedOn: number
    rowsProcessed: number
    rowsSucceeded: number
    rowsFailed: number
    carrierFormatId: number
    importType: number
    status: number
    errorLog: number
    aiAnalysis: number
    aiAnalyzedAt: number
    _all: number
  }


  export type ImportLogAvgAggregateInputType = {
    rowsProcessed?: true
    rowsSucceeded?: true
    rowsFailed?: true
  }

  export type ImportLogSumAggregateInputType = {
    rowsProcessed?: true
    rowsSucceeded?: true
    rowsFailed?: true
  }

  export type ImportLogMinAggregateInputType = {
    fileName?: true
    fileURL?: true
    importedBy?: true
    importedOn?: true
    rowsProcessed?: true
    rowsSucceeded?: true
    rowsFailed?: true
    carrierFormatId?: true
    importType?: true
    status?: true
    errorLog?: true
    aiAnalyzedAt?: true
  }

  export type ImportLogMaxAggregateInputType = {
    fileName?: true
    fileURL?: true
    importedBy?: true
    importedOn?: true
    rowsProcessed?: true
    rowsSucceeded?: true
    rowsFailed?: true
    carrierFormatId?: true
    importType?: true
    status?: true
    errorLog?: true
    aiAnalyzedAt?: true
  }

  export type ImportLogCountAggregateInputType = {
    fileName?: true
    fileURL?: true
    importedBy?: true
    importedOn?: true
    rowsProcessed?: true
    rowsSucceeded?: true
    rowsFailed?: true
    carrierFormatId?: true
    importType?: true
    status?: true
    errorLog?: true
    aiAnalysis?: true
    aiAnalyzedAt?: true
    _all?: true
  }

  export type ImportLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportLog to aggregate.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportLogs
    **/
    _count?: true | ImportLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportLogMaxAggregateInputType
  }

  export type GetImportLogAggregateType<T extends ImportLogAggregateArgs> = {
        [P in keyof T & keyof AggregateImportLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportLog[P]>
      : GetScalarType<T[P], AggregateImportLog[P]>
  }




  export type ImportLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportLogWhereInput
    orderBy?: ImportLogOrderByWithAggregationInput | ImportLogOrderByWithAggregationInput[]
    by: ImportLogScalarFieldEnum[] | ImportLogScalarFieldEnum
    having?: ImportLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportLogCountAggregateInputType | true
    _avg?: ImportLogAvgAggregateInputType
    _sum?: ImportLogSumAggregateInputType
    _min?: ImportLogMinAggregateInputType
    _max?: ImportLogMaxAggregateInputType
  }

  export type ImportLogGroupByOutputType = {
    fileName: string
    fileURL: string | null
    importedBy: string | null
    importedOn: Date
    rowsProcessed: number
    rowsSucceeded: number
    rowsFailed: number
    carrierFormatId: string | null
    importType: string | null
    status: string
    errorLog: string | null
    aiAnalysis: JsonValue | null
    aiAnalyzedAt: Date | null
    _count: ImportLogCountAggregateOutputType | null
    _avg: ImportLogAvgAggregateOutputType | null
    _sum: ImportLogSumAggregateOutputType | null
    _min: ImportLogMinAggregateOutputType | null
    _max: ImportLogMaxAggregateOutputType | null
  }

  type GetImportLogGroupByPayload<T extends ImportLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportLogGroupByOutputType[P]>
            : GetScalarType<T[P], ImportLogGroupByOutputType[P]>
        }
      >
    >


  export type ImportLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fileName?: boolean
    fileURL?: boolean
    importedBy?: boolean
    importedOn?: boolean
    rowsProcessed?: boolean
    rowsSucceeded?: boolean
    rowsFailed?: boolean
    carrierFormatId?: boolean
    importType?: boolean
    status?: boolean
    errorLog?: boolean
    aiAnalysis?: boolean
    aiAnalyzedAt?: boolean
    aceStatusLogs?: boolean | ImportLog$aceStatusLogsArgs<ExtArgs>
    containerEvents?: boolean | ImportLog$containerEventsArgs<ExtArgs>
    carrierFormat?: boolean | ImportLog$carrierFormatArgs<ExtArgs>
    rawRows?: boolean | ImportLog$rawRowsArgs<ExtArgs>
    shipmentEvents?: boolean | ImportLog$shipmentEventsArgs<ExtArgs>
    _count?: boolean | ImportLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importLog"]>

  export type ImportLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fileName?: boolean
    fileURL?: boolean
    importedBy?: boolean
    importedOn?: boolean
    rowsProcessed?: boolean
    rowsSucceeded?: boolean
    rowsFailed?: boolean
    carrierFormatId?: boolean
    importType?: boolean
    status?: boolean
    errorLog?: boolean
    aiAnalysis?: boolean
    aiAnalyzedAt?: boolean
    carrierFormat?: boolean | ImportLog$carrierFormatArgs<ExtArgs>
  }, ExtArgs["result"]["importLog"]>

  export type ImportLogSelectScalar = {
    fileName?: boolean
    fileURL?: boolean
    importedBy?: boolean
    importedOn?: boolean
    rowsProcessed?: boolean
    rowsSucceeded?: boolean
    rowsFailed?: boolean
    carrierFormatId?: boolean
    importType?: boolean
    status?: boolean
    errorLog?: boolean
    aiAnalysis?: boolean
    aiAnalyzedAt?: boolean
  }

  export type ImportLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aceStatusLogs?: boolean | ImportLog$aceStatusLogsArgs<ExtArgs>
    containerEvents?: boolean | ImportLog$containerEventsArgs<ExtArgs>
    carrierFormat?: boolean | ImportLog$carrierFormatArgs<ExtArgs>
    rawRows?: boolean | ImportLog$rawRowsArgs<ExtArgs>
    shipmentEvents?: boolean | ImportLog$shipmentEventsArgs<ExtArgs>
    _count?: boolean | ImportLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrierFormat?: boolean | ImportLog$carrierFormatArgs<ExtArgs>
  }

  export type $ImportLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportLog"
    objects: {
      aceStatusLogs: Prisma.$ACEStatusLogPayload<ExtArgs>[]
      containerEvents: Prisma.$ContainerEventPayload<ExtArgs>[]
      carrierFormat: Prisma.$CarrierFormatPayload<ExtArgs> | null
      rawRows: Prisma.$RawRowPayload<ExtArgs>[]
      shipmentEvents: Prisma.$ShipmentEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      fileName: string
      fileURL: string | null
      importedBy: string | null
      importedOn: Date
      rowsProcessed: number
      rowsSucceeded: number
      rowsFailed: number
      carrierFormatId: string | null
      importType: string | null
      status: string
      errorLog: string | null
      aiAnalysis: Prisma.JsonValue | null
      aiAnalyzedAt: Date | null
    }, ExtArgs["result"]["importLog"]>
    composites: {}
  }

  type ImportLogGetPayload<S extends boolean | null | undefined | ImportLogDefaultArgs> = $Result.GetResult<Prisma.$ImportLogPayload, S>

  type ImportLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportLogCountAggregateInputType | true
    }

  export interface ImportLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportLog'], meta: { name: 'ImportLog' } }
    /**
     * Find zero or one ImportLog that matches the filter.
     * @param {ImportLogFindUniqueArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportLogFindUniqueArgs>(args: SelectSubset<T, ImportLogFindUniqueArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportLogFindUniqueOrThrowArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogFindFirstArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportLogFindFirstArgs>(args?: SelectSubset<T, ImportLogFindFirstArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogFindFirstOrThrowArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportLogs
     * const importLogs = await prisma.importLog.findMany()
     * 
     * // Get first 10 ImportLogs
     * const importLogs = await prisma.importLog.findMany({ take: 10 })
     * 
     * // Only select the `fileName`
     * const importLogWithFileNameOnly = await prisma.importLog.findMany({ select: { fileName: true } })
     * 
     */
    findMany<T extends ImportLogFindManyArgs>(args?: SelectSubset<T, ImportLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportLog.
     * @param {ImportLogCreateArgs} args - Arguments to create a ImportLog.
     * @example
     * // Create one ImportLog
     * const ImportLog = await prisma.importLog.create({
     *   data: {
     *     // ... data to create a ImportLog
     *   }
     * })
     * 
     */
    create<T extends ImportLogCreateArgs>(args: SelectSubset<T, ImportLogCreateArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportLogs.
     * @param {ImportLogCreateManyArgs} args - Arguments to create many ImportLogs.
     * @example
     * // Create many ImportLogs
     * const importLog = await prisma.importLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportLogCreateManyArgs>(args?: SelectSubset<T, ImportLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportLogs and returns the data saved in the database.
     * @param {ImportLogCreateManyAndReturnArgs} args - Arguments to create many ImportLogs.
     * @example
     * // Create many ImportLogs
     * const importLog = await prisma.importLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportLogs and only return the `fileName`
     * const importLogWithFileNameOnly = await prisma.importLog.createManyAndReturn({ 
     *   select: { fileName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportLog.
     * @param {ImportLogDeleteArgs} args - Arguments to delete one ImportLog.
     * @example
     * // Delete one ImportLog
     * const ImportLog = await prisma.importLog.delete({
     *   where: {
     *     // ... filter to delete one ImportLog
     *   }
     * })
     * 
     */
    delete<T extends ImportLogDeleteArgs>(args: SelectSubset<T, ImportLogDeleteArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportLog.
     * @param {ImportLogUpdateArgs} args - Arguments to update one ImportLog.
     * @example
     * // Update one ImportLog
     * const importLog = await prisma.importLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportLogUpdateArgs>(args: SelectSubset<T, ImportLogUpdateArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportLogs.
     * @param {ImportLogDeleteManyArgs} args - Arguments to filter ImportLogs to delete.
     * @example
     * // Delete a few ImportLogs
     * const { count } = await prisma.importLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportLogDeleteManyArgs>(args?: SelectSubset<T, ImportLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportLogs
     * const importLog = await prisma.importLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportLogUpdateManyArgs>(args: SelectSubset<T, ImportLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportLog.
     * @param {ImportLogUpsertArgs} args - Arguments to update or create a ImportLog.
     * @example
     * // Update or create a ImportLog
     * const importLog = await prisma.importLog.upsert({
     *   create: {
     *     // ... data to create a ImportLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportLog we want to update
     *   }
     * })
     */
    upsert<T extends ImportLogUpsertArgs>(args: SelectSubset<T, ImportLogUpsertArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogCountArgs} args - Arguments to filter ImportLogs to count.
     * @example
     * // Count the number of ImportLogs
     * const count = await prisma.importLog.count({
     *   where: {
     *     // ... the filter for the ImportLogs we want to count
     *   }
     * })
    **/
    count<T extends ImportLogCountArgs>(
      args?: Subset<T, ImportLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportLogAggregateArgs>(args: Subset<T, ImportLogAggregateArgs>): Prisma.PrismaPromise<GetImportLogAggregateType<T>>

    /**
     * Group by ImportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportLogGroupByArgs['orderBy'] }
        : { orderBy?: ImportLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportLog model
   */
  readonly fields: ImportLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aceStatusLogs<T extends ImportLog$aceStatusLogsArgs<ExtArgs> = {}>(args?: Subset<T, ImportLog$aceStatusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findMany"> | Null>
    containerEvents<T extends ImportLog$containerEventsArgs<ExtArgs> = {}>(args?: Subset<T, ImportLog$containerEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findMany"> | Null>
    carrierFormat<T extends ImportLog$carrierFormatArgs<ExtArgs> = {}>(args?: Subset<T, ImportLog$carrierFormatArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rawRows<T extends ImportLog$rawRowsArgs<ExtArgs> = {}>(args?: Subset<T, ImportLog$rawRowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "findMany"> | Null>
    shipmentEvents<T extends ImportLog$shipmentEventsArgs<ExtArgs> = {}>(args?: Subset<T, ImportLog$shipmentEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportLog model
   */ 
  interface ImportLogFieldRefs {
    readonly fileName: FieldRef<"ImportLog", 'String'>
    readonly fileURL: FieldRef<"ImportLog", 'String'>
    readonly importedBy: FieldRef<"ImportLog", 'String'>
    readonly importedOn: FieldRef<"ImportLog", 'DateTime'>
    readonly rowsProcessed: FieldRef<"ImportLog", 'Int'>
    readonly rowsSucceeded: FieldRef<"ImportLog", 'Int'>
    readonly rowsFailed: FieldRef<"ImportLog", 'Int'>
    readonly carrierFormatId: FieldRef<"ImportLog", 'String'>
    readonly importType: FieldRef<"ImportLog", 'String'>
    readonly status: FieldRef<"ImportLog", 'String'>
    readonly errorLog: FieldRef<"ImportLog", 'String'>
    readonly aiAnalysis: FieldRef<"ImportLog", 'Json'>
    readonly aiAnalyzedAt: FieldRef<"ImportLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportLog findUnique
   */
  export type ImportLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog findUniqueOrThrow
   */
  export type ImportLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog findFirst
   */
  export type ImportLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportLogs.
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportLogs.
     */
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * ImportLog findFirstOrThrow
   */
  export type ImportLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportLogs.
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportLogs.
     */
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * ImportLog findMany
   */
  export type ImportLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLogs to fetch.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportLogs.
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * ImportLog create
   */
  export type ImportLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportLog.
     */
    data: XOR<ImportLogCreateInput, ImportLogUncheckedCreateInput>
  }

  /**
   * ImportLog createMany
   */
  export type ImportLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportLogs.
     */
    data: ImportLogCreateManyInput | ImportLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportLog createManyAndReturn
   */
  export type ImportLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportLogs.
     */
    data: ImportLogCreateManyInput | ImportLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportLog update
   */
  export type ImportLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportLog.
     */
    data: XOR<ImportLogUpdateInput, ImportLogUncheckedUpdateInput>
    /**
     * Choose, which ImportLog to update.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog updateMany
   */
  export type ImportLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportLogs.
     */
    data: XOR<ImportLogUpdateManyMutationInput, ImportLogUncheckedUpdateManyInput>
    /**
     * Filter which ImportLogs to update
     */
    where?: ImportLogWhereInput
  }

  /**
   * ImportLog upsert
   */
  export type ImportLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportLog to update in case it exists.
     */
    where: ImportLogWhereUniqueInput
    /**
     * In case the ImportLog found by the `where` argument doesn't exist, create a new ImportLog with this data.
     */
    create: XOR<ImportLogCreateInput, ImportLogUncheckedCreateInput>
    /**
     * In case the ImportLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportLogUpdateInput, ImportLogUncheckedUpdateInput>
  }

  /**
   * ImportLog delete
   */
  export type ImportLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter which ImportLog to delete.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog deleteMany
   */
  export type ImportLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportLogs to delete
     */
    where?: ImportLogWhereInput
  }

  /**
   * ImportLog.aceStatusLogs
   */
  export type ImportLog$aceStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    where?: ACEStatusLogWhereInput
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    cursor?: ACEStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ACEStatusLogScalarFieldEnum | ACEStatusLogScalarFieldEnum[]
  }

  /**
   * ImportLog.containerEvents
   */
  export type ImportLog$containerEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    where?: ContainerEventWhereInput
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    cursor?: ContainerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * ImportLog.carrierFormat
   */
  export type ImportLog$carrierFormatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    where?: CarrierFormatWhereInput
  }

  /**
   * ImportLog.rawRows
   */
  export type ImportLog$rawRowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    where?: RawRowWhereInput
    orderBy?: RawRowOrderByWithRelationInput | RawRowOrderByWithRelationInput[]
    cursor?: RawRowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawRowScalarFieldEnum | RawRowScalarFieldEnum[]
  }

  /**
   * ImportLog.shipmentEvents
   */
  export type ImportLog$shipmentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    where?: ShipmentEventWhereInput
    orderBy?: ShipmentEventOrderByWithRelationInput | ShipmentEventOrderByWithRelationInput[]
    cursor?: ShipmentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentEventScalarFieldEnum | ShipmentEventScalarFieldEnum[]
  }

  /**
   * ImportLog without action
   */
  export type ImportLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
  }


  /**
   * Model RawRow
   */

  export type AggregateRawRow = {
    _count: RawRowCountAggregateOutputType | null
    _avg: RawRowAvgAggregateOutputType | null
    _sum: RawRowSumAggregateOutputType | null
    _min: RawRowMinAggregateOutputType | null
    _max: RawRowMaxAggregateOutputType | null
  }

  export type RawRowAvgAggregateOutputType = {
    rowNumber: number | null
  }

  export type RawRowSumAggregateOutputType = {
    rowNumber: number | null
  }

  export type RawRowMinAggregateOutputType = {
    id: string | null
    importLogId: string | null
    rowNumber: number | null
    data: string | null
  }

  export type RawRowMaxAggregateOutputType = {
    id: string | null
    importLogId: string | null
    rowNumber: number | null
    data: string | null
  }

  export type RawRowCountAggregateOutputType = {
    id: number
    importLogId: number
    rowNumber: number
    data: number
    _all: number
  }


  export type RawRowAvgAggregateInputType = {
    rowNumber?: true
  }

  export type RawRowSumAggregateInputType = {
    rowNumber?: true
  }

  export type RawRowMinAggregateInputType = {
    id?: true
    importLogId?: true
    rowNumber?: true
    data?: true
  }

  export type RawRowMaxAggregateInputType = {
    id?: true
    importLogId?: true
    rowNumber?: true
    data?: true
  }

  export type RawRowCountAggregateInputType = {
    id?: true
    importLogId?: true
    rowNumber?: true
    data?: true
    _all?: true
  }

  export type RawRowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawRow to aggregate.
     */
    where?: RawRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawRows to fetch.
     */
    orderBy?: RawRowOrderByWithRelationInput | RawRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawRows
    **/
    _count?: true | RawRowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawRowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawRowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawRowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawRowMaxAggregateInputType
  }

  export type GetRawRowAggregateType<T extends RawRowAggregateArgs> = {
        [P in keyof T & keyof AggregateRawRow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawRow[P]>
      : GetScalarType<T[P], AggregateRawRow[P]>
  }




  export type RawRowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawRowWhereInput
    orderBy?: RawRowOrderByWithAggregationInput | RawRowOrderByWithAggregationInput[]
    by: RawRowScalarFieldEnum[] | RawRowScalarFieldEnum
    having?: RawRowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawRowCountAggregateInputType | true
    _avg?: RawRowAvgAggregateInputType
    _sum?: RawRowSumAggregateInputType
    _min?: RawRowMinAggregateInputType
    _max?: RawRowMaxAggregateInputType
  }

  export type RawRowGroupByOutputType = {
    id: string
    importLogId: string
    rowNumber: number
    data: string
    _count: RawRowCountAggregateOutputType | null
    _avg: RawRowAvgAggregateOutputType | null
    _sum: RawRowSumAggregateOutputType | null
    _min: RawRowMinAggregateOutputType | null
    _max: RawRowMaxAggregateOutputType | null
  }

  type GetRawRowGroupByPayload<T extends RawRowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawRowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawRowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawRowGroupByOutputType[P]>
            : GetScalarType<T[P], RawRowGroupByOutputType[P]>
        }
      >
    >


  export type RawRowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importLogId?: boolean
    rowNumber?: boolean
    data?: boolean
    importLog?: boolean | ImportLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawRow"]>

  export type RawRowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importLogId?: boolean
    rowNumber?: boolean
    data?: boolean
    importLog?: boolean | ImportLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawRow"]>

  export type RawRowSelectScalar = {
    id?: boolean
    importLogId?: boolean
    rowNumber?: boolean
    data?: boolean
  }

  export type RawRowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLog?: boolean | ImportLogDefaultArgs<ExtArgs>
  }
  export type RawRowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLog?: boolean | ImportLogDefaultArgs<ExtArgs>
  }

  export type $RawRowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawRow"
    objects: {
      importLog: Prisma.$ImportLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      importLogId: string
      rowNumber: number
      data: string
    }, ExtArgs["result"]["rawRow"]>
    composites: {}
  }

  type RawRowGetPayload<S extends boolean | null | undefined | RawRowDefaultArgs> = $Result.GetResult<Prisma.$RawRowPayload, S>

  type RawRowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RawRowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RawRowCountAggregateInputType | true
    }

  export interface RawRowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawRow'], meta: { name: 'RawRow' } }
    /**
     * Find zero or one RawRow that matches the filter.
     * @param {RawRowFindUniqueArgs} args - Arguments to find a RawRow
     * @example
     * // Get one RawRow
     * const rawRow = await prisma.rawRow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawRowFindUniqueArgs>(args: SelectSubset<T, RawRowFindUniqueArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RawRow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RawRowFindUniqueOrThrowArgs} args - Arguments to find a RawRow
     * @example
     * // Get one RawRow
     * const rawRow = await prisma.rawRow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawRowFindUniqueOrThrowArgs>(args: SelectSubset<T, RawRowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RawRow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowFindFirstArgs} args - Arguments to find a RawRow
     * @example
     * // Get one RawRow
     * const rawRow = await prisma.rawRow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawRowFindFirstArgs>(args?: SelectSubset<T, RawRowFindFirstArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RawRow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowFindFirstOrThrowArgs} args - Arguments to find a RawRow
     * @example
     * // Get one RawRow
     * const rawRow = await prisma.rawRow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawRowFindFirstOrThrowArgs>(args?: SelectSubset<T, RawRowFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RawRows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawRows
     * const rawRows = await prisma.rawRow.findMany()
     * 
     * // Get first 10 RawRows
     * const rawRows = await prisma.rawRow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rawRowWithIdOnly = await prisma.rawRow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RawRowFindManyArgs>(args?: SelectSubset<T, RawRowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RawRow.
     * @param {RawRowCreateArgs} args - Arguments to create a RawRow.
     * @example
     * // Create one RawRow
     * const RawRow = await prisma.rawRow.create({
     *   data: {
     *     // ... data to create a RawRow
     *   }
     * })
     * 
     */
    create<T extends RawRowCreateArgs>(args: SelectSubset<T, RawRowCreateArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RawRows.
     * @param {RawRowCreateManyArgs} args - Arguments to create many RawRows.
     * @example
     * // Create many RawRows
     * const rawRow = await prisma.rawRow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawRowCreateManyArgs>(args?: SelectSubset<T, RawRowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RawRows and returns the data saved in the database.
     * @param {RawRowCreateManyAndReturnArgs} args - Arguments to create many RawRows.
     * @example
     * // Create many RawRows
     * const rawRow = await prisma.rawRow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RawRows and only return the `id`
     * const rawRowWithIdOnly = await prisma.rawRow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RawRowCreateManyAndReturnArgs>(args?: SelectSubset<T, RawRowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RawRow.
     * @param {RawRowDeleteArgs} args - Arguments to delete one RawRow.
     * @example
     * // Delete one RawRow
     * const RawRow = await prisma.rawRow.delete({
     *   where: {
     *     // ... filter to delete one RawRow
     *   }
     * })
     * 
     */
    delete<T extends RawRowDeleteArgs>(args: SelectSubset<T, RawRowDeleteArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RawRow.
     * @param {RawRowUpdateArgs} args - Arguments to update one RawRow.
     * @example
     * // Update one RawRow
     * const rawRow = await prisma.rawRow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawRowUpdateArgs>(args: SelectSubset<T, RawRowUpdateArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RawRows.
     * @param {RawRowDeleteManyArgs} args - Arguments to filter RawRows to delete.
     * @example
     * // Delete a few RawRows
     * const { count } = await prisma.rawRow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawRowDeleteManyArgs>(args?: SelectSubset<T, RawRowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawRows
     * const rawRow = await prisma.rawRow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawRowUpdateManyArgs>(args: SelectSubset<T, RawRowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RawRow.
     * @param {RawRowUpsertArgs} args - Arguments to update or create a RawRow.
     * @example
     * // Update or create a RawRow
     * const rawRow = await prisma.rawRow.upsert({
     *   create: {
     *     // ... data to create a RawRow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawRow we want to update
     *   }
     * })
     */
    upsert<T extends RawRowUpsertArgs>(args: SelectSubset<T, RawRowUpsertArgs<ExtArgs>>): Prisma__RawRowClient<$Result.GetResult<Prisma.$RawRowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RawRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowCountArgs} args - Arguments to filter RawRows to count.
     * @example
     * // Count the number of RawRows
     * const count = await prisma.rawRow.count({
     *   where: {
     *     // ... the filter for the RawRows we want to count
     *   }
     * })
    **/
    count<T extends RawRowCountArgs>(
      args?: Subset<T, RawRowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawRowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawRowAggregateArgs>(args: Subset<T, RawRowAggregateArgs>): Prisma.PrismaPromise<GetRawRowAggregateType<T>>

    /**
     * Group by RawRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawRowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawRowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawRowGroupByArgs['orderBy'] }
        : { orderBy?: RawRowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawRowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawRowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawRow model
   */
  readonly fields: RawRowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawRow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawRowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importLog<T extends ImportLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImportLogDefaultArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawRow model
   */ 
  interface RawRowFieldRefs {
    readonly id: FieldRef<"RawRow", 'String'>
    readonly importLogId: FieldRef<"RawRow", 'String'>
    readonly rowNumber: FieldRef<"RawRow", 'Int'>
    readonly data: FieldRef<"RawRow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RawRow findUnique
   */
  export type RawRowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * Filter, which RawRow to fetch.
     */
    where: RawRowWhereUniqueInput
  }

  /**
   * RawRow findUniqueOrThrow
   */
  export type RawRowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * Filter, which RawRow to fetch.
     */
    where: RawRowWhereUniqueInput
  }

  /**
   * RawRow findFirst
   */
  export type RawRowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * Filter, which RawRow to fetch.
     */
    where?: RawRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawRows to fetch.
     */
    orderBy?: RawRowOrderByWithRelationInput | RawRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawRows.
     */
    cursor?: RawRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawRows.
     */
    distinct?: RawRowScalarFieldEnum | RawRowScalarFieldEnum[]
  }

  /**
   * RawRow findFirstOrThrow
   */
  export type RawRowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * Filter, which RawRow to fetch.
     */
    where?: RawRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawRows to fetch.
     */
    orderBy?: RawRowOrderByWithRelationInput | RawRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawRows.
     */
    cursor?: RawRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawRows.
     */
    distinct?: RawRowScalarFieldEnum | RawRowScalarFieldEnum[]
  }

  /**
   * RawRow findMany
   */
  export type RawRowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * Filter, which RawRows to fetch.
     */
    where?: RawRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawRows to fetch.
     */
    orderBy?: RawRowOrderByWithRelationInput | RawRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawRows.
     */
    cursor?: RawRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawRows.
     */
    skip?: number
    distinct?: RawRowScalarFieldEnum | RawRowScalarFieldEnum[]
  }

  /**
   * RawRow create
   */
  export type RawRowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * The data needed to create a RawRow.
     */
    data: XOR<RawRowCreateInput, RawRowUncheckedCreateInput>
  }

  /**
   * RawRow createMany
   */
  export type RawRowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawRows.
     */
    data: RawRowCreateManyInput | RawRowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RawRow createManyAndReturn
   */
  export type RawRowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RawRows.
     */
    data: RawRowCreateManyInput | RawRowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawRow update
   */
  export type RawRowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * The data needed to update a RawRow.
     */
    data: XOR<RawRowUpdateInput, RawRowUncheckedUpdateInput>
    /**
     * Choose, which RawRow to update.
     */
    where: RawRowWhereUniqueInput
  }

  /**
   * RawRow updateMany
   */
  export type RawRowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawRows.
     */
    data: XOR<RawRowUpdateManyMutationInput, RawRowUncheckedUpdateManyInput>
    /**
     * Filter which RawRows to update
     */
    where?: RawRowWhereInput
  }

  /**
   * RawRow upsert
   */
  export type RawRowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * The filter to search for the RawRow to update in case it exists.
     */
    where: RawRowWhereUniqueInput
    /**
     * In case the RawRow found by the `where` argument doesn't exist, create a new RawRow with this data.
     */
    create: XOR<RawRowCreateInput, RawRowUncheckedCreateInput>
    /**
     * In case the RawRow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawRowUpdateInput, RawRowUncheckedUpdateInput>
  }

  /**
   * RawRow delete
   */
  export type RawRowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
    /**
     * Filter which RawRow to delete.
     */
    where: RawRowWhereUniqueInput
  }

  /**
   * RawRow deleteMany
   */
  export type RawRowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawRows to delete
     */
    where?: RawRowWhereInput
  }

  /**
   * RawRow without action
   */
  export type RawRowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawRow
     */
    select?: RawRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawRowInclude<ExtArgs> | null
  }


  /**
   * Model TransitStage
   */

  export type AggregateTransitStage = {
    _count: TransitStageCountAggregateOutputType | null
    _avg: TransitStageAvgAggregateOutputType | null
    _sum: TransitStageSumAggregateOutputType | null
    _min: TransitStageMinAggregateOutputType | null
    _max: TransitStageMaxAggregateOutputType | null
  }

  export type TransitStageAvgAggregateOutputType = {
    sequence: number | null
    expectedDays: number | null
    alertAfterDays: number | null
  }

  export type TransitStageSumAggregateOutputType = {
    sequence: number | null
    expectedDays: number | null
    alertAfterDays: number | null
  }

  export type TransitStageMinAggregateOutputType = {
    stageName: string | null
    stageCode: string | null
    sequence: number | null
    category: string | null
    expectedDays: number | null
    alertAfterDays: number | null
    responsibleTeam: string | null
    isActive: boolean | null
    dcsaEventType: string | null
    dcsaEventCategory: string | null
    dcsaFacilityType: string | null
  }

  export type TransitStageMaxAggregateOutputType = {
    stageName: string | null
    stageCode: string | null
    sequence: number | null
    category: string | null
    expectedDays: number | null
    alertAfterDays: number | null
    responsibleTeam: string | null
    isActive: boolean | null
    dcsaEventType: string | null
    dcsaEventCategory: string | null
    dcsaFacilityType: string | null
  }

  export type TransitStageCountAggregateOutputType = {
    stageName: number
    stageCode: number
    sequence: number
    category: number
    expectedDays: number
    alertAfterDays: number
    responsibleTeam: number
    isActive: number
    dcsaEventType: number
    dcsaEventCategory: number
    dcsaFacilityType: number
    _all: number
  }


  export type TransitStageAvgAggregateInputType = {
    sequence?: true
    expectedDays?: true
    alertAfterDays?: true
  }

  export type TransitStageSumAggregateInputType = {
    sequence?: true
    expectedDays?: true
    alertAfterDays?: true
  }

  export type TransitStageMinAggregateInputType = {
    stageName?: true
    stageCode?: true
    sequence?: true
    category?: true
    expectedDays?: true
    alertAfterDays?: true
    responsibleTeam?: true
    isActive?: true
    dcsaEventType?: true
    dcsaEventCategory?: true
    dcsaFacilityType?: true
  }

  export type TransitStageMaxAggregateInputType = {
    stageName?: true
    stageCode?: true
    sequence?: true
    category?: true
    expectedDays?: true
    alertAfterDays?: true
    responsibleTeam?: true
    isActive?: true
    dcsaEventType?: true
    dcsaEventCategory?: true
    dcsaFacilityType?: true
  }

  export type TransitStageCountAggregateInputType = {
    stageName?: true
    stageCode?: true
    sequence?: true
    category?: true
    expectedDays?: true
    alertAfterDays?: true
    responsibleTeam?: true
    isActive?: true
    dcsaEventType?: true
    dcsaEventCategory?: true
    dcsaFacilityType?: true
    _all?: true
  }

  export type TransitStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransitStage to aggregate.
     */
    where?: TransitStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransitStages to fetch.
     */
    orderBy?: TransitStageOrderByWithRelationInput | TransitStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransitStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransitStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransitStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransitStages
    **/
    _count?: true | TransitStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransitStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransitStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransitStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransitStageMaxAggregateInputType
  }

  export type GetTransitStageAggregateType<T extends TransitStageAggregateArgs> = {
        [P in keyof T & keyof AggregateTransitStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransitStage[P]>
      : GetScalarType<T[P], AggregateTransitStage[P]>
  }




  export type TransitStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransitStageWhereInput
    orderBy?: TransitStageOrderByWithAggregationInput | TransitStageOrderByWithAggregationInput[]
    by: TransitStageScalarFieldEnum[] | TransitStageScalarFieldEnum
    having?: TransitStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransitStageCountAggregateInputType | true
    _avg?: TransitStageAvgAggregateInputType
    _sum?: TransitStageSumAggregateInputType
    _min?: TransitStageMinAggregateInputType
    _max?: TransitStageMaxAggregateInputType
  }

  export type TransitStageGroupByOutputType = {
    stageName: string
    stageCode: string | null
    sequence: number
    category: string | null
    expectedDays: number | null
    alertAfterDays: number | null
    responsibleTeam: string | null
    isActive: boolean
    dcsaEventType: string | null
    dcsaEventCategory: string | null
    dcsaFacilityType: string | null
    _count: TransitStageCountAggregateOutputType | null
    _avg: TransitStageAvgAggregateOutputType | null
    _sum: TransitStageSumAggregateOutputType | null
    _min: TransitStageMinAggregateOutputType | null
    _max: TransitStageMaxAggregateOutputType | null
  }

  type GetTransitStageGroupByPayload<T extends TransitStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransitStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransitStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransitStageGroupByOutputType[P]>
            : GetScalarType<T[P], TransitStageGroupByOutputType[P]>
        }
      >
    >


  export type TransitStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stageName?: boolean
    stageCode?: boolean
    sequence?: boolean
    category?: boolean
    expectedDays?: boolean
    alertAfterDays?: boolean
    responsibleTeam?: boolean
    isActive?: boolean
    dcsaEventType?: boolean
    dcsaEventCategory?: boolean
    dcsaFacilityType?: boolean
    containers?: boolean | TransitStage$containersArgs<ExtArgs>
    previousEvents?: boolean | TransitStage$previousEventsArgs<ExtArgs>
    containerEvents?: boolean | TransitStage$containerEventsArgs<ExtArgs>
    dcsaEventMaps?: boolean | TransitStage$dcsaEventMapsArgs<ExtArgs>
    _count?: boolean | TransitStageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transitStage"]>

  export type TransitStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stageName?: boolean
    stageCode?: boolean
    sequence?: boolean
    category?: boolean
    expectedDays?: boolean
    alertAfterDays?: boolean
    responsibleTeam?: boolean
    isActive?: boolean
    dcsaEventType?: boolean
    dcsaEventCategory?: boolean
    dcsaFacilityType?: boolean
  }, ExtArgs["result"]["transitStage"]>

  export type TransitStageSelectScalar = {
    stageName?: boolean
    stageCode?: boolean
    sequence?: boolean
    category?: boolean
    expectedDays?: boolean
    alertAfterDays?: boolean
    responsibleTeam?: boolean
    isActive?: boolean
    dcsaEventType?: boolean
    dcsaEventCategory?: boolean
    dcsaFacilityType?: boolean
  }

  export type TransitStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containers?: boolean | TransitStage$containersArgs<ExtArgs>
    previousEvents?: boolean | TransitStage$previousEventsArgs<ExtArgs>
    containerEvents?: boolean | TransitStage$containerEventsArgs<ExtArgs>
    dcsaEventMaps?: boolean | TransitStage$dcsaEventMapsArgs<ExtArgs>
    _count?: boolean | TransitStageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransitStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TransitStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransitStage"
    objects: {
      containers: Prisma.$ContainerPayload<ExtArgs>[]
      previousEvents: Prisma.$ContainerEventPayload<ExtArgs>[]
      containerEvents: Prisma.$ContainerEventPayload<ExtArgs>[]
      dcsaEventMaps: Prisma.$DCSAEventMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      stageName: string
      stageCode: string | null
      sequence: number
      category: string | null
      expectedDays: number | null
      alertAfterDays: number | null
      responsibleTeam: string | null
      isActive: boolean
      dcsaEventType: string | null
      dcsaEventCategory: string | null
      dcsaFacilityType: string | null
    }, ExtArgs["result"]["transitStage"]>
    composites: {}
  }

  type TransitStageGetPayload<S extends boolean | null | undefined | TransitStageDefaultArgs> = $Result.GetResult<Prisma.$TransitStagePayload, S>

  type TransitStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransitStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransitStageCountAggregateInputType | true
    }

  export interface TransitStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransitStage'], meta: { name: 'TransitStage' } }
    /**
     * Find zero or one TransitStage that matches the filter.
     * @param {TransitStageFindUniqueArgs} args - Arguments to find a TransitStage
     * @example
     * // Get one TransitStage
     * const transitStage = await prisma.transitStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransitStageFindUniqueArgs>(args: SelectSubset<T, TransitStageFindUniqueArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransitStage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransitStageFindUniqueOrThrowArgs} args - Arguments to find a TransitStage
     * @example
     * // Get one TransitStage
     * const transitStage = await prisma.transitStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransitStageFindUniqueOrThrowArgs>(args: SelectSubset<T, TransitStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransitStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageFindFirstArgs} args - Arguments to find a TransitStage
     * @example
     * // Get one TransitStage
     * const transitStage = await prisma.transitStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransitStageFindFirstArgs>(args?: SelectSubset<T, TransitStageFindFirstArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransitStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageFindFirstOrThrowArgs} args - Arguments to find a TransitStage
     * @example
     * // Get one TransitStage
     * const transitStage = await prisma.transitStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransitStageFindFirstOrThrowArgs>(args?: SelectSubset<T, TransitStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransitStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransitStages
     * const transitStages = await prisma.transitStage.findMany()
     * 
     * // Get first 10 TransitStages
     * const transitStages = await prisma.transitStage.findMany({ take: 10 })
     * 
     * // Only select the `stageName`
     * const transitStageWithStageNameOnly = await prisma.transitStage.findMany({ select: { stageName: true } })
     * 
     */
    findMany<T extends TransitStageFindManyArgs>(args?: SelectSubset<T, TransitStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransitStage.
     * @param {TransitStageCreateArgs} args - Arguments to create a TransitStage.
     * @example
     * // Create one TransitStage
     * const TransitStage = await prisma.transitStage.create({
     *   data: {
     *     // ... data to create a TransitStage
     *   }
     * })
     * 
     */
    create<T extends TransitStageCreateArgs>(args: SelectSubset<T, TransitStageCreateArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransitStages.
     * @param {TransitStageCreateManyArgs} args - Arguments to create many TransitStages.
     * @example
     * // Create many TransitStages
     * const transitStage = await prisma.transitStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransitStageCreateManyArgs>(args?: SelectSubset<T, TransitStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransitStages and returns the data saved in the database.
     * @param {TransitStageCreateManyAndReturnArgs} args - Arguments to create many TransitStages.
     * @example
     * // Create many TransitStages
     * const transitStage = await prisma.transitStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransitStages and only return the `stageName`
     * const transitStageWithStageNameOnly = await prisma.transitStage.createManyAndReturn({ 
     *   select: { stageName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransitStageCreateManyAndReturnArgs>(args?: SelectSubset<T, TransitStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransitStage.
     * @param {TransitStageDeleteArgs} args - Arguments to delete one TransitStage.
     * @example
     * // Delete one TransitStage
     * const TransitStage = await prisma.transitStage.delete({
     *   where: {
     *     // ... filter to delete one TransitStage
     *   }
     * })
     * 
     */
    delete<T extends TransitStageDeleteArgs>(args: SelectSubset<T, TransitStageDeleteArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransitStage.
     * @param {TransitStageUpdateArgs} args - Arguments to update one TransitStage.
     * @example
     * // Update one TransitStage
     * const transitStage = await prisma.transitStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransitStageUpdateArgs>(args: SelectSubset<T, TransitStageUpdateArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransitStages.
     * @param {TransitStageDeleteManyArgs} args - Arguments to filter TransitStages to delete.
     * @example
     * // Delete a few TransitStages
     * const { count } = await prisma.transitStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransitStageDeleteManyArgs>(args?: SelectSubset<T, TransitStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransitStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransitStages
     * const transitStage = await prisma.transitStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransitStageUpdateManyArgs>(args: SelectSubset<T, TransitStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransitStage.
     * @param {TransitStageUpsertArgs} args - Arguments to update or create a TransitStage.
     * @example
     * // Update or create a TransitStage
     * const transitStage = await prisma.transitStage.upsert({
     *   create: {
     *     // ... data to create a TransitStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransitStage we want to update
     *   }
     * })
     */
    upsert<T extends TransitStageUpsertArgs>(args: SelectSubset<T, TransitStageUpsertArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransitStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageCountArgs} args - Arguments to filter TransitStages to count.
     * @example
     * // Count the number of TransitStages
     * const count = await prisma.transitStage.count({
     *   where: {
     *     // ... the filter for the TransitStages we want to count
     *   }
     * })
    **/
    count<T extends TransitStageCountArgs>(
      args?: Subset<T, TransitStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransitStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransitStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransitStageAggregateArgs>(args: Subset<T, TransitStageAggregateArgs>): Prisma.PrismaPromise<GetTransitStageAggregateType<T>>

    /**
     * Group by TransitStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransitStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransitStageGroupByArgs['orderBy'] }
        : { orderBy?: TransitStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransitStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransitStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransitStage model
   */
  readonly fields: TransitStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransitStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransitStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    containers<T extends TransitStage$containersArgs<ExtArgs> = {}>(args?: Subset<T, TransitStage$containersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findMany"> | Null>
    previousEvents<T extends TransitStage$previousEventsArgs<ExtArgs> = {}>(args?: Subset<T, TransitStage$previousEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findMany"> | Null>
    containerEvents<T extends TransitStage$containerEventsArgs<ExtArgs> = {}>(args?: Subset<T, TransitStage$containerEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findMany"> | Null>
    dcsaEventMaps<T extends TransitStage$dcsaEventMapsArgs<ExtArgs> = {}>(args?: Subset<T, TransitStage$dcsaEventMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransitStage model
   */ 
  interface TransitStageFieldRefs {
    readonly stageName: FieldRef<"TransitStage", 'String'>
    readonly stageCode: FieldRef<"TransitStage", 'String'>
    readonly sequence: FieldRef<"TransitStage", 'Int'>
    readonly category: FieldRef<"TransitStage", 'String'>
    readonly expectedDays: FieldRef<"TransitStage", 'Int'>
    readonly alertAfterDays: FieldRef<"TransitStage", 'Int'>
    readonly responsibleTeam: FieldRef<"TransitStage", 'String'>
    readonly isActive: FieldRef<"TransitStage", 'Boolean'>
    readonly dcsaEventType: FieldRef<"TransitStage", 'String'>
    readonly dcsaEventCategory: FieldRef<"TransitStage", 'String'>
    readonly dcsaFacilityType: FieldRef<"TransitStage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransitStage findUnique
   */
  export type TransitStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * Filter, which TransitStage to fetch.
     */
    where: TransitStageWhereUniqueInput
  }

  /**
   * TransitStage findUniqueOrThrow
   */
  export type TransitStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * Filter, which TransitStage to fetch.
     */
    where: TransitStageWhereUniqueInput
  }

  /**
   * TransitStage findFirst
   */
  export type TransitStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * Filter, which TransitStage to fetch.
     */
    where?: TransitStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransitStages to fetch.
     */
    orderBy?: TransitStageOrderByWithRelationInput | TransitStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransitStages.
     */
    cursor?: TransitStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransitStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransitStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransitStages.
     */
    distinct?: TransitStageScalarFieldEnum | TransitStageScalarFieldEnum[]
  }

  /**
   * TransitStage findFirstOrThrow
   */
  export type TransitStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * Filter, which TransitStage to fetch.
     */
    where?: TransitStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransitStages to fetch.
     */
    orderBy?: TransitStageOrderByWithRelationInput | TransitStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransitStages.
     */
    cursor?: TransitStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransitStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransitStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransitStages.
     */
    distinct?: TransitStageScalarFieldEnum | TransitStageScalarFieldEnum[]
  }

  /**
   * TransitStage findMany
   */
  export type TransitStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * Filter, which TransitStages to fetch.
     */
    where?: TransitStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransitStages to fetch.
     */
    orderBy?: TransitStageOrderByWithRelationInput | TransitStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransitStages.
     */
    cursor?: TransitStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransitStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransitStages.
     */
    skip?: number
    distinct?: TransitStageScalarFieldEnum | TransitStageScalarFieldEnum[]
  }

  /**
   * TransitStage create
   */
  export type TransitStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * The data needed to create a TransitStage.
     */
    data: XOR<TransitStageCreateInput, TransitStageUncheckedCreateInput>
  }

  /**
   * TransitStage createMany
   */
  export type TransitStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransitStages.
     */
    data: TransitStageCreateManyInput | TransitStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransitStage createManyAndReturn
   */
  export type TransitStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransitStages.
     */
    data: TransitStageCreateManyInput | TransitStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransitStage update
   */
  export type TransitStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * The data needed to update a TransitStage.
     */
    data: XOR<TransitStageUpdateInput, TransitStageUncheckedUpdateInput>
    /**
     * Choose, which TransitStage to update.
     */
    where: TransitStageWhereUniqueInput
  }

  /**
   * TransitStage updateMany
   */
  export type TransitStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransitStages.
     */
    data: XOR<TransitStageUpdateManyMutationInput, TransitStageUncheckedUpdateManyInput>
    /**
     * Filter which TransitStages to update
     */
    where?: TransitStageWhereInput
  }

  /**
   * TransitStage upsert
   */
  export type TransitStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * The filter to search for the TransitStage to update in case it exists.
     */
    where: TransitStageWhereUniqueInput
    /**
     * In case the TransitStage found by the `where` argument doesn't exist, create a new TransitStage with this data.
     */
    create: XOR<TransitStageCreateInput, TransitStageUncheckedCreateInput>
    /**
     * In case the TransitStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransitStageUpdateInput, TransitStageUncheckedUpdateInput>
  }

  /**
   * TransitStage delete
   */
  export type TransitStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    /**
     * Filter which TransitStage to delete.
     */
    where: TransitStageWhereUniqueInput
  }

  /**
   * TransitStage deleteMany
   */
  export type TransitStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransitStages to delete
     */
    where?: TransitStageWhereInput
  }

  /**
   * TransitStage.containers
   */
  export type TransitStage$containersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    cursor?: ContainerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * TransitStage.previousEvents
   */
  export type TransitStage$previousEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    where?: ContainerEventWhereInput
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    cursor?: ContainerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * TransitStage.containerEvents
   */
  export type TransitStage$containerEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    where?: ContainerEventWhereInput
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    cursor?: ContainerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * TransitStage.dcsaEventMaps
   */
  export type TransitStage$dcsaEventMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    where?: DCSAEventMapWhereInput
    orderBy?: DCSAEventMapOrderByWithRelationInput | DCSAEventMapOrderByWithRelationInput[]
    cursor?: DCSAEventMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DCSAEventMapScalarFieldEnum | DCSAEventMapScalarFieldEnum[]
  }

  /**
   * TransitStage without action
   */
  export type TransitStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
  }


  /**
   * Model Shipment
   */

  export type AggregateShipment = {
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  export type ShipmentAvgAggregateOutputType = {
    totalWeight: number | null
    totalPieces: number | null
    expectedContainers: number | null
    amountDue: number | null
    dutyAmount: number | null
  }

  export type ShipmentSumAggregateOutputType = {
    totalWeight: number | null
    totalPieces: number | null
    expectedContainers: number | null
    amountDue: number | null
    dutyAmount: number | null
  }

  export type ShipmentMinAggregateOutputType = {
    shipmentReference: string | null
    hbl: string | null
    mbl: string | null
    bookingReference: string | null
    shipmentType: string | null
    carrier: string | null
    forwarder: string | null
    shipper: string | null
    consignee: string | null
    pol: string | null
    pod: string | null
    finalDestination: string | null
    contents: string | null
    supplier: string | null
    totalWeight: number | null
    totalPieces: number | null
    customerReference: string | null
    poNumber: string | null
    incoTerms: string | null
    expectedContainers: number | null
    blType: string | null
    blStatus: string | null
    paymentStatus: string | null
    paymentDueDate: Date | null
    amountDue: number | null
    releaseStatus: string | null
    releaseDate: Date | null
    holdReason: string | null
    notes: string | null
    aceEntryNumber: string | null
    aceEntryType: string | null
    dutyAmount: number | null
    liquidationStatus: string | null
    liquidationDate: Date | null
  }

  export type ShipmentMaxAggregateOutputType = {
    shipmentReference: string | null
    hbl: string | null
    mbl: string | null
    bookingReference: string | null
    shipmentType: string | null
    carrier: string | null
    forwarder: string | null
    shipper: string | null
    consignee: string | null
    pol: string | null
    pod: string | null
    finalDestination: string | null
    contents: string | null
    supplier: string | null
    totalWeight: number | null
    totalPieces: number | null
    customerReference: string | null
    poNumber: string | null
    incoTerms: string | null
    expectedContainers: number | null
    blType: string | null
    blStatus: string | null
    paymentStatus: string | null
    paymentDueDate: Date | null
    amountDue: number | null
    releaseStatus: string | null
    releaseDate: Date | null
    holdReason: string | null
    notes: string | null
    aceEntryNumber: string | null
    aceEntryType: string | null
    dutyAmount: number | null
    liquidationStatus: string | null
    liquidationDate: Date | null
  }

  export type ShipmentCountAggregateOutputType = {
    shipmentReference: number
    hbl: number
    mbl: number
    bookingReference: number
    shipmentType: number
    carrier: number
    forwarder: number
    shipper: number
    consignee: number
    pol: number
    pod: number
    finalDestination: number
    contents: number
    supplier: number
    totalWeight: number
    totalPieces: number
    customerReference: number
    poNumber: number
    incoTerms: number
    expectedContainers: number
    blType: number
    blStatus: number
    paymentStatus: number
    paymentDueDate: number
    amountDue: number
    releaseStatus: number
    releaseDate: number
    holdReason: number
    notes: number
    aceEntryNumber: number
    aceEntryType: number
    dutyAmount: number
    liquidationStatus: number
    liquidationDate: number
    _all: number
  }


  export type ShipmentAvgAggregateInputType = {
    totalWeight?: true
    totalPieces?: true
    expectedContainers?: true
    amountDue?: true
    dutyAmount?: true
  }

  export type ShipmentSumAggregateInputType = {
    totalWeight?: true
    totalPieces?: true
    expectedContainers?: true
    amountDue?: true
    dutyAmount?: true
  }

  export type ShipmentMinAggregateInputType = {
    shipmentReference?: true
    hbl?: true
    mbl?: true
    bookingReference?: true
    shipmentType?: true
    carrier?: true
    forwarder?: true
    shipper?: true
    consignee?: true
    pol?: true
    pod?: true
    finalDestination?: true
    contents?: true
    supplier?: true
    totalWeight?: true
    totalPieces?: true
    customerReference?: true
    poNumber?: true
    incoTerms?: true
    expectedContainers?: true
    blType?: true
    blStatus?: true
    paymentStatus?: true
    paymentDueDate?: true
    amountDue?: true
    releaseStatus?: true
    releaseDate?: true
    holdReason?: true
    notes?: true
    aceEntryNumber?: true
    aceEntryType?: true
    dutyAmount?: true
    liquidationStatus?: true
    liquidationDate?: true
  }

  export type ShipmentMaxAggregateInputType = {
    shipmentReference?: true
    hbl?: true
    mbl?: true
    bookingReference?: true
    shipmentType?: true
    carrier?: true
    forwarder?: true
    shipper?: true
    consignee?: true
    pol?: true
    pod?: true
    finalDestination?: true
    contents?: true
    supplier?: true
    totalWeight?: true
    totalPieces?: true
    customerReference?: true
    poNumber?: true
    incoTerms?: true
    expectedContainers?: true
    blType?: true
    blStatus?: true
    paymentStatus?: true
    paymentDueDate?: true
    amountDue?: true
    releaseStatus?: true
    releaseDate?: true
    holdReason?: true
    notes?: true
    aceEntryNumber?: true
    aceEntryType?: true
    dutyAmount?: true
    liquidationStatus?: true
    liquidationDate?: true
  }

  export type ShipmentCountAggregateInputType = {
    shipmentReference?: true
    hbl?: true
    mbl?: true
    bookingReference?: true
    shipmentType?: true
    carrier?: true
    forwarder?: true
    shipper?: true
    consignee?: true
    pol?: true
    pod?: true
    finalDestination?: true
    contents?: true
    supplier?: true
    totalWeight?: true
    totalPieces?: true
    customerReference?: true
    poNumber?: true
    incoTerms?: true
    expectedContainers?: true
    blType?: true
    blStatus?: true
    paymentStatus?: true
    paymentDueDate?: true
    amountDue?: true
    releaseStatus?: true
    releaseDate?: true
    holdReason?: true
    notes?: true
    aceEntryNumber?: true
    aceEntryType?: true
    dutyAmount?: true
    liquidationStatus?: true
    liquidationDate?: true
    _all?: true
  }

  export type ShipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipment to aggregate.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shipments
    **/
    _count?: true | ShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentMaxAggregateInputType
  }

  export type GetShipmentAggregateType<T extends ShipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipment[P]>
      : GetScalarType<T[P], AggregateShipment[P]>
  }




  export type ShipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithAggregationInput | ShipmentOrderByWithAggregationInput[]
    by: ShipmentScalarFieldEnum[] | ShipmentScalarFieldEnum
    having?: ShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentCountAggregateInputType | true
    _avg?: ShipmentAvgAggregateInputType
    _sum?: ShipmentSumAggregateInputType
    _min?: ShipmentMinAggregateInputType
    _max?: ShipmentMaxAggregateInputType
  }

  export type ShipmentGroupByOutputType = {
    shipmentReference: string
    hbl: string | null
    mbl: string | null
    bookingReference: string | null
    shipmentType: string | null
    carrier: string | null
    forwarder: string | null
    shipper: string | null
    consignee: string | null
    pol: string | null
    pod: string | null
    finalDestination: string | null
    contents: string | null
    supplier: string | null
    totalWeight: number | null
    totalPieces: number | null
    customerReference: string | null
    poNumber: string | null
    incoTerms: string | null
    expectedContainers: number | null
    blType: string | null
    blStatus: string | null
    paymentStatus: string | null
    paymentDueDate: Date | null
    amountDue: number | null
    releaseStatus: string | null
    releaseDate: Date | null
    holdReason: string | null
    notes: string | null
    aceEntryNumber: string | null
    aceEntryType: string | null
    dutyAmount: number | null
    liquidationStatus: string | null
    liquidationDate: Date | null
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  type GetShipmentGroupByPayload<T extends ShipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shipmentReference?: boolean
    hbl?: boolean
    mbl?: boolean
    bookingReference?: boolean
    shipmentType?: boolean
    carrier?: boolean
    forwarder?: boolean
    shipper?: boolean
    consignee?: boolean
    pol?: boolean
    pod?: boolean
    finalDestination?: boolean
    contents?: boolean
    supplier?: boolean
    totalWeight?: boolean
    totalPieces?: boolean
    customerReference?: boolean
    poNumber?: boolean
    incoTerms?: boolean
    expectedContainers?: boolean
    blType?: boolean
    blStatus?: boolean
    paymentStatus?: boolean
    paymentDueDate?: boolean
    amountDue?: boolean
    releaseStatus?: boolean
    releaseDate?: boolean
    holdReason?: boolean
    notes?: boolean
    aceEntryNumber?: boolean
    aceEntryType?: boolean
    dutyAmount?: boolean
    liquidationStatus?: boolean
    liquidationDate?: boolean
    aceStatusLogs?: boolean | Shipment$aceStatusLogsArgs<ExtArgs>
    shipmentContainers?: boolean | Shipment$shipmentContainersArgs<ExtArgs>
    shipmentEvents?: boolean | Shipment$shipmentEventsArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shipmentReference?: boolean
    hbl?: boolean
    mbl?: boolean
    bookingReference?: boolean
    shipmentType?: boolean
    carrier?: boolean
    forwarder?: boolean
    shipper?: boolean
    consignee?: boolean
    pol?: boolean
    pod?: boolean
    finalDestination?: boolean
    contents?: boolean
    supplier?: boolean
    totalWeight?: boolean
    totalPieces?: boolean
    customerReference?: boolean
    poNumber?: boolean
    incoTerms?: boolean
    expectedContainers?: boolean
    blType?: boolean
    blStatus?: boolean
    paymentStatus?: boolean
    paymentDueDate?: boolean
    amountDue?: boolean
    releaseStatus?: boolean
    releaseDate?: boolean
    holdReason?: boolean
    notes?: boolean
    aceEntryNumber?: boolean
    aceEntryType?: boolean
    dutyAmount?: boolean
    liquidationStatus?: boolean
    liquidationDate?: boolean
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectScalar = {
    shipmentReference?: boolean
    hbl?: boolean
    mbl?: boolean
    bookingReference?: boolean
    shipmentType?: boolean
    carrier?: boolean
    forwarder?: boolean
    shipper?: boolean
    consignee?: boolean
    pol?: boolean
    pod?: boolean
    finalDestination?: boolean
    contents?: boolean
    supplier?: boolean
    totalWeight?: boolean
    totalPieces?: boolean
    customerReference?: boolean
    poNumber?: boolean
    incoTerms?: boolean
    expectedContainers?: boolean
    blType?: boolean
    blStatus?: boolean
    paymentStatus?: boolean
    paymentDueDate?: boolean
    amountDue?: boolean
    releaseStatus?: boolean
    releaseDate?: boolean
    holdReason?: boolean
    notes?: boolean
    aceEntryNumber?: boolean
    aceEntryType?: boolean
    dutyAmount?: boolean
    liquidationStatus?: boolean
    liquidationDate?: boolean
  }

  export type ShipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aceStatusLogs?: boolean | Shipment$aceStatusLogsArgs<ExtArgs>
    shipmentContainers?: boolean | Shipment$shipmentContainersArgs<ExtArgs>
    shipmentEvents?: boolean | Shipment$shipmentEventsArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipment"
    objects: {
      aceStatusLogs: Prisma.$ACEStatusLogPayload<ExtArgs>[]
      shipmentContainers: Prisma.$ShipmentContainerPayload<ExtArgs>[]
      shipmentEvents: Prisma.$ShipmentEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shipmentReference: string
      hbl: string | null
      mbl: string | null
      bookingReference: string | null
      shipmentType: string | null
      carrier: string | null
      forwarder: string | null
      shipper: string | null
      consignee: string | null
      pol: string | null
      pod: string | null
      finalDestination: string | null
      contents: string | null
      supplier: string | null
      totalWeight: number | null
      totalPieces: number | null
      customerReference: string | null
      poNumber: string | null
      incoTerms: string | null
      expectedContainers: number | null
      blType: string | null
      blStatus: string | null
      paymentStatus: string | null
      paymentDueDate: Date | null
      amountDue: number | null
      releaseStatus: string | null
      releaseDate: Date | null
      holdReason: string | null
      notes: string | null
      aceEntryNumber: string | null
      aceEntryType: string | null
      dutyAmount: number | null
      liquidationStatus: string | null
      liquidationDate: Date | null
    }, ExtArgs["result"]["shipment"]>
    composites: {}
  }

  type ShipmentGetPayload<S extends boolean | null | undefined | ShipmentDefaultArgs> = $Result.GetResult<Prisma.$ShipmentPayload, S>

  type ShipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShipmentCountAggregateInputType | true
    }

  export interface ShipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipment'], meta: { name: 'Shipment' } }
    /**
     * Find zero or one Shipment that matches the filter.
     * @param {ShipmentFindUniqueArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentFindUniqueArgs>(args: SelectSubset<T, ShipmentFindUniqueArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShipmentFindUniqueOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentFindFirstArgs>(args?: SelectSubset<T, ShipmentFindFirstArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shipments
     * const shipments = await prisma.shipment.findMany()
     * 
     * // Get first 10 Shipments
     * const shipments = await prisma.shipment.findMany({ take: 10 })
     * 
     * // Only select the `shipmentReference`
     * const shipmentWithShipmentReferenceOnly = await prisma.shipment.findMany({ select: { shipmentReference: true } })
     * 
     */
    findMany<T extends ShipmentFindManyArgs>(args?: SelectSubset<T, ShipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shipment.
     * @param {ShipmentCreateArgs} args - Arguments to create a Shipment.
     * @example
     * // Create one Shipment
     * const Shipment = await prisma.shipment.create({
     *   data: {
     *     // ... data to create a Shipment
     *   }
     * })
     * 
     */
    create<T extends ShipmentCreateArgs>(args: SelectSubset<T, ShipmentCreateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shipments.
     * @param {ShipmentCreateManyArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentCreateManyArgs>(args?: SelectSubset<T, ShipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shipments and returns the data saved in the database.
     * @param {ShipmentCreateManyAndReturnArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shipments and only return the `shipmentReference`
     * const shipmentWithShipmentReferenceOnly = await prisma.shipment.createManyAndReturn({ 
     *   select: { shipmentReference: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shipment.
     * @param {ShipmentDeleteArgs} args - Arguments to delete one Shipment.
     * @example
     * // Delete one Shipment
     * const Shipment = await prisma.shipment.delete({
     *   where: {
     *     // ... filter to delete one Shipment
     *   }
     * })
     * 
     */
    delete<T extends ShipmentDeleteArgs>(args: SelectSubset<T, ShipmentDeleteArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shipment.
     * @param {ShipmentUpdateArgs} args - Arguments to update one Shipment.
     * @example
     * // Update one Shipment
     * const shipment = await prisma.shipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentUpdateArgs>(args: SelectSubset<T, ShipmentUpdateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shipments.
     * @param {ShipmentDeleteManyArgs} args - Arguments to filter Shipments to delete.
     * @example
     * // Delete a few Shipments
     * const { count } = await prisma.shipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentDeleteManyArgs>(args?: SelectSubset<T, ShipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentUpdateManyArgs>(args: SelectSubset<T, ShipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shipment.
     * @param {ShipmentUpsertArgs} args - Arguments to update or create a Shipment.
     * @example
     * // Update or create a Shipment
     * const shipment = await prisma.shipment.upsert({
     *   create: {
     *     // ... data to create a Shipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipment we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentUpsertArgs>(args: SelectSubset<T, ShipmentUpsertArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentCountArgs} args - Arguments to filter Shipments to count.
     * @example
     * // Count the number of Shipments
     * const count = await prisma.shipment.count({
     *   where: {
     *     // ... the filter for the Shipments we want to count
     *   }
     * })
    **/
    count<T extends ShipmentCountArgs>(
      args?: Subset<T, ShipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentAggregateArgs>(args: Subset<T, ShipmentAggregateArgs>): Prisma.PrismaPromise<GetShipmentAggregateType<T>>

    /**
     * Group by Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipment model
   */
  readonly fields: ShipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aceStatusLogs<T extends Shipment$aceStatusLogsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$aceStatusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findMany"> | Null>
    shipmentContainers<T extends Shipment$shipmentContainersArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$shipmentContainersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findMany"> | Null>
    shipmentEvents<T extends Shipment$shipmentEventsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$shipmentEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipment model
   */ 
  interface ShipmentFieldRefs {
    readonly shipmentReference: FieldRef<"Shipment", 'String'>
    readonly hbl: FieldRef<"Shipment", 'String'>
    readonly mbl: FieldRef<"Shipment", 'String'>
    readonly bookingReference: FieldRef<"Shipment", 'String'>
    readonly shipmentType: FieldRef<"Shipment", 'String'>
    readonly carrier: FieldRef<"Shipment", 'String'>
    readonly forwarder: FieldRef<"Shipment", 'String'>
    readonly shipper: FieldRef<"Shipment", 'String'>
    readonly consignee: FieldRef<"Shipment", 'String'>
    readonly pol: FieldRef<"Shipment", 'String'>
    readonly pod: FieldRef<"Shipment", 'String'>
    readonly finalDestination: FieldRef<"Shipment", 'String'>
    readonly contents: FieldRef<"Shipment", 'String'>
    readonly supplier: FieldRef<"Shipment", 'String'>
    readonly totalWeight: FieldRef<"Shipment", 'Float'>
    readonly totalPieces: FieldRef<"Shipment", 'Int'>
    readonly customerReference: FieldRef<"Shipment", 'String'>
    readonly poNumber: FieldRef<"Shipment", 'String'>
    readonly incoTerms: FieldRef<"Shipment", 'String'>
    readonly expectedContainers: FieldRef<"Shipment", 'Int'>
    readonly blType: FieldRef<"Shipment", 'String'>
    readonly blStatus: FieldRef<"Shipment", 'String'>
    readonly paymentStatus: FieldRef<"Shipment", 'String'>
    readonly paymentDueDate: FieldRef<"Shipment", 'DateTime'>
    readonly amountDue: FieldRef<"Shipment", 'Float'>
    readonly releaseStatus: FieldRef<"Shipment", 'String'>
    readonly releaseDate: FieldRef<"Shipment", 'DateTime'>
    readonly holdReason: FieldRef<"Shipment", 'String'>
    readonly notes: FieldRef<"Shipment", 'String'>
    readonly aceEntryNumber: FieldRef<"Shipment", 'String'>
    readonly aceEntryType: FieldRef<"Shipment", 'String'>
    readonly dutyAmount: FieldRef<"Shipment", 'Float'>
    readonly liquidationStatus: FieldRef<"Shipment", 'String'>
    readonly liquidationDate: FieldRef<"Shipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shipment findUnique
   */
  export type ShipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findUniqueOrThrow
   */
  export type ShipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findFirst
   */
  export type ShipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findFirstOrThrow
   */
  export type ShipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findMany
   */
  export type ShipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipments to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment create
   */
  export type ShipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipment.
     */
    data: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
  }

  /**
   * Shipment createMany
   */
  export type ShipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipment createManyAndReturn
   */
  export type ShipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipment update
   */
  export type ShipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipment.
     */
    data: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
    /**
     * Choose, which Shipment to update.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment updateMany
   */
  export type ShipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
  }

  /**
   * Shipment upsert
   */
  export type ShipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipment to update in case it exists.
     */
    where: ShipmentWhereUniqueInput
    /**
     * In case the Shipment found by the `where` argument doesn't exist, create a new Shipment with this data.
     */
    create: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
    /**
     * In case the Shipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
  }

  /**
   * Shipment delete
   */
  export type ShipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter which Shipment to delete.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment deleteMany
   */
  export type ShipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipments to delete
     */
    where?: ShipmentWhereInput
  }

  /**
   * Shipment.aceStatusLogs
   */
  export type Shipment$aceStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    where?: ACEStatusLogWhereInput
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    cursor?: ACEStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ACEStatusLogScalarFieldEnum | ACEStatusLogScalarFieldEnum[]
  }

  /**
   * Shipment.shipmentContainers
   */
  export type Shipment$shipmentContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    where?: ShipmentContainerWhereInput
    orderBy?: ShipmentContainerOrderByWithRelationInput | ShipmentContainerOrderByWithRelationInput[]
    cursor?: ShipmentContainerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentContainerScalarFieldEnum | ShipmentContainerScalarFieldEnum[]
  }

  /**
   * Shipment.shipmentEvents
   */
  export type Shipment$shipmentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    where?: ShipmentEventWhereInput
    orderBy?: ShipmentEventOrderByWithRelationInput | ShipmentEventOrderByWithRelationInput[]
    cursor?: ShipmentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentEventScalarFieldEnum | ShipmentEventScalarFieldEnum[]
  }

  /**
   * Shipment without action
   */
  export type ShipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
  }


  /**
   * Model Container
   */

  export type AggregateContainer = {
    _count: ContainerCountAggregateOutputType | null
    _avg: ContainerAvgAggregateOutputType | null
    _sum: ContainerSumAggregateOutputType | null
    _min: ContainerMinAggregateOutputType | null
    _max: ContainerMaxAggregateOutputType | null
  }

  export type ContainerAvgAggregateOutputType = {
    grossWeight: number | null
  }

  export type ContainerSumAggregateOutputType = {
    grossWeight: number | null
  }

  export type ContainerMinAggregateOutputType = {
    containerNumber: string | null
    containerType: string | null
    currentStatus: string | null
    currentLocation: string | null
    currentVessel: string | null
    currentVoyage: string | null
    mbl: string | null
    carrier: string | null
    pol: string | null
    pod: string | null
    etd: Date | null
    atd: Date | null
    eta: Date | null
    ata: Date | null
    lastFreeDay: Date | null
    detentionFreeDay: Date | null
    statusLastUpdated: Date | null
    hasException: boolean | null
    exceptionType: string | null
    exceptionOwner: string | null
    exceptionNotes: string | null
    exceptionDate: Date | null
    manualPriority: string | null
    priorityReason: string | null
    prioritySetBy: string | null
    prioritySetDate: Date | null
    notes: string | null
    emptyIndicator: boolean | null
    sealNumber: string | null
    grossWeight: number | null
    carrierEventId: string | null
    aceEntryNumber: string | null
    aceDisposition: string | null
    aceStatus: string | null
    aceLastUpdated: Date | null
    pgaHold: boolean | null
    pgaAgency: string | null
    pgaHoldReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContainerMaxAggregateOutputType = {
    containerNumber: string | null
    containerType: string | null
    currentStatus: string | null
    currentLocation: string | null
    currentVessel: string | null
    currentVoyage: string | null
    mbl: string | null
    carrier: string | null
    pol: string | null
    pod: string | null
    etd: Date | null
    atd: Date | null
    eta: Date | null
    ata: Date | null
    lastFreeDay: Date | null
    detentionFreeDay: Date | null
    statusLastUpdated: Date | null
    hasException: boolean | null
    exceptionType: string | null
    exceptionOwner: string | null
    exceptionNotes: string | null
    exceptionDate: Date | null
    manualPriority: string | null
    priorityReason: string | null
    prioritySetBy: string | null
    prioritySetDate: Date | null
    notes: string | null
    emptyIndicator: boolean | null
    sealNumber: string | null
    grossWeight: number | null
    carrierEventId: string | null
    aceEntryNumber: string | null
    aceDisposition: string | null
    aceStatus: string | null
    aceLastUpdated: Date | null
    pgaHold: boolean | null
    pgaAgency: string | null
    pgaHoldReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContainerCountAggregateOutputType = {
    containerNumber: number
    containerType: number
    currentStatus: number
    currentLocation: number
    currentVessel: number
    currentVoyage: number
    mbl: number
    carrier: number
    pol: number
    pod: number
    etd: number
    atd: number
    eta: number
    ata: number
    lastFreeDay: number
    detentionFreeDay: number
    statusLastUpdated: number
    hasException: number
    exceptionType: number
    exceptionOwner: number
    exceptionNotes: number
    exceptionDate: number
    manualPriority: number
    priorityReason: number
    prioritySetBy: number
    prioritySetDate: number
    notes: number
    emptyIndicator: number
    sealNumber: number
    grossWeight: number
    carrierEventId: number
    aceEntryNumber: number
    aceDisposition: number
    aceStatus: number
    aceLastUpdated: number
    pgaHold: number
    pgaAgency: number
    pgaHoldReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContainerAvgAggregateInputType = {
    grossWeight?: true
  }

  export type ContainerSumAggregateInputType = {
    grossWeight?: true
  }

  export type ContainerMinAggregateInputType = {
    containerNumber?: true
    containerType?: true
    currentStatus?: true
    currentLocation?: true
    currentVessel?: true
    currentVoyage?: true
    mbl?: true
    carrier?: true
    pol?: true
    pod?: true
    etd?: true
    atd?: true
    eta?: true
    ata?: true
    lastFreeDay?: true
    detentionFreeDay?: true
    statusLastUpdated?: true
    hasException?: true
    exceptionType?: true
    exceptionOwner?: true
    exceptionNotes?: true
    exceptionDate?: true
    manualPriority?: true
    priorityReason?: true
    prioritySetBy?: true
    prioritySetDate?: true
    notes?: true
    emptyIndicator?: true
    sealNumber?: true
    grossWeight?: true
    carrierEventId?: true
    aceEntryNumber?: true
    aceDisposition?: true
    aceStatus?: true
    aceLastUpdated?: true
    pgaHold?: true
    pgaAgency?: true
    pgaHoldReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContainerMaxAggregateInputType = {
    containerNumber?: true
    containerType?: true
    currentStatus?: true
    currentLocation?: true
    currentVessel?: true
    currentVoyage?: true
    mbl?: true
    carrier?: true
    pol?: true
    pod?: true
    etd?: true
    atd?: true
    eta?: true
    ata?: true
    lastFreeDay?: true
    detentionFreeDay?: true
    statusLastUpdated?: true
    hasException?: true
    exceptionType?: true
    exceptionOwner?: true
    exceptionNotes?: true
    exceptionDate?: true
    manualPriority?: true
    priorityReason?: true
    prioritySetBy?: true
    prioritySetDate?: true
    notes?: true
    emptyIndicator?: true
    sealNumber?: true
    grossWeight?: true
    carrierEventId?: true
    aceEntryNumber?: true
    aceDisposition?: true
    aceStatus?: true
    aceLastUpdated?: true
    pgaHold?: true
    pgaAgency?: true
    pgaHoldReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContainerCountAggregateInputType = {
    containerNumber?: true
    containerType?: true
    currentStatus?: true
    currentLocation?: true
    currentVessel?: true
    currentVoyage?: true
    mbl?: true
    carrier?: true
    pol?: true
    pod?: true
    etd?: true
    atd?: true
    eta?: true
    ata?: true
    lastFreeDay?: true
    detentionFreeDay?: true
    statusLastUpdated?: true
    hasException?: true
    exceptionType?: true
    exceptionOwner?: true
    exceptionNotes?: true
    exceptionDate?: true
    manualPriority?: true
    priorityReason?: true
    prioritySetBy?: true
    prioritySetDate?: true
    notes?: true
    emptyIndicator?: true
    sealNumber?: true
    grossWeight?: true
    carrierEventId?: true
    aceEntryNumber?: true
    aceDisposition?: true
    aceStatus?: true
    aceLastUpdated?: true
    pgaHold?: true
    pgaAgency?: true
    pgaHoldReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContainerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Container to aggregate.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Containers
    **/
    _count?: true | ContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerMaxAggregateInputType
  }

  export type GetContainerAggregateType<T extends ContainerAggregateArgs> = {
        [P in keyof T & keyof AggregateContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainer[P]>
      : GetScalarType<T[P], AggregateContainer[P]>
  }




  export type ContainerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerWhereInput
    orderBy?: ContainerOrderByWithAggregationInput | ContainerOrderByWithAggregationInput[]
    by: ContainerScalarFieldEnum[] | ContainerScalarFieldEnum
    having?: ContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerCountAggregateInputType | true
    _avg?: ContainerAvgAggregateInputType
    _sum?: ContainerSumAggregateInputType
    _min?: ContainerMinAggregateInputType
    _max?: ContainerMaxAggregateInputType
  }

  export type ContainerGroupByOutputType = {
    containerNumber: string
    containerType: string | null
    currentStatus: string | null
    currentLocation: string | null
    currentVessel: string | null
    currentVoyage: string | null
    mbl: string | null
    carrier: string | null
    pol: string | null
    pod: string | null
    etd: Date | null
    atd: Date | null
    eta: Date | null
    ata: Date | null
    lastFreeDay: Date | null
    detentionFreeDay: Date | null
    statusLastUpdated: Date | null
    hasException: boolean
    exceptionType: string | null
    exceptionOwner: string | null
    exceptionNotes: string | null
    exceptionDate: Date | null
    manualPriority: string | null
    priorityReason: string | null
    prioritySetBy: string | null
    prioritySetDate: Date | null
    notes: string | null
    emptyIndicator: boolean | null
    sealNumber: string | null
    grossWeight: number | null
    carrierEventId: string | null
    aceEntryNumber: string | null
    aceDisposition: string | null
    aceStatus: string | null
    aceLastUpdated: Date | null
    pgaHold: boolean | null
    pgaAgency: string | null
    pgaHoldReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContainerCountAggregateOutputType | null
    _avg: ContainerAvgAggregateOutputType | null
    _sum: ContainerSumAggregateOutputType | null
    _min: ContainerMinAggregateOutputType | null
    _max: ContainerMaxAggregateOutputType | null
  }

  type GetContainerGroupByPayload<T extends ContainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerGroupByOutputType[P]>
        }
      >
    >


  export type ContainerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    containerNumber?: boolean
    containerType?: boolean
    currentStatus?: boolean
    currentLocation?: boolean
    currentVessel?: boolean
    currentVoyage?: boolean
    mbl?: boolean
    carrier?: boolean
    pol?: boolean
    pod?: boolean
    etd?: boolean
    atd?: boolean
    eta?: boolean
    ata?: boolean
    lastFreeDay?: boolean
    detentionFreeDay?: boolean
    statusLastUpdated?: boolean
    hasException?: boolean
    exceptionType?: boolean
    exceptionOwner?: boolean
    exceptionNotes?: boolean
    exceptionDate?: boolean
    manualPriority?: boolean
    priorityReason?: boolean
    prioritySetBy?: boolean
    prioritySetDate?: boolean
    notes?: boolean
    emptyIndicator?: boolean
    sealNumber?: boolean
    grossWeight?: boolean
    carrierEventId?: boolean
    aceEntryNumber?: boolean
    aceDisposition?: boolean
    aceStatus?: boolean
    aceLastUpdated?: boolean
    pgaHold?: boolean
    pgaAgency?: boolean
    pgaHoldReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aceStatusLogs?: boolean | Container$aceStatusLogsArgs<ExtArgs>
    stage?: boolean | Container$stageArgs<ExtArgs>
    events?: boolean | Container$eventsArgs<ExtArgs>
    shipmentContainers?: boolean | Container$shipmentContainersArgs<ExtArgs>
    attentionFlags?: boolean | Container$attentionFlagsArgs<ExtArgs>
    activityLogs?: boolean | Container$activityLogsArgs<ExtArgs>
    statusOverrides?: boolean | Container$statusOverridesArgs<ExtArgs>
    riskAssessment?: boolean | Container$riskAssessmentArgs<ExtArgs>
    _count?: boolean | ContainerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    containerNumber?: boolean
    containerType?: boolean
    currentStatus?: boolean
    currentLocation?: boolean
    currentVessel?: boolean
    currentVoyage?: boolean
    mbl?: boolean
    carrier?: boolean
    pol?: boolean
    pod?: boolean
    etd?: boolean
    atd?: boolean
    eta?: boolean
    ata?: boolean
    lastFreeDay?: boolean
    detentionFreeDay?: boolean
    statusLastUpdated?: boolean
    hasException?: boolean
    exceptionType?: boolean
    exceptionOwner?: boolean
    exceptionNotes?: boolean
    exceptionDate?: boolean
    manualPriority?: boolean
    priorityReason?: boolean
    prioritySetBy?: boolean
    prioritySetDate?: boolean
    notes?: boolean
    emptyIndicator?: boolean
    sealNumber?: boolean
    grossWeight?: boolean
    carrierEventId?: boolean
    aceEntryNumber?: boolean
    aceDisposition?: boolean
    aceStatus?: boolean
    aceLastUpdated?: boolean
    pgaHold?: boolean
    pgaAgency?: boolean
    pgaHoldReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stage?: boolean | Container$stageArgs<ExtArgs>
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectScalar = {
    containerNumber?: boolean
    containerType?: boolean
    currentStatus?: boolean
    currentLocation?: boolean
    currentVessel?: boolean
    currentVoyage?: boolean
    mbl?: boolean
    carrier?: boolean
    pol?: boolean
    pod?: boolean
    etd?: boolean
    atd?: boolean
    eta?: boolean
    ata?: boolean
    lastFreeDay?: boolean
    detentionFreeDay?: boolean
    statusLastUpdated?: boolean
    hasException?: boolean
    exceptionType?: boolean
    exceptionOwner?: boolean
    exceptionNotes?: boolean
    exceptionDate?: boolean
    manualPriority?: boolean
    priorityReason?: boolean
    prioritySetBy?: boolean
    prioritySetDate?: boolean
    notes?: boolean
    emptyIndicator?: boolean
    sealNumber?: boolean
    grossWeight?: boolean
    carrierEventId?: boolean
    aceEntryNumber?: boolean
    aceDisposition?: boolean
    aceStatus?: boolean
    aceLastUpdated?: boolean
    pgaHold?: boolean
    pgaAgency?: boolean
    pgaHoldReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContainerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aceStatusLogs?: boolean | Container$aceStatusLogsArgs<ExtArgs>
    stage?: boolean | Container$stageArgs<ExtArgs>
    events?: boolean | Container$eventsArgs<ExtArgs>
    shipmentContainers?: boolean | Container$shipmentContainersArgs<ExtArgs>
    attentionFlags?: boolean | Container$attentionFlagsArgs<ExtArgs>
    activityLogs?: boolean | Container$activityLogsArgs<ExtArgs>
    statusOverrides?: boolean | Container$statusOverridesArgs<ExtArgs>
    riskAssessment?: boolean | Container$riskAssessmentArgs<ExtArgs>
    _count?: boolean | ContainerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContainerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stage?: boolean | Container$stageArgs<ExtArgs>
  }

  export type $ContainerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Container"
    objects: {
      aceStatusLogs: Prisma.$ACEStatusLogPayload<ExtArgs>[]
      stage: Prisma.$TransitStagePayload<ExtArgs> | null
      events: Prisma.$ContainerEventPayload<ExtArgs>[]
      shipmentContainers: Prisma.$ShipmentContainerPayload<ExtArgs>[]
      attentionFlags: Prisma.$AttentionFlagPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      statusOverrides: Prisma.$StatusOverridePayload<ExtArgs>[]
      riskAssessment: Prisma.$RiskAssessmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      containerNumber: string
      containerType: string | null
      currentStatus: string | null
      currentLocation: string | null
      currentVessel: string | null
      currentVoyage: string | null
      mbl: string | null
      carrier: string | null
      pol: string | null
      pod: string | null
      etd: Date | null
      atd: Date | null
      eta: Date | null
      ata: Date | null
      lastFreeDay: Date | null
      detentionFreeDay: Date | null
      statusLastUpdated: Date | null
      hasException: boolean
      exceptionType: string | null
      exceptionOwner: string | null
      exceptionNotes: string | null
      exceptionDate: Date | null
      manualPriority: string | null
      priorityReason: string | null
      prioritySetBy: string | null
      prioritySetDate: Date | null
      notes: string | null
      emptyIndicator: boolean | null
      sealNumber: string | null
      grossWeight: number | null
      carrierEventId: string | null
      aceEntryNumber: string | null
      aceDisposition: string | null
      aceStatus: string | null
      aceLastUpdated: Date | null
      pgaHold: boolean | null
      pgaAgency: string | null
      pgaHoldReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["container"]>
    composites: {}
  }

  type ContainerGetPayload<S extends boolean | null | undefined | ContainerDefaultArgs> = $Result.GetResult<Prisma.$ContainerPayload, S>

  type ContainerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContainerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContainerCountAggregateInputType | true
    }

  export interface ContainerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Container'], meta: { name: 'Container' } }
    /**
     * Find zero or one Container that matches the filter.
     * @param {ContainerFindUniqueArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerFindUniqueArgs>(args: SelectSubset<T, ContainerFindUniqueArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Container that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContainerFindUniqueOrThrowArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Container that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindFirstArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerFindFirstArgs>(args?: SelectSubset<T, ContainerFindFirstArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Container that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindFirstOrThrowArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Containers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Containers
     * const containers = await prisma.container.findMany()
     * 
     * // Get first 10 Containers
     * const containers = await prisma.container.findMany({ take: 10 })
     * 
     * // Only select the `containerNumber`
     * const containerWithContainerNumberOnly = await prisma.container.findMany({ select: { containerNumber: true } })
     * 
     */
    findMany<T extends ContainerFindManyArgs>(args?: SelectSubset<T, ContainerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Container.
     * @param {ContainerCreateArgs} args - Arguments to create a Container.
     * @example
     * // Create one Container
     * const Container = await prisma.container.create({
     *   data: {
     *     // ... data to create a Container
     *   }
     * })
     * 
     */
    create<T extends ContainerCreateArgs>(args: SelectSubset<T, ContainerCreateArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Containers.
     * @param {ContainerCreateManyArgs} args - Arguments to create many Containers.
     * @example
     * // Create many Containers
     * const container = await prisma.container.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerCreateManyArgs>(args?: SelectSubset<T, ContainerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Containers and returns the data saved in the database.
     * @param {ContainerCreateManyAndReturnArgs} args - Arguments to create many Containers.
     * @example
     * // Create many Containers
     * const container = await prisma.container.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Containers and only return the `containerNumber`
     * const containerWithContainerNumberOnly = await prisma.container.createManyAndReturn({ 
     *   select: { containerNumber: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Container.
     * @param {ContainerDeleteArgs} args - Arguments to delete one Container.
     * @example
     * // Delete one Container
     * const Container = await prisma.container.delete({
     *   where: {
     *     // ... filter to delete one Container
     *   }
     * })
     * 
     */
    delete<T extends ContainerDeleteArgs>(args: SelectSubset<T, ContainerDeleteArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Container.
     * @param {ContainerUpdateArgs} args - Arguments to update one Container.
     * @example
     * // Update one Container
     * const container = await prisma.container.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerUpdateArgs>(args: SelectSubset<T, ContainerUpdateArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Containers.
     * @param {ContainerDeleteManyArgs} args - Arguments to filter Containers to delete.
     * @example
     * // Delete a few Containers
     * const { count } = await prisma.container.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerDeleteManyArgs>(args?: SelectSubset<T, ContainerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Containers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Containers
     * const container = await prisma.container.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerUpdateManyArgs>(args: SelectSubset<T, ContainerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Container.
     * @param {ContainerUpsertArgs} args - Arguments to update or create a Container.
     * @example
     * // Update or create a Container
     * const container = await prisma.container.upsert({
     *   create: {
     *     // ... data to create a Container
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Container we want to update
     *   }
     * })
     */
    upsert<T extends ContainerUpsertArgs>(args: SelectSubset<T, ContainerUpsertArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Containers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerCountArgs} args - Arguments to filter Containers to count.
     * @example
     * // Count the number of Containers
     * const count = await prisma.container.count({
     *   where: {
     *     // ... the filter for the Containers we want to count
     *   }
     * })
    **/
    count<T extends ContainerCountArgs>(
      args?: Subset<T, ContainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Container.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerAggregateArgs>(args: Subset<T, ContainerAggregateArgs>): Prisma.PrismaPromise<GetContainerAggregateType<T>>

    /**
     * Group by Container.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerGroupByArgs['orderBy'] }
        : { orderBy?: ContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Container model
   */
  readonly fields: ContainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Container.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aceStatusLogs<T extends Container$aceStatusLogsArgs<ExtArgs> = {}>(args?: Subset<T, Container$aceStatusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findMany"> | Null>
    stage<T extends Container$stageArgs<ExtArgs> = {}>(args?: Subset<T, Container$stageArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Container$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Container$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findMany"> | Null>
    shipmentContainers<T extends Container$shipmentContainersArgs<ExtArgs> = {}>(args?: Subset<T, Container$shipmentContainersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findMany"> | Null>
    attentionFlags<T extends Container$attentionFlagsArgs<ExtArgs> = {}>(args?: Subset<T, Container$attentionFlagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "findMany"> | Null>
    activityLogs<T extends Container$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Container$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    statusOverrides<T extends Container$statusOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Container$statusOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "findMany"> | Null>
    riskAssessment<T extends Container$riskAssessmentArgs<ExtArgs> = {}>(args?: Subset<T, Container$riskAssessmentArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Container model
   */ 
  interface ContainerFieldRefs {
    readonly containerNumber: FieldRef<"Container", 'String'>
    readonly containerType: FieldRef<"Container", 'String'>
    readonly currentStatus: FieldRef<"Container", 'String'>
    readonly currentLocation: FieldRef<"Container", 'String'>
    readonly currentVessel: FieldRef<"Container", 'String'>
    readonly currentVoyage: FieldRef<"Container", 'String'>
    readonly mbl: FieldRef<"Container", 'String'>
    readonly carrier: FieldRef<"Container", 'String'>
    readonly pol: FieldRef<"Container", 'String'>
    readonly pod: FieldRef<"Container", 'String'>
    readonly etd: FieldRef<"Container", 'DateTime'>
    readonly atd: FieldRef<"Container", 'DateTime'>
    readonly eta: FieldRef<"Container", 'DateTime'>
    readonly ata: FieldRef<"Container", 'DateTime'>
    readonly lastFreeDay: FieldRef<"Container", 'DateTime'>
    readonly detentionFreeDay: FieldRef<"Container", 'DateTime'>
    readonly statusLastUpdated: FieldRef<"Container", 'DateTime'>
    readonly hasException: FieldRef<"Container", 'Boolean'>
    readonly exceptionType: FieldRef<"Container", 'String'>
    readonly exceptionOwner: FieldRef<"Container", 'String'>
    readonly exceptionNotes: FieldRef<"Container", 'String'>
    readonly exceptionDate: FieldRef<"Container", 'DateTime'>
    readonly manualPriority: FieldRef<"Container", 'String'>
    readonly priorityReason: FieldRef<"Container", 'String'>
    readonly prioritySetBy: FieldRef<"Container", 'String'>
    readonly prioritySetDate: FieldRef<"Container", 'DateTime'>
    readonly notes: FieldRef<"Container", 'String'>
    readonly emptyIndicator: FieldRef<"Container", 'Boolean'>
    readonly sealNumber: FieldRef<"Container", 'String'>
    readonly grossWeight: FieldRef<"Container", 'Float'>
    readonly carrierEventId: FieldRef<"Container", 'String'>
    readonly aceEntryNumber: FieldRef<"Container", 'String'>
    readonly aceDisposition: FieldRef<"Container", 'String'>
    readonly aceStatus: FieldRef<"Container", 'String'>
    readonly aceLastUpdated: FieldRef<"Container", 'DateTime'>
    readonly pgaHold: FieldRef<"Container", 'Boolean'>
    readonly pgaAgency: FieldRef<"Container", 'String'>
    readonly pgaHoldReason: FieldRef<"Container", 'String'>
    readonly createdAt: FieldRef<"Container", 'DateTime'>
    readonly updatedAt: FieldRef<"Container", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Container findUnique
   */
  export type ContainerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container findUniqueOrThrow
   */
  export type ContainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container findFirst
   */
  export type ContainerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Containers.
     */
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container findFirstOrThrow
   */
  export type ContainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Containers.
     */
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container findMany
   */
  export type ContainerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Containers to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container create
   */
  export type ContainerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * The data needed to create a Container.
     */
    data: XOR<ContainerCreateInput, ContainerUncheckedCreateInput>
  }

  /**
   * Container createMany
   */
  export type ContainerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Containers.
     */
    data: ContainerCreateManyInput | ContainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Container createManyAndReturn
   */
  export type ContainerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Containers.
     */
    data: ContainerCreateManyInput | ContainerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Container update
   */
  export type ContainerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * The data needed to update a Container.
     */
    data: XOR<ContainerUpdateInput, ContainerUncheckedUpdateInput>
    /**
     * Choose, which Container to update.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container updateMany
   */
  export type ContainerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Containers.
     */
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyInput>
    /**
     * Filter which Containers to update
     */
    where?: ContainerWhereInput
  }

  /**
   * Container upsert
   */
  export type ContainerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * The filter to search for the Container to update in case it exists.
     */
    where: ContainerWhereUniqueInput
    /**
     * In case the Container found by the `where` argument doesn't exist, create a new Container with this data.
     */
    create: XOR<ContainerCreateInput, ContainerUncheckedCreateInput>
    /**
     * In case the Container was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerUpdateInput, ContainerUncheckedUpdateInput>
  }

  /**
   * Container delete
   */
  export type ContainerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter which Container to delete.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container deleteMany
   */
  export type ContainerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Containers to delete
     */
    where?: ContainerWhereInput
  }

  /**
   * Container.aceStatusLogs
   */
  export type Container$aceStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    where?: ACEStatusLogWhereInput
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    cursor?: ACEStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ACEStatusLogScalarFieldEnum | ACEStatusLogScalarFieldEnum[]
  }

  /**
   * Container.stage
   */
  export type Container$stageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    where?: TransitStageWhereInput
  }

  /**
   * Container.events
   */
  export type Container$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    where?: ContainerEventWhereInput
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    cursor?: ContainerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * Container.shipmentContainers
   */
  export type Container$shipmentContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    where?: ShipmentContainerWhereInput
    orderBy?: ShipmentContainerOrderByWithRelationInput | ShipmentContainerOrderByWithRelationInput[]
    cursor?: ShipmentContainerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentContainerScalarFieldEnum | ShipmentContainerScalarFieldEnum[]
  }

  /**
   * Container.attentionFlags
   */
  export type Container$attentionFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    where?: AttentionFlagWhereInput
    orderBy?: AttentionFlagOrderByWithRelationInput | AttentionFlagOrderByWithRelationInput[]
    cursor?: AttentionFlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttentionFlagScalarFieldEnum | AttentionFlagScalarFieldEnum[]
  }

  /**
   * Container.activityLogs
   */
  export type Container$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Container.statusOverrides
   */
  export type Container$statusOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    where?: StatusOverrideWhereInput
    orderBy?: StatusOverrideOrderByWithRelationInput | StatusOverrideOrderByWithRelationInput[]
    cursor?: StatusOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusOverrideScalarFieldEnum | StatusOverrideScalarFieldEnum[]
  }

  /**
   * Container.riskAssessment
   */
  export type Container$riskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    where?: RiskAssessmentWhereInput
  }

  /**
   * Container without action
   */
  export type ContainerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
  }


  /**
   * Model ShipmentContainer
   */

  export type AggregateShipmentContainer = {
    _count: ShipmentContainerCountAggregateOutputType | null
    _avg: ShipmentContainerAvgAggregateOutputType | null
    _sum: ShipmentContainerSumAggregateOutputType | null
    _min: ShipmentContainerMinAggregateOutputType | null
    _max: ShipmentContainerMaxAggregateOutputType | null
  }

  export type ShipmentContainerAvgAggregateOutputType = {
    piecesInContainer: number | null
    weightInContainer: number | null
  }

  export type ShipmentContainerSumAggregateOutputType = {
    piecesInContainer: number | null
    weightInContainer: number | null
  }

  export type ShipmentContainerMinAggregateOutputType = {
    id: string | null
    shipmentId: string | null
    containerId: string | null
    piecesInContainer: number | null
    weightInContainer: number | null
    notes: string | null
  }

  export type ShipmentContainerMaxAggregateOutputType = {
    id: string | null
    shipmentId: string | null
    containerId: string | null
    piecesInContainer: number | null
    weightInContainer: number | null
    notes: string | null
  }

  export type ShipmentContainerCountAggregateOutputType = {
    id: number
    shipmentId: number
    containerId: number
    piecesInContainer: number
    weightInContainer: number
    notes: number
    _all: number
  }


  export type ShipmentContainerAvgAggregateInputType = {
    piecesInContainer?: true
    weightInContainer?: true
  }

  export type ShipmentContainerSumAggregateInputType = {
    piecesInContainer?: true
    weightInContainer?: true
  }

  export type ShipmentContainerMinAggregateInputType = {
    id?: true
    shipmentId?: true
    containerId?: true
    piecesInContainer?: true
    weightInContainer?: true
    notes?: true
  }

  export type ShipmentContainerMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    containerId?: true
    piecesInContainer?: true
    weightInContainer?: true
    notes?: true
  }

  export type ShipmentContainerCountAggregateInputType = {
    id?: true
    shipmentId?: true
    containerId?: true
    piecesInContainer?: true
    weightInContainer?: true
    notes?: true
    _all?: true
  }

  export type ShipmentContainerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentContainer to aggregate.
     */
    where?: ShipmentContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentContainers to fetch.
     */
    orderBy?: ShipmentContainerOrderByWithRelationInput | ShipmentContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentContainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentContainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShipmentContainers
    **/
    _count?: true | ShipmentContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentContainerMaxAggregateInputType
  }

  export type GetShipmentContainerAggregateType<T extends ShipmentContainerAggregateArgs> = {
        [P in keyof T & keyof AggregateShipmentContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipmentContainer[P]>
      : GetScalarType<T[P], AggregateShipmentContainer[P]>
  }




  export type ShipmentContainerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentContainerWhereInput
    orderBy?: ShipmentContainerOrderByWithAggregationInput | ShipmentContainerOrderByWithAggregationInput[]
    by: ShipmentContainerScalarFieldEnum[] | ShipmentContainerScalarFieldEnum
    having?: ShipmentContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentContainerCountAggregateInputType | true
    _avg?: ShipmentContainerAvgAggregateInputType
    _sum?: ShipmentContainerSumAggregateInputType
    _min?: ShipmentContainerMinAggregateInputType
    _max?: ShipmentContainerMaxAggregateInputType
  }

  export type ShipmentContainerGroupByOutputType = {
    id: string
    shipmentId: string
    containerId: string
    piecesInContainer: number | null
    weightInContainer: number | null
    notes: string | null
    _count: ShipmentContainerCountAggregateOutputType | null
    _avg: ShipmentContainerAvgAggregateOutputType | null
    _sum: ShipmentContainerSumAggregateOutputType | null
    _min: ShipmentContainerMinAggregateOutputType | null
    _max: ShipmentContainerMaxAggregateOutputType | null
  }

  type GetShipmentContainerGroupByPayload<T extends ShipmentContainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentContainerGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentContainerGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentContainerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    containerId?: boolean
    piecesInContainer?: boolean
    weightInContainer?: boolean
    notes?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentContainer"]>

  export type ShipmentContainerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    containerId?: boolean
    piecesInContainer?: boolean
    weightInContainer?: boolean
    notes?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentContainer"]>

  export type ShipmentContainerSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    containerId?: boolean
    piecesInContainer?: boolean
    weightInContainer?: boolean
    notes?: boolean
  }

  export type ShipmentContainerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }
  export type ShipmentContainerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }

  export type $ShipmentContainerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShipmentContainer"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs>
      shipment: Prisma.$ShipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shipmentId: string
      containerId: string
      piecesInContainer: number | null
      weightInContainer: number | null
      notes: string | null
    }, ExtArgs["result"]["shipmentContainer"]>
    composites: {}
  }

  type ShipmentContainerGetPayload<S extends boolean | null | undefined | ShipmentContainerDefaultArgs> = $Result.GetResult<Prisma.$ShipmentContainerPayload, S>

  type ShipmentContainerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShipmentContainerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShipmentContainerCountAggregateInputType | true
    }

  export interface ShipmentContainerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShipmentContainer'], meta: { name: 'ShipmentContainer' } }
    /**
     * Find zero or one ShipmentContainer that matches the filter.
     * @param {ShipmentContainerFindUniqueArgs} args - Arguments to find a ShipmentContainer
     * @example
     * // Get one ShipmentContainer
     * const shipmentContainer = await prisma.shipmentContainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentContainerFindUniqueArgs>(args: SelectSubset<T, ShipmentContainerFindUniqueArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShipmentContainer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShipmentContainerFindUniqueOrThrowArgs} args - Arguments to find a ShipmentContainer
     * @example
     * // Get one ShipmentContainer
     * const shipmentContainer = await prisma.shipmentContainer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentContainerFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentContainerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShipmentContainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerFindFirstArgs} args - Arguments to find a ShipmentContainer
     * @example
     * // Get one ShipmentContainer
     * const shipmentContainer = await prisma.shipmentContainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentContainerFindFirstArgs>(args?: SelectSubset<T, ShipmentContainerFindFirstArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShipmentContainer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerFindFirstOrThrowArgs} args - Arguments to find a ShipmentContainer
     * @example
     * // Get one ShipmentContainer
     * const shipmentContainer = await prisma.shipmentContainer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentContainerFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentContainerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShipmentContainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShipmentContainers
     * const shipmentContainers = await prisma.shipmentContainer.findMany()
     * 
     * // Get first 10 ShipmentContainers
     * const shipmentContainers = await prisma.shipmentContainer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentContainerWithIdOnly = await prisma.shipmentContainer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentContainerFindManyArgs>(args?: SelectSubset<T, ShipmentContainerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShipmentContainer.
     * @param {ShipmentContainerCreateArgs} args - Arguments to create a ShipmentContainer.
     * @example
     * // Create one ShipmentContainer
     * const ShipmentContainer = await prisma.shipmentContainer.create({
     *   data: {
     *     // ... data to create a ShipmentContainer
     *   }
     * })
     * 
     */
    create<T extends ShipmentContainerCreateArgs>(args: SelectSubset<T, ShipmentContainerCreateArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShipmentContainers.
     * @param {ShipmentContainerCreateManyArgs} args - Arguments to create many ShipmentContainers.
     * @example
     * // Create many ShipmentContainers
     * const shipmentContainer = await prisma.shipmentContainer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentContainerCreateManyArgs>(args?: SelectSubset<T, ShipmentContainerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShipmentContainers and returns the data saved in the database.
     * @param {ShipmentContainerCreateManyAndReturnArgs} args - Arguments to create many ShipmentContainers.
     * @example
     * // Create many ShipmentContainers
     * const shipmentContainer = await prisma.shipmentContainer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShipmentContainers and only return the `id`
     * const shipmentContainerWithIdOnly = await prisma.shipmentContainer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentContainerCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentContainerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShipmentContainer.
     * @param {ShipmentContainerDeleteArgs} args - Arguments to delete one ShipmentContainer.
     * @example
     * // Delete one ShipmentContainer
     * const ShipmentContainer = await prisma.shipmentContainer.delete({
     *   where: {
     *     // ... filter to delete one ShipmentContainer
     *   }
     * })
     * 
     */
    delete<T extends ShipmentContainerDeleteArgs>(args: SelectSubset<T, ShipmentContainerDeleteArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShipmentContainer.
     * @param {ShipmentContainerUpdateArgs} args - Arguments to update one ShipmentContainer.
     * @example
     * // Update one ShipmentContainer
     * const shipmentContainer = await prisma.shipmentContainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentContainerUpdateArgs>(args: SelectSubset<T, ShipmentContainerUpdateArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShipmentContainers.
     * @param {ShipmentContainerDeleteManyArgs} args - Arguments to filter ShipmentContainers to delete.
     * @example
     * // Delete a few ShipmentContainers
     * const { count } = await prisma.shipmentContainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentContainerDeleteManyArgs>(args?: SelectSubset<T, ShipmentContainerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShipmentContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShipmentContainers
     * const shipmentContainer = await prisma.shipmentContainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentContainerUpdateManyArgs>(args: SelectSubset<T, ShipmentContainerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShipmentContainer.
     * @param {ShipmentContainerUpsertArgs} args - Arguments to update or create a ShipmentContainer.
     * @example
     * // Update or create a ShipmentContainer
     * const shipmentContainer = await prisma.shipmentContainer.upsert({
     *   create: {
     *     // ... data to create a ShipmentContainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShipmentContainer we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentContainerUpsertArgs>(args: SelectSubset<T, ShipmentContainerUpsertArgs<ExtArgs>>): Prisma__ShipmentContainerClient<$Result.GetResult<Prisma.$ShipmentContainerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShipmentContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerCountArgs} args - Arguments to filter ShipmentContainers to count.
     * @example
     * // Count the number of ShipmentContainers
     * const count = await prisma.shipmentContainer.count({
     *   where: {
     *     // ... the filter for the ShipmentContainers we want to count
     *   }
     * })
    **/
    count<T extends ShipmentContainerCountArgs>(
      args?: Subset<T, ShipmentContainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShipmentContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentContainerAggregateArgs>(args: Subset<T, ShipmentContainerAggregateArgs>): Prisma.PrismaPromise<GetShipmentContainerAggregateType<T>>

    /**
     * Group by ShipmentContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentContainerGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentContainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShipmentContainer model
   */
  readonly fields: ShipmentContainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShipmentContainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentContainerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShipmentContainer model
   */ 
  interface ShipmentContainerFieldRefs {
    readonly id: FieldRef<"ShipmentContainer", 'String'>
    readonly shipmentId: FieldRef<"ShipmentContainer", 'String'>
    readonly containerId: FieldRef<"ShipmentContainer", 'String'>
    readonly piecesInContainer: FieldRef<"ShipmentContainer", 'Int'>
    readonly weightInContainer: FieldRef<"ShipmentContainer", 'Float'>
    readonly notes: FieldRef<"ShipmentContainer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShipmentContainer findUnique
   */
  export type ShipmentContainerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentContainer to fetch.
     */
    where: ShipmentContainerWhereUniqueInput
  }

  /**
   * ShipmentContainer findUniqueOrThrow
   */
  export type ShipmentContainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentContainer to fetch.
     */
    where: ShipmentContainerWhereUniqueInput
  }

  /**
   * ShipmentContainer findFirst
   */
  export type ShipmentContainerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentContainer to fetch.
     */
    where?: ShipmentContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentContainers to fetch.
     */
    orderBy?: ShipmentContainerOrderByWithRelationInput | ShipmentContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentContainers.
     */
    cursor?: ShipmentContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentContainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentContainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentContainers.
     */
    distinct?: ShipmentContainerScalarFieldEnum | ShipmentContainerScalarFieldEnum[]
  }

  /**
   * ShipmentContainer findFirstOrThrow
   */
  export type ShipmentContainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentContainer to fetch.
     */
    where?: ShipmentContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentContainers to fetch.
     */
    orderBy?: ShipmentContainerOrderByWithRelationInput | ShipmentContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentContainers.
     */
    cursor?: ShipmentContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentContainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentContainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentContainers.
     */
    distinct?: ShipmentContainerScalarFieldEnum | ShipmentContainerScalarFieldEnum[]
  }

  /**
   * ShipmentContainer findMany
   */
  export type ShipmentContainerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentContainers to fetch.
     */
    where?: ShipmentContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentContainers to fetch.
     */
    orderBy?: ShipmentContainerOrderByWithRelationInput | ShipmentContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShipmentContainers.
     */
    cursor?: ShipmentContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentContainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentContainers.
     */
    skip?: number
    distinct?: ShipmentContainerScalarFieldEnum | ShipmentContainerScalarFieldEnum[]
  }

  /**
   * ShipmentContainer create
   */
  export type ShipmentContainerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * The data needed to create a ShipmentContainer.
     */
    data: XOR<ShipmentContainerCreateInput, ShipmentContainerUncheckedCreateInput>
  }

  /**
   * ShipmentContainer createMany
   */
  export type ShipmentContainerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShipmentContainers.
     */
    data: ShipmentContainerCreateManyInput | ShipmentContainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShipmentContainer createManyAndReturn
   */
  export type ShipmentContainerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShipmentContainers.
     */
    data: ShipmentContainerCreateManyInput | ShipmentContainerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShipmentContainer update
   */
  export type ShipmentContainerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * The data needed to update a ShipmentContainer.
     */
    data: XOR<ShipmentContainerUpdateInput, ShipmentContainerUncheckedUpdateInput>
    /**
     * Choose, which ShipmentContainer to update.
     */
    where: ShipmentContainerWhereUniqueInput
  }

  /**
   * ShipmentContainer updateMany
   */
  export type ShipmentContainerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShipmentContainers.
     */
    data: XOR<ShipmentContainerUpdateManyMutationInput, ShipmentContainerUncheckedUpdateManyInput>
    /**
     * Filter which ShipmentContainers to update
     */
    where?: ShipmentContainerWhereInput
  }

  /**
   * ShipmentContainer upsert
   */
  export type ShipmentContainerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * The filter to search for the ShipmentContainer to update in case it exists.
     */
    where: ShipmentContainerWhereUniqueInput
    /**
     * In case the ShipmentContainer found by the `where` argument doesn't exist, create a new ShipmentContainer with this data.
     */
    create: XOR<ShipmentContainerCreateInput, ShipmentContainerUncheckedCreateInput>
    /**
     * In case the ShipmentContainer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentContainerUpdateInput, ShipmentContainerUncheckedUpdateInput>
  }

  /**
   * ShipmentContainer delete
   */
  export type ShipmentContainerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
    /**
     * Filter which ShipmentContainer to delete.
     */
    where: ShipmentContainerWhereUniqueInput
  }

  /**
   * ShipmentContainer deleteMany
   */
  export type ShipmentContainerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentContainers to delete
     */
    where?: ShipmentContainerWhereInput
  }

  /**
   * ShipmentContainer without action
   */
  export type ShipmentContainerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentContainer
     */
    select?: ShipmentContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentContainerInclude<ExtArgs> | null
  }


  /**
   * Model ContainerEvent
   */

  export type AggregateContainerEvent = {
    _count: ContainerEventCountAggregateOutputType | null
    _min: ContainerEventMinAggregateOutputType | null
    _max: ContainerEventMaxAggregateOutputType | null
  }

  export type ContainerEventMinAggregateOutputType = {
    id: string | null
    containerId: string | null
    stageName: string | null
    eventDateTime: Date | null
    location: string | null
    facilityId: string | null
    vessel: string | null
    voyage: string | null
    source: string | null
    sourceFileId: string | null
    updatedBy: string | null
    updatedOn: Date | null
    previousStatus: string | null
    exceptionCleared: boolean | null
    notes: string | null
    eventCategory: string | null
    eventClassifier: string | null
    dcsaEventType: string | null
    transportMode: string | null
    facilityType: string | null
    emptyIndicator: boolean | null
    carrierEventId: string | null
  }

  export type ContainerEventMaxAggregateOutputType = {
    id: string | null
    containerId: string | null
    stageName: string | null
    eventDateTime: Date | null
    location: string | null
    facilityId: string | null
    vessel: string | null
    voyage: string | null
    source: string | null
    sourceFileId: string | null
    updatedBy: string | null
    updatedOn: Date | null
    previousStatus: string | null
    exceptionCleared: boolean | null
    notes: string | null
    eventCategory: string | null
    eventClassifier: string | null
    dcsaEventType: string | null
    transportMode: string | null
    facilityType: string | null
    emptyIndicator: boolean | null
    carrierEventId: string | null
  }

  export type ContainerEventCountAggregateOutputType = {
    id: number
    containerId: number
    stageName: number
    eventDateTime: number
    location: number
    facilityId: number
    vessel: number
    voyage: number
    source: number
    sourceFileId: number
    updatedBy: number
    updatedOn: number
    previousStatus: number
    exceptionCleared: number
    notes: number
    eventCategory: number
    eventClassifier: number
    dcsaEventType: number
    transportMode: number
    facilityType: number
    emptyIndicator: number
    carrierEventId: number
    _all: number
  }


  export type ContainerEventMinAggregateInputType = {
    id?: true
    containerId?: true
    stageName?: true
    eventDateTime?: true
    location?: true
    facilityId?: true
    vessel?: true
    voyage?: true
    source?: true
    sourceFileId?: true
    updatedBy?: true
    updatedOn?: true
    previousStatus?: true
    exceptionCleared?: true
    notes?: true
    eventCategory?: true
    eventClassifier?: true
    dcsaEventType?: true
    transportMode?: true
    facilityType?: true
    emptyIndicator?: true
    carrierEventId?: true
  }

  export type ContainerEventMaxAggregateInputType = {
    id?: true
    containerId?: true
    stageName?: true
    eventDateTime?: true
    location?: true
    facilityId?: true
    vessel?: true
    voyage?: true
    source?: true
    sourceFileId?: true
    updatedBy?: true
    updatedOn?: true
    previousStatus?: true
    exceptionCleared?: true
    notes?: true
    eventCategory?: true
    eventClassifier?: true
    dcsaEventType?: true
    transportMode?: true
    facilityType?: true
    emptyIndicator?: true
    carrierEventId?: true
  }

  export type ContainerEventCountAggregateInputType = {
    id?: true
    containerId?: true
    stageName?: true
    eventDateTime?: true
    location?: true
    facilityId?: true
    vessel?: true
    voyage?: true
    source?: true
    sourceFileId?: true
    updatedBy?: true
    updatedOn?: true
    previousStatus?: true
    exceptionCleared?: true
    notes?: true
    eventCategory?: true
    eventClassifier?: true
    dcsaEventType?: true
    transportMode?: true
    facilityType?: true
    emptyIndicator?: true
    carrierEventId?: true
    _all?: true
  }

  export type ContainerEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerEvent to aggregate.
     */
    where?: ContainerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerEvents to fetch.
     */
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContainerEvents
    **/
    _count?: true | ContainerEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerEventMaxAggregateInputType
  }

  export type GetContainerEventAggregateType<T extends ContainerEventAggregateArgs> = {
        [P in keyof T & keyof AggregateContainerEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainerEvent[P]>
      : GetScalarType<T[P], AggregateContainerEvent[P]>
  }




  export type ContainerEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerEventWhereInput
    orderBy?: ContainerEventOrderByWithAggregationInput | ContainerEventOrderByWithAggregationInput[]
    by: ContainerEventScalarFieldEnum[] | ContainerEventScalarFieldEnum
    having?: ContainerEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerEventCountAggregateInputType | true
    _min?: ContainerEventMinAggregateInputType
    _max?: ContainerEventMaxAggregateInputType
  }

  export type ContainerEventGroupByOutputType = {
    id: string
    containerId: string
    stageName: string | null
    eventDateTime: Date
    location: string | null
    facilityId: string | null
    vessel: string | null
    voyage: string | null
    source: string | null
    sourceFileId: string | null
    updatedBy: string | null
    updatedOn: Date | null
    previousStatus: string | null
    exceptionCleared: boolean | null
    notes: string | null
    eventCategory: string | null
    eventClassifier: string | null
    dcsaEventType: string | null
    transportMode: string | null
    facilityType: string | null
    emptyIndicator: boolean | null
    carrierEventId: string | null
    _count: ContainerEventCountAggregateOutputType | null
    _min: ContainerEventMinAggregateOutputType | null
    _max: ContainerEventMaxAggregateOutputType | null
  }

  type GetContainerEventGroupByPayload<T extends ContainerEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerEventGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerEventGroupByOutputType[P]>
        }
      >
    >


  export type ContainerEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    stageName?: boolean
    eventDateTime?: boolean
    location?: boolean
    facilityId?: boolean
    vessel?: boolean
    voyage?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedBy?: boolean
    updatedOn?: boolean
    previousStatus?: boolean
    exceptionCleared?: boolean
    notes?: boolean
    eventCategory?: boolean
    eventClassifier?: boolean
    dcsaEventType?: boolean
    transportMode?: boolean
    facilityType?: boolean
    emptyIndicator?: boolean
    carrierEventId?: boolean
    facility?: boolean | ContainerEvent$facilityArgs<ExtArgs>
    importLog?: boolean | ContainerEvent$importLogArgs<ExtArgs>
    previousStage?: boolean | ContainerEvent$previousStageArgs<ExtArgs>
    stage?: boolean | ContainerEvent$stageArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["containerEvent"]>

  export type ContainerEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    stageName?: boolean
    eventDateTime?: boolean
    location?: boolean
    facilityId?: boolean
    vessel?: boolean
    voyage?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedBy?: boolean
    updatedOn?: boolean
    previousStatus?: boolean
    exceptionCleared?: boolean
    notes?: boolean
    eventCategory?: boolean
    eventClassifier?: boolean
    dcsaEventType?: boolean
    transportMode?: boolean
    facilityType?: boolean
    emptyIndicator?: boolean
    carrierEventId?: boolean
    facility?: boolean | ContainerEvent$facilityArgs<ExtArgs>
    importLog?: boolean | ContainerEvent$importLogArgs<ExtArgs>
    previousStage?: boolean | ContainerEvent$previousStageArgs<ExtArgs>
    stage?: boolean | ContainerEvent$stageArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["containerEvent"]>

  export type ContainerEventSelectScalar = {
    id?: boolean
    containerId?: boolean
    stageName?: boolean
    eventDateTime?: boolean
    location?: boolean
    facilityId?: boolean
    vessel?: boolean
    voyage?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedBy?: boolean
    updatedOn?: boolean
    previousStatus?: boolean
    exceptionCleared?: boolean
    notes?: boolean
    eventCategory?: boolean
    eventClassifier?: boolean
    dcsaEventType?: boolean
    transportMode?: boolean
    facilityType?: boolean
    emptyIndicator?: boolean
    carrierEventId?: boolean
  }

  export type ContainerEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | ContainerEvent$facilityArgs<ExtArgs>
    importLog?: boolean | ContainerEvent$importLogArgs<ExtArgs>
    previousStage?: boolean | ContainerEvent$previousStageArgs<ExtArgs>
    stage?: boolean | ContainerEvent$stageArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }
  export type ContainerEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | ContainerEvent$facilityArgs<ExtArgs>
    importLog?: boolean | ContainerEvent$importLogArgs<ExtArgs>
    previousStage?: boolean | ContainerEvent$previousStageArgs<ExtArgs>
    stage?: boolean | ContainerEvent$stageArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }

  export type $ContainerEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContainerEvent"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      importLog: Prisma.$ImportLogPayload<ExtArgs> | null
      previousStage: Prisma.$TransitStagePayload<ExtArgs> | null
      stage: Prisma.$TransitStagePayload<ExtArgs> | null
      container: Prisma.$ContainerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerId: string
      stageName: string | null
      eventDateTime: Date
      location: string | null
      facilityId: string | null
      vessel: string | null
      voyage: string | null
      source: string | null
      sourceFileId: string | null
      updatedBy: string | null
      updatedOn: Date | null
      previousStatus: string | null
      exceptionCleared: boolean | null
      notes: string | null
      eventCategory: string | null
      eventClassifier: string | null
      dcsaEventType: string | null
      transportMode: string | null
      facilityType: string | null
      emptyIndicator: boolean | null
      carrierEventId: string | null
    }, ExtArgs["result"]["containerEvent"]>
    composites: {}
  }

  type ContainerEventGetPayload<S extends boolean | null | undefined | ContainerEventDefaultArgs> = $Result.GetResult<Prisma.$ContainerEventPayload, S>

  type ContainerEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContainerEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContainerEventCountAggregateInputType | true
    }

  export interface ContainerEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContainerEvent'], meta: { name: 'ContainerEvent' } }
    /**
     * Find zero or one ContainerEvent that matches the filter.
     * @param {ContainerEventFindUniqueArgs} args - Arguments to find a ContainerEvent
     * @example
     * // Get one ContainerEvent
     * const containerEvent = await prisma.containerEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerEventFindUniqueArgs>(args: SelectSubset<T, ContainerEventFindUniqueArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContainerEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContainerEventFindUniqueOrThrowArgs} args - Arguments to find a ContainerEvent
     * @example
     * // Get one ContainerEvent
     * const containerEvent = await prisma.containerEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContainerEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventFindFirstArgs} args - Arguments to find a ContainerEvent
     * @example
     * // Get one ContainerEvent
     * const containerEvent = await prisma.containerEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerEventFindFirstArgs>(args?: SelectSubset<T, ContainerEventFindFirstArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContainerEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventFindFirstOrThrowArgs} args - Arguments to find a ContainerEvent
     * @example
     * // Get one ContainerEvent
     * const containerEvent = await prisma.containerEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContainerEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContainerEvents
     * const containerEvents = await prisma.containerEvent.findMany()
     * 
     * // Get first 10 ContainerEvents
     * const containerEvents = await prisma.containerEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerEventWithIdOnly = await prisma.containerEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerEventFindManyArgs>(args?: SelectSubset<T, ContainerEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContainerEvent.
     * @param {ContainerEventCreateArgs} args - Arguments to create a ContainerEvent.
     * @example
     * // Create one ContainerEvent
     * const ContainerEvent = await prisma.containerEvent.create({
     *   data: {
     *     // ... data to create a ContainerEvent
     *   }
     * })
     * 
     */
    create<T extends ContainerEventCreateArgs>(args: SelectSubset<T, ContainerEventCreateArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContainerEvents.
     * @param {ContainerEventCreateManyArgs} args - Arguments to create many ContainerEvents.
     * @example
     * // Create many ContainerEvents
     * const containerEvent = await prisma.containerEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerEventCreateManyArgs>(args?: SelectSubset<T, ContainerEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContainerEvents and returns the data saved in the database.
     * @param {ContainerEventCreateManyAndReturnArgs} args - Arguments to create many ContainerEvents.
     * @example
     * // Create many ContainerEvents
     * const containerEvent = await prisma.containerEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContainerEvents and only return the `id`
     * const containerEventWithIdOnly = await prisma.containerEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContainerEvent.
     * @param {ContainerEventDeleteArgs} args - Arguments to delete one ContainerEvent.
     * @example
     * // Delete one ContainerEvent
     * const ContainerEvent = await prisma.containerEvent.delete({
     *   where: {
     *     // ... filter to delete one ContainerEvent
     *   }
     * })
     * 
     */
    delete<T extends ContainerEventDeleteArgs>(args: SelectSubset<T, ContainerEventDeleteArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContainerEvent.
     * @param {ContainerEventUpdateArgs} args - Arguments to update one ContainerEvent.
     * @example
     * // Update one ContainerEvent
     * const containerEvent = await prisma.containerEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerEventUpdateArgs>(args: SelectSubset<T, ContainerEventUpdateArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContainerEvents.
     * @param {ContainerEventDeleteManyArgs} args - Arguments to filter ContainerEvents to delete.
     * @example
     * // Delete a few ContainerEvents
     * const { count } = await prisma.containerEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerEventDeleteManyArgs>(args?: SelectSubset<T, ContainerEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContainerEvents
     * const containerEvent = await prisma.containerEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerEventUpdateManyArgs>(args: SelectSubset<T, ContainerEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContainerEvent.
     * @param {ContainerEventUpsertArgs} args - Arguments to update or create a ContainerEvent.
     * @example
     * // Update or create a ContainerEvent
     * const containerEvent = await prisma.containerEvent.upsert({
     *   create: {
     *     // ... data to create a ContainerEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContainerEvent we want to update
     *   }
     * })
     */
    upsert<T extends ContainerEventUpsertArgs>(args: SelectSubset<T, ContainerEventUpsertArgs<ExtArgs>>): Prisma__ContainerEventClient<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContainerEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventCountArgs} args - Arguments to filter ContainerEvents to count.
     * @example
     * // Count the number of ContainerEvents
     * const count = await prisma.containerEvent.count({
     *   where: {
     *     // ... the filter for the ContainerEvents we want to count
     *   }
     * })
    **/
    count<T extends ContainerEventCountArgs>(
      args?: Subset<T, ContainerEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContainerEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerEventAggregateArgs>(args: Subset<T, ContainerEventAggregateArgs>): Prisma.PrismaPromise<GetContainerEventAggregateType<T>>

    /**
     * Group by ContainerEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerEventGroupByArgs['orderBy'] }
        : { orderBy?: ContainerEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContainerEvent model
   */
  readonly fields: ContainerEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContainerEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends ContainerEvent$facilityArgs<ExtArgs> = {}>(args?: Subset<T, ContainerEvent$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    importLog<T extends ContainerEvent$importLogArgs<ExtArgs> = {}>(args?: Subset<T, ContainerEvent$importLogArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    previousStage<T extends ContainerEvent$previousStageArgs<ExtArgs> = {}>(args?: Subset<T, ContainerEvent$previousStageArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stage<T extends ContainerEvent$stageArgs<ExtArgs> = {}>(args?: Subset<T, ContainerEvent$stageArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContainerEvent model
   */ 
  interface ContainerEventFieldRefs {
    readonly id: FieldRef<"ContainerEvent", 'String'>
    readonly containerId: FieldRef<"ContainerEvent", 'String'>
    readonly stageName: FieldRef<"ContainerEvent", 'String'>
    readonly eventDateTime: FieldRef<"ContainerEvent", 'DateTime'>
    readonly location: FieldRef<"ContainerEvent", 'String'>
    readonly facilityId: FieldRef<"ContainerEvent", 'String'>
    readonly vessel: FieldRef<"ContainerEvent", 'String'>
    readonly voyage: FieldRef<"ContainerEvent", 'String'>
    readonly source: FieldRef<"ContainerEvent", 'String'>
    readonly sourceFileId: FieldRef<"ContainerEvent", 'String'>
    readonly updatedBy: FieldRef<"ContainerEvent", 'String'>
    readonly updatedOn: FieldRef<"ContainerEvent", 'DateTime'>
    readonly previousStatus: FieldRef<"ContainerEvent", 'String'>
    readonly exceptionCleared: FieldRef<"ContainerEvent", 'Boolean'>
    readonly notes: FieldRef<"ContainerEvent", 'String'>
    readonly eventCategory: FieldRef<"ContainerEvent", 'String'>
    readonly eventClassifier: FieldRef<"ContainerEvent", 'String'>
    readonly dcsaEventType: FieldRef<"ContainerEvent", 'String'>
    readonly transportMode: FieldRef<"ContainerEvent", 'String'>
    readonly facilityType: FieldRef<"ContainerEvent", 'String'>
    readonly emptyIndicator: FieldRef<"ContainerEvent", 'Boolean'>
    readonly carrierEventId: FieldRef<"ContainerEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContainerEvent findUnique
   */
  export type ContainerEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * Filter, which ContainerEvent to fetch.
     */
    where: ContainerEventWhereUniqueInput
  }

  /**
   * ContainerEvent findUniqueOrThrow
   */
  export type ContainerEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * Filter, which ContainerEvent to fetch.
     */
    where: ContainerEventWhereUniqueInput
  }

  /**
   * ContainerEvent findFirst
   */
  export type ContainerEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * Filter, which ContainerEvent to fetch.
     */
    where?: ContainerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerEvents to fetch.
     */
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerEvents.
     */
    cursor?: ContainerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerEvents.
     */
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * ContainerEvent findFirstOrThrow
   */
  export type ContainerEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * Filter, which ContainerEvent to fetch.
     */
    where?: ContainerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerEvents to fetch.
     */
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerEvents.
     */
    cursor?: ContainerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerEvents.
     */
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * ContainerEvent findMany
   */
  export type ContainerEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * Filter, which ContainerEvents to fetch.
     */
    where?: ContainerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerEvents to fetch.
     */
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContainerEvents.
     */
    cursor?: ContainerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerEvents.
     */
    skip?: number
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * ContainerEvent create
   */
  export type ContainerEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ContainerEvent.
     */
    data: XOR<ContainerEventCreateInput, ContainerEventUncheckedCreateInput>
  }

  /**
   * ContainerEvent createMany
   */
  export type ContainerEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContainerEvents.
     */
    data: ContainerEventCreateManyInput | ContainerEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerEvent createManyAndReturn
   */
  export type ContainerEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContainerEvents.
     */
    data: ContainerEventCreateManyInput | ContainerEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContainerEvent update
   */
  export type ContainerEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ContainerEvent.
     */
    data: XOR<ContainerEventUpdateInput, ContainerEventUncheckedUpdateInput>
    /**
     * Choose, which ContainerEvent to update.
     */
    where: ContainerEventWhereUniqueInput
  }

  /**
   * ContainerEvent updateMany
   */
  export type ContainerEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContainerEvents.
     */
    data: XOR<ContainerEventUpdateManyMutationInput, ContainerEventUncheckedUpdateManyInput>
    /**
     * Filter which ContainerEvents to update
     */
    where?: ContainerEventWhereInput
  }

  /**
   * ContainerEvent upsert
   */
  export type ContainerEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ContainerEvent to update in case it exists.
     */
    where: ContainerEventWhereUniqueInput
    /**
     * In case the ContainerEvent found by the `where` argument doesn't exist, create a new ContainerEvent with this data.
     */
    create: XOR<ContainerEventCreateInput, ContainerEventUncheckedCreateInput>
    /**
     * In case the ContainerEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerEventUpdateInput, ContainerEventUncheckedUpdateInput>
  }

  /**
   * ContainerEvent delete
   */
  export type ContainerEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    /**
     * Filter which ContainerEvent to delete.
     */
    where: ContainerEventWhereUniqueInput
  }

  /**
   * ContainerEvent deleteMany
   */
  export type ContainerEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerEvents to delete
     */
    where?: ContainerEventWhereInput
  }

  /**
   * ContainerEvent.facility
   */
  export type ContainerEvent$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * ContainerEvent.importLog
   */
  export type ContainerEvent$importLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    where?: ImportLogWhereInput
  }

  /**
   * ContainerEvent.previousStage
   */
  export type ContainerEvent$previousStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    where?: TransitStageWhereInput
  }

  /**
   * ContainerEvent.stage
   */
  export type ContainerEvent$stageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    where?: TransitStageWhereInput
  }

  /**
   * ContainerEvent without action
   */
  export type ContainerEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
  }


  /**
   * Model ShipmentEvent
   */

  export type AggregateShipmentEvent = {
    _count: ShipmentEventCountAggregateOutputType | null
    _min: ShipmentEventMinAggregateOutputType | null
    _max: ShipmentEventMaxAggregateOutputType | null
  }

  export type ShipmentEventMinAggregateOutputType = {
    id: string | null
    shipmentId: string | null
    eventType: string | null
    eventDateTime: Date | null
    documentType: string | null
    source: string | null
    sourceFileId: string | null
    updatedBy: string | null
    updatedOn: Date | null
    previousBLStatus: string | null
    newBLStatus: string | null
    notes: string | null
    dcsaEventType: string | null
    carrierEventId: string | null
  }

  export type ShipmentEventMaxAggregateOutputType = {
    id: string | null
    shipmentId: string | null
    eventType: string | null
    eventDateTime: Date | null
    documentType: string | null
    source: string | null
    sourceFileId: string | null
    updatedBy: string | null
    updatedOn: Date | null
    previousBLStatus: string | null
    newBLStatus: string | null
    notes: string | null
    dcsaEventType: string | null
    carrierEventId: string | null
  }

  export type ShipmentEventCountAggregateOutputType = {
    id: number
    shipmentId: number
    eventType: number
    eventDateTime: number
    documentType: number
    source: number
    sourceFileId: number
    updatedBy: number
    updatedOn: number
    previousBLStatus: number
    newBLStatus: number
    notes: number
    dcsaEventType: number
    carrierEventId: number
    _all: number
  }


  export type ShipmentEventMinAggregateInputType = {
    id?: true
    shipmentId?: true
    eventType?: true
    eventDateTime?: true
    documentType?: true
    source?: true
    sourceFileId?: true
    updatedBy?: true
    updatedOn?: true
    previousBLStatus?: true
    newBLStatus?: true
    notes?: true
    dcsaEventType?: true
    carrierEventId?: true
  }

  export type ShipmentEventMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    eventType?: true
    eventDateTime?: true
    documentType?: true
    source?: true
    sourceFileId?: true
    updatedBy?: true
    updatedOn?: true
    previousBLStatus?: true
    newBLStatus?: true
    notes?: true
    dcsaEventType?: true
    carrierEventId?: true
  }

  export type ShipmentEventCountAggregateInputType = {
    id?: true
    shipmentId?: true
    eventType?: true
    eventDateTime?: true
    documentType?: true
    source?: true
    sourceFileId?: true
    updatedBy?: true
    updatedOn?: true
    previousBLStatus?: true
    newBLStatus?: true
    notes?: true
    dcsaEventType?: true
    carrierEventId?: true
    _all?: true
  }

  export type ShipmentEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentEvent to aggregate.
     */
    where?: ShipmentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentEvents to fetch.
     */
    orderBy?: ShipmentEventOrderByWithRelationInput | ShipmentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShipmentEvents
    **/
    _count?: true | ShipmentEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentEventMaxAggregateInputType
  }

  export type GetShipmentEventAggregateType<T extends ShipmentEventAggregateArgs> = {
        [P in keyof T & keyof AggregateShipmentEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipmentEvent[P]>
      : GetScalarType<T[P], AggregateShipmentEvent[P]>
  }




  export type ShipmentEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentEventWhereInput
    orderBy?: ShipmentEventOrderByWithAggregationInput | ShipmentEventOrderByWithAggregationInput[]
    by: ShipmentEventScalarFieldEnum[] | ShipmentEventScalarFieldEnum
    having?: ShipmentEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentEventCountAggregateInputType | true
    _min?: ShipmentEventMinAggregateInputType
    _max?: ShipmentEventMaxAggregateInputType
  }

  export type ShipmentEventGroupByOutputType = {
    id: string
    shipmentId: string
    eventType: string
    eventDateTime: Date
    documentType: string | null
    source: string | null
    sourceFileId: string | null
    updatedBy: string | null
    updatedOn: Date | null
    previousBLStatus: string | null
    newBLStatus: string | null
    notes: string | null
    dcsaEventType: string | null
    carrierEventId: string | null
    _count: ShipmentEventCountAggregateOutputType | null
    _min: ShipmentEventMinAggregateOutputType | null
    _max: ShipmentEventMaxAggregateOutputType | null
  }

  type GetShipmentEventGroupByPayload<T extends ShipmentEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentEventGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentEventGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    eventType?: boolean
    eventDateTime?: boolean
    documentType?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedBy?: boolean
    updatedOn?: boolean
    previousBLStatus?: boolean
    newBLStatus?: boolean
    notes?: boolean
    dcsaEventType?: boolean
    carrierEventId?: boolean
    importLog?: boolean | ShipmentEvent$importLogArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentEvent"]>

  export type ShipmentEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    eventType?: boolean
    eventDateTime?: boolean
    documentType?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedBy?: boolean
    updatedOn?: boolean
    previousBLStatus?: boolean
    newBLStatus?: boolean
    notes?: boolean
    dcsaEventType?: boolean
    carrierEventId?: boolean
    importLog?: boolean | ShipmentEvent$importLogArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipmentEvent"]>

  export type ShipmentEventSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    eventType?: boolean
    eventDateTime?: boolean
    documentType?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedBy?: boolean
    updatedOn?: boolean
    previousBLStatus?: boolean
    newBLStatus?: boolean
    notes?: boolean
    dcsaEventType?: boolean
    carrierEventId?: boolean
  }

  export type ShipmentEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLog?: boolean | ShipmentEvent$importLogArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }
  export type ShipmentEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLog?: boolean | ShipmentEvent$importLogArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }

  export type $ShipmentEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShipmentEvent"
    objects: {
      importLog: Prisma.$ImportLogPayload<ExtArgs> | null
      shipment: Prisma.$ShipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shipmentId: string
      eventType: string
      eventDateTime: Date
      documentType: string | null
      source: string | null
      sourceFileId: string | null
      updatedBy: string | null
      updatedOn: Date | null
      previousBLStatus: string | null
      newBLStatus: string | null
      notes: string | null
      dcsaEventType: string | null
      carrierEventId: string | null
    }, ExtArgs["result"]["shipmentEvent"]>
    composites: {}
  }

  type ShipmentEventGetPayload<S extends boolean | null | undefined | ShipmentEventDefaultArgs> = $Result.GetResult<Prisma.$ShipmentEventPayload, S>

  type ShipmentEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShipmentEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShipmentEventCountAggregateInputType | true
    }

  export interface ShipmentEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShipmentEvent'], meta: { name: 'ShipmentEvent' } }
    /**
     * Find zero or one ShipmentEvent that matches the filter.
     * @param {ShipmentEventFindUniqueArgs} args - Arguments to find a ShipmentEvent
     * @example
     * // Get one ShipmentEvent
     * const shipmentEvent = await prisma.shipmentEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentEventFindUniqueArgs>(args: SelectSubset<T, ShipmentEventFindUniqueArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShipmentEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShipmentEventFindUniqueOrThrowArgs} args - Arguments to find a ShipmentEvent
     * @example
     * // Get one ShipmentEvent
     * const shipmentEvent = await prisma.shipmentEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShipmentEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventFindFirstArgs} args - Arguments to find a ShipmentEvent
     * @example
     * // Get one ShipmentEvent
     * const shipmentEvent = await prisma.shipmentEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentEventFindFirstArgs>(args?: SelectSubset<T, ShipmentEventFindFirstArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShipmentEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventFindFirstOrThrowArgs} args - Arguments to find a ShipmentEvent
     * @example
     * // Get one ShipmentEvent
     * const shipmentEvent = await prisma.shipmentEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShipmentEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShipmentEvents
     * const shipmentEvents = await prisma.shipmentEvent.findMany()
     * 
     * // Get first 10 ShipmentEvents
     * const shipmentEvents = await prisma.shipmentEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentEventWithIdOnly = await prisma.shipmentEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentEventFindManyArgs>(args?: SelectSubset<T, ShipmentEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShipmentEvent.
     * @param {ShipmentEventCreateArgs} args - Arguments to create a ShipmentEvent.
     * @example
     * // Create one ShipmentEvent
     * const ShipmentEvent = await prisma.shipmentEvent.create({
     *   data: {
     *     // ... data to create a ShipmentEvent
     *   }
     * })
     * 
     */
    create<T extends ShipmentEventCreateArgs>(args: SelectSubset<T, ShipmentEventCreateArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShipmentEvents.
     * @param {ShipmentEventCreateManyArgs} args - Arguments to create many ShipmentEvents.
     * @example
     * // Create many ShipmentEvents
     * const shipmentEvent = await prisma.shipmentEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentEventCreateManyArgs>(args?: SelectSubset<T, ShipmentEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShipmentEvents and returns the data saved in the database.
     * @param {ShipmentEventCreateManyAndReturnArgs} args - Arguments to create many ShipmentEvents.
     * @example
     * // Create many ShipmentEvents
     * const shipmentEvent = await prisma.shipmentEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShipmentEvents and only return the `id`
     * const shipmentEventWithIdOnly = await prisma.shipmentEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShipmentEvent.
     * @param {ShipmentEventDeleteArgs} args - Arguments to delete one ShipmentEvent.
     * @example
     * // Delete one ShipmentEvent
     * const ShipmentEvent = await prisma.shipmentEvent.delete({
     *   where: {
     *     // ... filter to delete one ShipmentEvent
     *   }
     * })
     * 
     */
    delete<T extends ShipmentEventDeleteArgs>(args: SelectSubset<T, ShipmentEventDeleteArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShipmentEvent.
     * @param {ShipmentEventUpdateArgs} args - Arguments to update one ShipmentEvent.
     * @example
     * // Update one ShipmentEvent
     * const shipmentEvent = await prisma.shipmentEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentEventUpdateArgs>(args: SelectSubset<T, ShipmentEventUpdateArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShipmentEvents.
     * @param {ShipmentEventDeleteManyArgs} args - Arguments to filter ShipmentEvents to delete.
     * @example
     * // Delete a few ShipmentEvents
     * const { count } = await prisma.shipmentEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentEventDeleteManyArgs>(args?: SelectSubset<T, ShipmentEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShipmentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShipmentEvents
     * const shipmentEvent = await prisma.shipmentEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentEventUpdateManyArgs>(args: SelectSubset<T, ShipmentEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShipmentEvent.
     * @param {ShipmentEventUpsertArgs} args - Arguments to update or create a ShipmentEvent.
     * @example
     * // Update or create a ShipmentEvent
     * const shipmentEvent = await prisma.shipmentEvent.upsert({
     *   create: {
     *     // ... data to create a ShipmentEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShipmentEvent we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentEventUpsertArgs>(args: SelectSubset<T, ShipmentEventUpsertArgs<ExtArgs>>): Prisma__ShipmentEventClient<$Result.GetResult<Prisma.$ShipmentEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShipmentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventCountArgs} args - Arguments to filter ShipmentEvents to count.
     * @example
     * // Count the number of ShipmentEvents
     * const count = await prisma.shipmentEvent.count({
     *   where: {
     *     // ... the filter for the ShipmentEvents we want to count
     *   }
     * })
    **/
    count<T extends ShipmentEventCountArgs>(
      args?: Subset<T, ShipmentEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShipmentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentEventAggregateArgs>(args: Subset<T, ShipmentEventAggregateArgs>): Prisma.PrismaPromise<GetShipmentEventAggregateType<T>>

    /**
     * Group by ShipmentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentEventGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShipmentEvent model
   */
  readonly fields: ShipmentEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShipmentEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importLog<T extends ShipmentEvent$importLogArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentEvent$importLogArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShipmentEvent model
   */ 
  interface ShipmentEventFieldRefs {
    readonly id: FieldRef<"ShipmentEvent", 'String'>
    readonly shipmentId: FieldRef<"ShipmentEvent", 'String'>
    readonly eventType: FieldRef<"ShipmentEvent", 'String'>
    readonly eventDateTime: FieldRef<"ShipmentEvent", 'DateTime'>
    readonly documentType: FieldRef<"ShipmentEvent", 'String'>
    readonly source: FieldRef<"ShipmentEvent", 'String'>
    readonly sourceFileId: FieldRef<"ShipmentEvent", 'String'>
    readonly updatedBy: FieldRef<"ShipmentEvent", 'String'>
    readonly updatedOn: FieldRef<"ShipmentEvent", 'DateTime'>
    readonly previousBLStatus: FieldRef<"ShipmentEvent", 'String'>
    readonly newBLStatus: FieldRef<"ShipmentEvent", 'String'>
    readonly notes: FieldRef<"ShipmentEvent", 'String'>
    readonly dcsaEventType: FieldRef<"ShipmentEvent", 'String'>
    readonly carrierEventId: FieldRef<"ShipmentEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShipmentEvent findUnique
   */
  export type ShipmentEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentEvent to fetch.
     */
    where: ShipmentEventWhereUniqueInput
  }

  /**
   * ShipmentEvent findUniqueOrThrow
   */
  export type ShipmentEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentEvent to fetch.
     */
    where: ShipmentEventWhereUniqueInput
  }

  /**
   * ShipmentEvent findFirst
   */
  export type ShipmentEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentEvent to fetch.
     */
    where?: ShipmentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentEvents to fetch.
     */
    orderBy?: ShipmentEventOrderByWithRelationInput | ShipmentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentEvents.
     */
    cursor?: ShipmentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentEvents.
     */
    distinct?: ShipmentEventScalarFieldEnum | ShipmentEventScalarFieldEnum[]
  }

  /**
   * ShipmentEvent findFirstOrThrow
   */
  export type ShipmentEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentEvent to fetch.
     */
    where?: ShipmentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentEvents to fetch.
     */
    orderBy?: ShipmentEventOrderByWithRelationInput | ShipmentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShipmentEvents.
     */
    cursor?: ShipmentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShipmentEvents.
     */
    distinct?: ShipmentEventScalarFieldEnum | ShipmentEventScalarFieldEnum[]
  }

  /**
   * ShipmentEvent findMany
   */
  export type ShipmentEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * Filter, which ShipmentEvents to fetch.
     */
    where?: ShipmentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShipmentEvents to fetch.
     */
    orderBy?: ShipmentEventOrderByWithRelationInput | ShipmentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShipmentEvents.
     */
    cursor?: ShipmentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShipmentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShipmentEvents.
     */
    skip?: number
    distinct?: ShipmentEventScalarFieldEnum | ShipmentEventScalarFieldEnum[]
  }

  /**
   * ShipmentEvent create
   */
  export type ShipmentEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ShipmentEvent.
     */
    data: XOR<ShipmentEventCreateInput, ShipmentEventUncheckedCreateInput>
  }

  /**
   * ShipmentEvent createMany
   */
  export type ShipmentEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShipmentEvents.
     */
    data: ShipmentEventCreateManyInput | ShipmentEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShipmentEvent createManyAndReturn
   */
  export type ShipmentEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShipmentEvents.
     */
    data: ShipmentEventCreateManyInput | ShipmentEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShipmentEvent update
   */
  export type ShipmentEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ShipmentEvent.
     */
    data: XOR<ShipmentEventUpdateInput, ShipmentEventUncheckedUpdateInput>
    /**
     * Choose, which ShipmentEvent to update.
     */
    where: ShipmentEventWhereUniqueInput
  }

  /**
   * ShipmentEvent updateMany
   */
  export type ShipmentEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShipmentEvents.
     */
    data: XOR<ShipmentEventUpdateManyMutationInput, ShipmentEventUncheckedUpdateManyInput>
    /**
     * Filter which ShipmentEvents to update
     */
    where?: ShipmentEventWhereInput
  }

  /**
   * ShipmentEvent upsert
   */
  export type ShipmentEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ShipmentEvent to update in case it exists.
     */
    where: ShipmentEventWhereUniqueInput
    /**
     * In case the ShipmentEvent found by the `where` argument doesn't exist, create a new ShipmentEvent with this data.
     */
    create: XOR<ShipmentEventCreateInput, ShipmentEventUncheckedCreateInput>
    /**
     * In case the ShipmentEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentEventUpdateInput, ShipmentEventUncheckedUpdateInput>
  }

  /**
   * ShipmentEvent delete
   */
  export type ShipmentEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
    /**
     * Filter which ShipmentEvent to delete.
     */
    where: ShipmentEventWhereUniqueInput
  }

  /**
   * ShipmentEvent deleteMany
   */
  export type ShipmentEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShipmentEvents to delete
     */
    where?: ShipmentEventWhereInput
  }

  /**
   * ShipmentEvent.importLog
   */
  export type ShipmentEvent$importLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    where?: ImportLogWhereInput
  }

  /**
   * ShipmentEvent without action
   */
  export type ShipmentEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentEvent
     */
    select?: ShipmentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentEventInclude<ExtArgs> | null
  }


  /**
   * Model ACEStatusLog
   */

  export type AggregateACEStatusLog = {
    _count: ACEStatusLogCountAggregateOutputType | null
    _min: ACEStatusLogMinAggregateOutputType | null
    _max: ACEStatusLogMaxAggregateOutputType | null
  }

  export type ACEStatusLogMinAggregateOutputType = {
    id: string | null
    containerId: string | null
    shipmentId: string | null
    aceDisposition: string | null
    aceStatus: string | null
    previousACEStatus: string | null
    holdType: string | null
    pgaAgency: string | null
    holdReason: string | null
    eventDateTime: Date | null
    source: string | null
    sourceFileId: string | null
    updatedOn: Date | null
    notes: string | null
  }

  export type ACEStatusLogMaxAggregateOutputType = {
    id: string | null
    containerId: string | null
    shipmentId: string | null
    aceDisposition: string | null
    aceStatus: string | null
    previousACEStatus: string | null
    holdType: string | null
    pgaAgency: string | null
    holdReason: string | null
    eventDateTime: Date | null
    source: string | null
    sourceFileId: string | null
    updatedOn: Date | null
    notes: string | null
  }

  export type ACEStatusLogCountAggregateOutputType = {
    id: number
    containerId: number
    shipmentId: number
    aceDisposition: number
    aceStatus: number
    previousACEStatus: number
    holdType: number
    pgaAgency: number
    holdReason: number
    eventDateTime: number
    source: number
    sourceFileId: number
    updatedOn: number
    notes: number
    _all: number
  }


  export type ACEStatusLogMinAggregateInputType = {
    id?: true
    containerId?: true
    shipmentId?: true
    aceDisposition?: true
    aceStatus?: true
    previousACEStatus?: true
    holdType?: true
    pgaAgency?: true
    holdReason?: true
    eventDateTime?: true
    source?: true
    sourceFileId?: true
    updatedOn?: true
    notes?: true
  }

  export type ACEStatusLogMaxAggregateInputType = {
    id?: true
    containerId?: true
    shipmentId?: true
    aceDisposition?: true
    aceStatus?: true
    previousACEStatus?: true
    holdType?: true
    pgaAgency?: true
    holdReason?: true
    eventDateTime?: true
    source?: true
    sourceFileId?: true
    updatedOn?: true
    notes?: true
  }

  export type ACEStatusLogCountAggregateInputType = {
    id?: true
    containerId?: true
    shipmentId?: true
    aceDisposition?: true
    aceStatus?: true
    previousACEStatus?: true
    holdType?: true
    pgaAgency?: true
    holdReason?: true
    eventDateTime?: true
    source?: true
    sourceFileId?: true
    updatedOn?: true
    notes?: true
    _all?: true
  }

  export type ACEStatusLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ACEStatusLog to aggregate.
     */
    where?: ACEStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACEStatusLogs to fetch.
     */
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ACEStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACEStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACEStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ACEStatusLogs
    **/
    _count?: true | ACEStatusLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ACEStatusLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ACEStatusLogMaxAggregateInputType
  }

  export type GetACEStatusLogAggregateType<T extends ACEStatusLogAggregateArgs> = {
        [P in keyof T & keyof AggregateACEStatusLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateACEStatusLog[P]>
      : GetScalarType<T[P], AggregateACEStatusLog[P]>
  }




  export type ACEStatusLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ACEStatusLogWhereInput
    orderBy?: ACEStatusLogOrderByWithAggregationInput | ACEStatusLogOrderByWithAggregationInput[]
    by: ACEStatusLogScalarFieldEnum[] | ACEStatusLogScalarFieldEnum
    having?: ACEStatusLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ACEStatusLogCountAggregateInputType | true
    _min?: ACEStatusLogMinAggregateInputType
    _max?: ACEStatusLogMaxAggregateInputType
  }

  export type ACEStatusLogGroupByOutputType = {
    id: string
    containerId: string | null
    shipmentId: string | null
    aceDisposition: string | null
    aceStatus: string | null
    previousACEStatus: string | null
    holdType: string | null
    pgaAgency: string | null
    holdReason: string | null
    eventDateTime: Date | null
    source: string | null
    sourceFileId: string | null
    updatedOn: Date | null
    notes: string | null
    _count: ACEStatusLogCountAggregateOutputType | null
    _min: ACEStatusLogMinAggregateOutputType | null
    _max: ACEStatusLogMaxAggregateOutputType | null
  }

  type GetACEStatusLogGroupByPayload<T extends ACEStatusLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ACEStatusLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ACEStatusLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ACEStatusLogGroupByOutputType[P]>
            : GetScalarType<T[P], ACEStatusLogGroupByOutputType[P]>
        }
      >
    >


  export type ACEStatusLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    shipmentId?: boolean
    aceDisposition?: boolean
    aceStatus?: boolean
    previousACEStatus?: boolean
    holdType?: boolean
    pgaAgency?: boolean
    holdReason?: boolean
    eventDateTime?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedOn?: boolean
    notes?: boolean
    importLog?: boolean | ACEStatusLog$importLogArgs<ExtArgs>
    shipment?: boolean | ACEStatusLog$shipmentArgs<ExtArgs>
    container?: boolean | ACEStatusLog$containerArgs<ExtArgs>
  }, ExtArgs["result"]["aCEStatusLog"]>

  export type ACEStatusLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    shipmentId?: boolean
    aceDisposition?: boolean
    aceStatus?: boolean
    previousACEStatus?: boolean
    holdType?: boolean
    pgaAgency?: boolean
    holdReason?: boolean
    eventDateTime?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedOn?: boolean
    notes?: boolean
    importLog?: boolean | ACEStatusLog$importLogArgs<ExtArgs>
    shipment?: boolean | ACEStatusLog$shipmentArgs<ExtArgs>
    container?: boolean | ACEStatusLog$containerArgs<ExtArgs>
  }, ExtArgs["result"]["aCEStatusLog"]>

  export type ACEStatusLogSelectScalar = {
    id?: boolean
    containerId?: boolean
    shipmentId?: boolean
    aceDisposition?: boolean
    aceStatus?: boolean
    previousACEStatus?: boolean
    holdType?: boolean
    pgaAgency?: boolean
    holdReason?: boolean
    eventDateTime?: boolean
    source?: boolean
    sourceFileId?: boolean
    updatedOn?: boolean
    notes?: boolean
  }

  export type ACEStatusLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLog?: boolean | ACEStatusLog$importLogArgs<ExtArgs>
    shipment?: boolean | ACEStatusLog$shipmentArgs<ExtArgs>
    container?: boolean | ACEStatusLog$containerArgs<ExtArgs>
  }
  export type ACEStatusLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importLog?: boolean | ACEStatusLog$importLogArgs<ExtArgs>
    shipment?: boolean | ACEStatusLog$shipmentArgs<ExtArgs>
    container?: boolean | ACEStatusLog$containerArgs<ExtArgs>
  }

  export type $ACEStatusLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ACEStatusLog"
    objects: {
      importLog: Prisma.$ImportLogPayload<ExtArgs> | null
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
      container: Prisma.$ContainerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerId: string | null
      shipmentId: string | null
      aceDisposition: string | null
      aceStatus: string | null
      previousACEStatus: string | null
      holdType: string | null
      pgaAgency: string | null
      holdReason: string | null
      eventDateTime: Date | null
      source: string | null
      sourceFileId: string | null
      updatedOn: Date | null
      notes: string | null
    }, ExtArgs["result"]["aCEStatusLog"]>
    composites: {}
  }

  type ACEStatusLogGetPayload<S extends boolean | null | undefined | ACEStatusLogDefaultArgs> = $Result.GetResult<Prisma.$ACEStatusLogPayload, S>

  type ACEStatusLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ACEStatusLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ACEStatusLogCountAggregateInputType | true
    }

  export interface ACEStatusLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ACEStatusLog'], meta: { name: 'ACEStatusLog' } }
    /**
     * Find zero or one ACEStatusLog that matches the filter.
     * @param {ACEStatusLogFindUniqueArgs} args - Arguments to find a ACEStatusLog
     * @example
     * // Get one ACEStatusLog
     * const aCEStatusLog = await prisma.aCEStatusLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ACEStatusLogFindUniqueArgs>(args: SelectSubset<T, ACEStatusLogFindUniqueArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ACEStatusLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ACEStatusLogFindUniqueOrThrowArgs} args - Arguments to find a ACEStatusLog
     * @example
     * // Get one ACEStatusLog
     * const aCEStatusLog = await prisma.aCEStatusLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ACEStatusLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ACEStatusLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ACEStatusLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogFindFirstArgs} args - Arguments to find a ACEStatusLog
     * @example
     * // Get one ACEStatusLog
     * const aCEStatusLog = await prisma.aCEStatusLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ACEStatusLogFindFirstArgs>(args?: SelectSubset<T, ACEStatusLogFindFirstArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ACEStatusLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogFindFirstOrThrowArgs} args - Arguments to find a ACEStatusLog
     * @example
     * // Get one ACEStatusLog
     * const aCEStatusLog = await prisma.aCEStatusLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ACEStatusLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ACEStatusLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ACEStatusLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ACEStatusLogs
     * const aCEStatusLogs = await prisma.aCEStatusLog.findMany()
     * 
     * // Get first 10 ACEStatusLogs
     * const aCEStatusLogs = await prisma.aCEStatusLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aCEStatusLogWithIdOnly = await prisma.aCEStatusLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ACEStatusLogFindManyArgs>(args?: SelectSubset<T, ACEStatusLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ACEStatusLog.
     * @param {ACEStatusLogCreateArgs} args - Arguments to create a ACEStatusLog.
     * @example
     * // Create one ACEStatusLog
     * const ACEStatusLog = await prisma.aCEStatusLog.create({
     *   data: {
     *     // ... data to create a ACEStatusLog
     *   }
     * })
     * 
     */
    create<T extends ACEStatusLogCreateArgs>(args: SelectSubset<T, ACEStatusLogCreateArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ACEStatusLogs.
     * @param {ACEStatusLogCreateManyArgs} args - Arguments to create many ACEStatusLogs.
     * @example
     * // Create many ACEStatusLogs
     * const aCEStatusLog = await prisma.aCEStatusLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ACEStatusLogCreateManyArgs>(args?: SelectSubset<T, ACEStatusLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ACEStatusLogs and returns the data saved in the database.
     * @param {ACEStatusLogCreateManyAndReturnArgs} args - Arguments to create many ACEStatusLogs.
     * @example
     * // Create many ACEStatusLogs
     * const aCEStatusLog = await prisma.aCEStatusLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ACEStatusLogs and only return the `id`
     * const aCEStatusLogWithIdOnly = await prisma.aCEStatusLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ACEStatusLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ACEStatusLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ACEStatusLog.
     * @param {ACEStatusLogDeleteArgs} args - Arguments to delete one ACEStatusLog.
     * @example
     * // Delete one ACEStatusLog
     * const ACEStatusLog = await prisma.aCEStatusLog.delete({
     *   where: {
     *     // ... filter to delete one ACEStatusLog
     *   }
     * })
     * 
     */
    delete<T extends ACEStatusLogDeleteArgs>(args: SelectSubset<T, ACEStatusLogDeleteArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ACEStatusLog.
     * @param {ACEStatusLogUpdateArgs} args - Arguments to update one ACEStatusLog.
     * @example
     * // Update one ACEStatusLog
     * const aCEStatusLog = await prisma.aCEStatusLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ACEStatusLogUpdateArgs>(args: SelectSubset<T, ACEStatusLogUpdateArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ACEStatusLogs.
     * @param {ACEStatusLogDeleteManyArgs} args - Arguments to filter ACEStatusLogs to delete.
     * @example
     * // Delete a few ACEStatusLogs
     * const { count } = await prisma.aCEStatusLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ACEStatusLogDeleteManyArgs>(args?: SelectSubset<T, ACEStatusLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ACEStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ACEStatusLogs
     * const aCEStatusLog = await prisma.aCEStatusLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ACEStatusLogUpdateManyArgs>(args: SelectSubset<T, ACEStatusLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ACEStatusLog.
     * @param {ACEStatusLogUpsertArgs} args - Arguments to update or create a ACEStatusLog.
     * @example
     * // Update or create a ACEStatusLog
     * const aCEStatusLog = await prisma.aCEStatusLog.upsert({
     *   create: {
     *     // ... data to create a ACEStatusLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ACEStatusLog we want to update
     *   }
     * })
     */
    upsert<T extends ACEStatusLogUpsertArgs>(args: SelectSubset<T, ACEStatusLogUpsertArgs<ExtArgs>>): Prisma__ACEStatusLogClient<$Result.GetResult<Prisma.$ACEStatusLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ACEStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogCountArgs} args - Arguments to filter ACEStatusLogs to count.
     * @example
     * // Count the number of ACEStatusLogs
     * const count = await prisma.aCEStatusLog.count({
     *   where: {
     *     // ... the filter for the ACEStatusLogs we want to count
     *   }
     * })
    **/
    count<T extends ACEStatusLogCountArgs>(
      args?: Subset<T, ACEStatusLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ACEStatusLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ACEStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ACEStatusLogAggregateArgs>(args: Subset<T, ACEStatusLogAggregateArgs>): Prisma.PrismaPromise<GetACEStatusLogAggregateType<T>>

    /**
     * Group by ACEStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACEStatusLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ACEStatusLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ACEStatusLogGroupByArgs['orderBy'] }
        : { orderBy?: ACEStatusLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ACEStatusLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetACEStatusLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ACEStatusLog model
   */
  readonly fields: ACEStatusLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ACEStatusLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ACEStatusLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importLog<T extends ACEStatusLog$importLogArgs<ExtArgs> = {}>(args?: Subset<T, ACEStatusLog$importLogArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shipment<T extends ACEStatusLog$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, ACEStatusLog$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    container<T extends ACEStatusLog$containerArgs<ExtArgs> = {}>(args?: Subset<T, ACEStatusLog$containerArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ACEStatusLog model
   */ 
  interface ACEStatusLogFieldRefs {
    readonly id: FieldRef<"ACEStatusLog", 'String'>
    readonly containerId: FieldRef<"ACEStatusLog", 'String'>
    readonly shipmentId: FieldRef<"ACEStatusLog", 'String'>
    readonly aceDisposition: FieldRef<"ACEStatusLog", 'String'>
    readonly aceStatus: FieldRef<"ACEStatusLog", 'String'>
    readonly previousACEStatus: FieldRef<"ACEStatusLog", 'String'>
    readonly holdType: FieldRef<"ACEStatusLog", 'String'>
    readonly pgaAgency: FieldRef<"ACEStatusLog", 'String'>
    readonly holdReason: FieldRef<"ACEStatusLog", 'String'>
    readonly eventDateTime: FieldRef<"ACEStatusLog", 'DateTime'>
    readonly source: FieldRef<"ACEStatusLog", 'String'>
    readonly sourceFileId: FieldRef<"ACEStatusLog", 'String'>
    readonly updatedOn: FieldRef<"ACEStatusLog", 'DateTime'>
    readonly notes: FieldRef<"ACEStatusLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ACEStatusLog findUnique
   */
  export type ACEStatusLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which ACEStatusLog to fetch.
     */
    where: ACEStatusLogWhereUniqueInput
  }

  /**
   * ACEStatusLog findUniqueOrThrow
   */
  export type ACEStatusLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which ACEStatusLog to fetch.
     */
    where: ACEStatusLogWhereUniqueInput
  }

  /**
   * ACEStatusLog findFirst
   */
  export type ACEStatusLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which ACEStatusLog to fetch.
     */
    where?: ACEStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACEStatusLogs to fetch.
     */
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ACEStatusLogs.
     */
    cursor?: ACEStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACEStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACEStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ACEStatusLogs.
     */
    distinct?: ACEStatusLogScalarFieldEnum | ACEStatusLogScalarFieldEnum[]
  }

  /**
   * ACEStatusLog findFirstOrThrow
   */
  export type ACEStatusLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which ACEStatusLog to fetch.
     */
    where?: ACEStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACEStatusLogs to fetch.
     */
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ACEStatusLogs.
     */
    cursor?: ACEStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACEStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACEStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ACEStatusLogs.
     */
    distinct?: ACEStatusLogScalarFieldEnum | ACEStatusLogScalarFieldEnum[]
  }

  /**
   * ACEStatusLog findMany
   */
  export type ACEStatusLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which ACEStatusLogs to fetch.
     */
    where?: ACEStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ACEStatusLogs to fetch.
     */
    orderBy?: ACEStatusLogOrderByWithRelationInput | ACEStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ACEStatusLogs.
     */
    cursor?: ACEStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ACEStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ACEStatusLogs.
     */
    skip?: number
    distinct?: ACEStatusLogScalarFieldEnum | ACEStatusLogScalarFieldEnum[]
  }

  /**
   * ACEStatusLog create
   */
  export type ACEStatusLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ACEStatusLog.
     */
    data?: XOR<ACEStatusLogCreateInput, ACEStatusLogUncheckedCreateInput>
  }

  /**
   * ACEStatusLog createMany
   */
  export type ACEStatusLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ACEStatusLogs.
     */
    data: ACEStatusLogCreateManyInput | ACEStatusLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ACEStatusLog createManyAndReturn
   */
  export type ACEStatusLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ACEStatusLogs.
     */
    data: ACEStatusLogCreateManyInput | ACEStatusLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ACEStatusLog update
   */
  export type ACEStatusLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ACEStatusLog.
     */
    data: XOR<ACEStatusLogUpdateInput, ACEStatusLogUncheckedUpdateInput>
    /**
     * Choose, which ACEStatusLog to update.
     */
    where: ACEStatusLogWhereUniqueInput
  }

  /**
   * ACEStatusLog updateMany
   */
  export type ACEStatusLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ACEStatusLogs.
     */
    data: XOR<ACEStatusLogUpdateManyMutationInput, ACEStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which ACEStatusLogs to update
     */
    where?: ACEStatusLogWhereInput
  }

  /**
   * ACEStatusLog upsert
   */
  export type ACEStatusLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ACEStatusLog to update in case it exists.
     */
    where: ACEStatusLogWhereUniqueInput
    /**
     * In case the ACEStatusLog found by the `where` argument doesn't exist, create a new ACEStatusLog with this data.
     */
    create: XOR<ACEStatusLogCreateInput, ACEStatusLogUncheckedCreateInput>
    /**
     * In case the ACEStatusLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ACEStatusLogUpdateInput, ACEStatusLogUncheckedUpdateInput>
  }

  /**
   * ACEStatusLog delete
   */
  export type ACEStatusLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
    /**
     * Filter which ACEStatusLog to delete.
     */
    where: ACEStatusLogWhereUniqueInput
  }

  /**
   * ACEStatusLog deleteMany
   */
  export type ACEStatusLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ACEStatusLogs to delete
     */
    where?: ACEStatusLogWhereInput
  }

  /**
   * ACEStatusLog.importLog
   */
  export type ACEStatusLog$importLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    where?: ImportLogWhereInput
  }

  /**
   * ACEStatusLog.shipment
   */
  export type ACEStatusLog$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * ACEStatusLog.container
   */
  export type ACEStatusLog$containerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
  }

  /**
   * ACEStatusLog without action
   */
  export type ACEStatusLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ACEStatusLog
     */
    select?: ACEStatusLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ACEStatusLogInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityMinAggregateOutputType = {
    facilityName: string | null
    facilityCode: string | null
    facilityType: string | null
    portId: string | null
    address: string | null
    unLocationCode: string | null
    isActive: boolean | null
  }

  export type FacilityMaxAggregateOutputType = {
    facilityName: string | null
    facilityCode: string | null
    facilityType: string | null
    portId: string | null
    address: string | null
    unLocationCode: string | null
    isActive: boolean | null
  }

  export type FacilityCountAggregateOutputType = {
    facilityName: number
    facilityCode: number
    facilityType: number
    portId: number
    address: number
    unLocationCode: number
    isActive: number
    _all: number
  }


  export type FacilityMinAggregateInputType = {
    facilityName?: true
    facilityCode?: true
    facilityType?: true
    portId?: true
    address?: true
    unLocationCode?: true
    isActive?: true
  }

  export type FacilityMaxAggregateInputType = {
    facilityName?: true
    facilityCode?: true
    facilityType?: true
    portId?: true
    address?: true
    unLocationCode?: true
    isActive?: true
  }

  export type FacilityCountAggregateInputType = {
    facilityName?: true
    facilityCode?: true
    facilityType?: true
    portId?: true
    address?: true
    unLocationCode?: true
    isActive?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    facilityName: string
    facilityCode: string | null
    facilityType: string | null
    portId: string | null
    address: string | null
    unLocationCode: string | null
    isActive: boolean
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    facilityName?: boolean
    facilityCode?: boolean
    facilityType?: boolean
    portId?: boolean
    address?: boolean
    unLocationCode?: boolean
    isActive?: boolean
    containerEvents?: boolean | Facility$containerEventsArgs<ExtArgs>
    port?: boolean | Facility$portArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    facilityName?: boolean
    facilityCode?: boolean
    facilityType?: boolean
    portId?: boolean
    address?: boolean
    unLocationCode?: boolean
    isActive?: boolean
    port?: boolean | Facility$portArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    facilityName?: boolean
    facilityCode?: boolean
    facilityType?: boolean
    portId?: boolean
    address?: boolean
    unLocationCode?: boolean
    isActive?: boolean
  }

  export type FacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerEvents?: boolean | Facility$containerEventsArgs<ExtArgs>
    port?: boolean | Facility$portArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    port?: boolean | Facility$portArgs<ExtArgs>
  }

  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {
      containerEvents: Prisma.$ContainerEventPayload<ExtArgs>[]
      port: Prisma.$PortPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      facilityName: string
      facilityCode: string | null
      facilityType: string | null
      portId: string | null
      address: string | null
      unLocationCode: string | null
      isActive: boolean
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }

  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `facilityName`
     * const facilityWithFacilityNameOnly = await prisma.facility.findMany({ select: { facilityName: true } })
     * 
     */
    findMany<T extends FacilityFindManyArgs>(args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
     */
    create<T extends FacilityCreateArgs>(args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCreateManyArgs>(args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `facilityName`
     * const facilityWithFacilityNameOnly = await prisma.facility.createManyAndReturn({ 
     *   select: { facilityName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
     */
    delete<T extends FacilityDeleteArgs>(args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityUpdateArgs>(args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityDeleteManyArgs>(args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityUpdateManyArgs>(args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    containerEvents<T extends Facility$containerEventsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$containerEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerEventPayload<ExtArgs>, T, "findMany"> | Null>
    port<T extends Facility$portArgs<ExtArgs> = {}>(args?: Subset<T, Facility$portArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facility model
   */ 
  interface FacilityFieldRefs {
    readonly facilityName: FieldRef<"Facility", 'String'>
    readonly facilityCode: FieldRef<"Facility", 'String'>
    readonly facilityType: FieldRef<"Facility", 'String'>
    readonly portId: FieldRef<"Facility", 'String'>
    readonly address: FieldRef<"Facility", 'String'>
    readonly unLocationCode: FieldRef<"Facility", 'String'>
    readonly isActive: FieldRef<"Facility", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility.containerEvents
   */
  export type Facility$containerEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerEvent
     */
    select?: ContainerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerEventInclude<ExtArgs> | null
    where?: ContainerEventWhereInput
    orderBy?: ContainerEventOrderByWithRelationInput | ContainerEventOrderByWithRelationInput[]
    cursor?: ContainerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerEventScalarFieldEnum | ContainerEventScalarFieldEnum[]
  }

  /**
   * Facility.port
   */
  export type Facility$portArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    where?: PortWhereInput
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
  }


  /**
   * Model Carrier
   */

  export type AggregateCarrier = {
    _count: CarrierCountAggregateOutputType | null
    _min: CarrierMinAggregateOutputType | null
    _max: CarrierMaxAggregateOutputType | null
  }

  export type CarrierMinAggregateOutputType = {
    carrierName: string | null
    scac: string | null
    shortName: string | null
    trackingURL: string | null
    isActive: boolean | null
    dcsaCompliant: boolean | null
    apiEndpoint: string | null
    apiCredentialRef: string | null
  }

  export type CarrierMaxAggregateOutputType = {
    carrierName: string | null
    scac: string | null
    shortName: string | null
    trackingURL: string | null
    isActive: boolean | null
    dcsaCompliant: boolean | null
    apiEndpoint: string | null
    apiCredentialRef: string | null
  }

  export type CarrierCountAggregateOutputType = {
    carrierName: number
    scac: number
    shortName: number
    trackingURL: number
    isActive: number
    dcsaCompliant: number
    apiEndpoint: number
    apiCredentialRef: number
    _all: number
  }


  export type CarrierMinAggregateInputType = {
    carrierName?: true
    scac?: true
    shortName?: true
    trackingURL?: true
    isActive?: true
    dcsaCompliant?: true
    apiEndpoint?: true
    apiCredentialRef?: true
  }

  export type CarrierMaxAggregateInputType = {
    carrierName?: true
    scac?: true
    shortName?: true
    trackingURL?: true
    isActive?: true
    dcsaCompliant?: true
    apiEndpoint?: true
    apiCredentialRef?: true
  }

  export type CarrierCountAggregateInputType = {
    carrierName?: true
    scac?: true
    shortName?: true
    trackingURL?: true
    isActive?: true
    dcsaCompliant?: true
    apiEndpoint?: true
    apiCredentialRef?: true
    _all?: true
  }

  export type CarrierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carrier to aggregate.
     */
    where?: CarrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carriers to fetch.
     */
    orderBy?: CarrierOrderByWithRelationInput | CarrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carriers
    **/
    _count?: true | CarrierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarrierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarrierMaxAggregateInputType
  }

  export type GetCarrierAggregateType<T extends CarrierAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrier[P]>
      : GetScalarType<T[P], AggregateCarrier[P]>
  }




  export type CarrierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarrierWhereInput
    orderBy?: CarrierOrderByWithAggregationInput | CarrierOrderByWithAggregationInput[]
    by: CarrierScalarFieldEnum[] | CarrierScalarFieldEnum
    having?: CarrierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarrierCountAggregateInputType | true
    _min?: CarrierMinAggregateInputType
    _max?: CarrierMaxAggregateInputType
  }

  export type CarrierGroupByOutputType = {
    carrierName: string
    scac: string | null
    shortName: string | null
    trackingURL: string | null
    isActive: boolean
    dcsaCompliant: boolean | null
    apiEndpoint: string | null
    apiCredentialRef: string | null
    _count: CarrierCountAggregateOutputType | null
    _min: CarrierMinAggregateOutputType | null
    _max: CarrierMaxAggregateOutputType | null
  }

  type GetCarrierGroupByPayload<T extends CarrierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarrierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarrierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarrierGroupByOutputType[P]>
            : GetScalarType<T[P], CarrierGroupByOutputType[P]>
        }
      >
    >


  export type CarrierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    carrierName?: boolean
    scac?: boolean
    shortName?: boolean
    trackingURL?: boolean
    isActive?: boolean
    dcsaCompliant?: boolean
    apiEndpoint?: boolean
    apiCredentialRef?: boolean
    carrierFormats?: boolean | Carrier$carrierFormatsArgs<ExtArgs>
    dcsaEventMaps?: boolean | Carrier$dcsaEventMapsArgs<ExtArgs>
    demurrageRates?: boolean | Carrier$demurrageRatesArgs<ExtArgs>
    _count?: boolean | CarrierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrier"]>

  export type CarrierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    carrierName?: boolean
    scac?: boolean
    shortName?: boolean
    trackingURL?: boolean
    isActive?: boolean
    dcsaCompliant?: boolean
    apiEndpoint?: boolean
    apiCredentialRef?: boolean
  }, ExtArgs["result"]["carrier"]>

  export type CarrierSelectScalar = {
    carrierName?: boolean
    scac?: boolean
    shortName?: boolean
    trackingURL?: boolean
    isActive?: boolean
    dcsaCompliant?: boolean
    apiEndpoint?: boolean
    apiCredentialRef?: boolean
  }

  export type CarrierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrierFormats?: boolean | Carrier$carrierFormatsArgs<ExtArgs>
    dcsaEventMaps?: boolean | Carrier$dcsaEventMapsArgs<ExtArgs>
    demurrageRates?: boolean | Carrier$demurrageRatesArgs<ExtArgs>
    _count?: boolean | CarrierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarrierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CarrierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carrier"
    objects: {
      carrierFormats: Prisma.$CarrierFormatPayload<ExtArgs>[]
      dcsaEventMaps: Prisma.$DCSAEventMapPayload<ExtArgs>[]
      demurrageRates: Prisma.$DemurrageRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      carrierName: string
      scac: string | null
      shortName: string | null
      trackingURL: string | null
      isActive: boolean
      dcsaCompliant: boolean | null
      apiEndpoint: string | null
      apiCredentialRef: string | null
    }, ExtArgs["result"]["carrier"]>
    composites: {}
  }

  type CarrierGetPayload<S extends boolean | null | undefined | CarrierDefaultArgs> = $Result.GetResult<Prisma.$CarrierPayload, S>

  type CarrierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarrierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarrierCountAggregateInputType | true
    }

  export interface CarrierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carrier'], meta: { name: 'Carrier' } }
    /**
     * Find zero or one Carrier that matches the filter.
     * @param {CarrierFindUniqueArgs} args - Arguments to find a Carrier
     * @example
     * // Get one Carrier
     * const carrier = await prisma.carrier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarrierFindUniqueArgs>(args: SelectSubset<T, CarrierFindUniqueArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Carrier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CarrierFindUniqueOrThrowArgs} args - Arguments to find a Carrier
     * @example
     * // Get one Carrier
     * const carrier = await prisma.carrier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarrierFindUniqueOrThrowArgs>(args: SelectSubset<T, CarrierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Carrier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFindFirstArgs} args - Arguments to find a Carrier
     * @example
     * // Get one Carrier
     * const carrier = await prisma.carrier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarrierFindFirstArgs>(args?: SelectSubset<T, CarrierFindFirstArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Carrier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFindFirstOrThrowArgs} args - Arguments to find a Carrier
     * @example
     * // Get one Carrier
     * const carrier = await prisma.carrier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarrierFindFirstOrThrowArgs>(args?: SelectSubset<T, CarrierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Carriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carriers
     * const carriers = await prisma.carrier.findMany()
     * 
     * // Get first 10 Carriers
     * const carriers = await prisma.carrier.findMany({ take: 10 })
     * 
     * // Only select the `carrierName`
     * const carrierWithCarrierNameOnly = await prisma.carrier.findMany({ select: { carrierName: true } })
     * 
     */
    findMany<T extends CarrierFindManyArgs>(args?: SelectSubset<T, CarrierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Carrier.
     * @param {CarrierCreateArgs} args - Arguments to create a Carrier.
     * @example
     * // Create one Carrier
     * const Carrier = await prisma.carrier.create({
     *   data: {
     *     // ... data to create a Carrier
     *   }
     * })
     * 
     */
    create<T extends CarrierCreateArgs>(args: SelectSubset<T, CarrierCreateArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Carriers.
     * @param {CarrierCreateManyArgs} args - Arguments to create many Carriers.
     * @example
     * // Create many Carriers
     * const carrier = await prisma.carrier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarrierCreateManyArgs>(args?: SelectSubset<T, CarrierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carriers and returns the data saved in the database.
     * @param {CarrierCreateManyAndReturnArgs} args - Arguments to create many Carriers.
     * @example
     * // Create many Carriers
     * const carrier = await prisma.carrier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carriers and only return the `carrierName`
     * const carrierWithCarrierNameOnly = await prisma.carrier.createManyAndReturn({ 
     *   select: { carrierName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarrierCreateManyAndReturnArgs>(args?: SelectSubset<T, CarrierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Carrier.
     * @param {CarrierDeleteArgs} args - Arguments to delete one Carrier.
     * @example
     * // Delete one Carrier
     * const Carrier = await prisma.carrier.delete({
     *   where: {
     *     // ... filter to delete one Carrier
     *   }
     * })
     * 
     */
    delete<T extends CarrierDeleteArgs>(args: SelectSubset<T, CarrierDeleteArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Carrier.
     * @param {CarrierUpdateArgs} args - Arguments to update one Carrier.
     * @example
     * // Update one Carrier
     * const carrier = await prisma.carrier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarrierUpdateArgs>(args: SelectSubset<T, CarrierUpdateArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Carriers.
     * @param {CarrierDeleteManyArgs} args - Arguments to filter Carriers to delete.
     * @example
     * // Delete a few Carriers
     * const { count } = await prisma.carrier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarrierDeleteManyArgs>(args?: SelectSubset<T, CarrierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carriers
     * const carrier = await prisma.carrier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarrierUpdateManyArgs>(args: SelectSubset<T, CarrierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Carrier.
     * @param {CarrierUpsertArgs} args - Arguments to update or create a Carrier.
     * @example
     * // Update or create a Carrier
     * const carrier = await prisma.carrier.upsert({
     *   create: {
     *     // ... data to create a Carrier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carrier we want to update
     *   }
     * })
     */
    upsert<T extends CarrierUpsertArgs>(args: SelectSubset<T, CarrierUpsertArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Carriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierCountArgs} args - Arguments to filter Carriers to count.
     * @example
     * // Count the number of Carriers
     * const count = await prisma.carrier.count({
     *   where: {
     *     // ... the filter for the Carriers we want to count
     *   }
     * })
    **/
    count<T extends CarrierCountArgs>(
      args?: Subset<T, CarrierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarrierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carrier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarrierAggregateArgs>(args: Subset<T, CarrierAggregateArgs>): Prisma.PrismaPromise<GetCarrierAggregateType<T>>

    /**
     * Group by Carrier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarrierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarrierGroupByArgs['orderBy'] }
        : { orderBy?: CarrierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarrierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarrierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carrier model
   */
  readonly fields: CarrierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carrier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarrierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carrierFormats<T extends Carrier$carrierFormatsArgs<ExtArgs> = {}>(args?: Subset<T, Carrier$carrierFormatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findMany"> | Null>
    dcsaEventMaps<T extends Carrier$dcsaEventMapsArgs<ExtArgs> = {}>(args?: Subset<T, Carrier$dcsaEventMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findMany"> | Null>
    demurrageRates<T extends Carrier$demurrageRatesArgs<ExtArgs> = {}>(args?: Subset<T, Carrier$demurrageRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carrier model
   */ 
  interface CarrierFieldRefs {
    readonly carrierName: FieldRef<"Carrier", 'String'>
    readonly scac: FieldRef<"Carrier", 'String'>
    readonly shortName: FieldRef<"Carrier", 'String'>
    readonly trackingURL: FieldRef<"Carrier", 'String'>
    readonly isActive: FieldRef<"Carrier", 'Boolean'>
    readonly dcsaCompliant: FieldRef<"Carrier", 'Boolean'>
    readonly apiEndpoint: FieldRef<"Carrier", 'String'>
    readonly apiCredentialRef: FieldRef<"Carrier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Carrier findUnique
   */
  export type CarrierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * Filter, which Carrier to fetch.
     */
    where: CarrierWhereUniqueInput
  }

  /**
   * Carrier findUniqueOrThrow
   */
  export type CarrierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * Filter, which Carrier to fetch.
     */
    where: CarrierWhereUniqueInput
  }

  /**
   * Carrier findFirst
   */
  export type CarrierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * Filter, which Carrier to fetch.
     */
    where?: CarrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carriers to fetch.
     */
    orderBy?: CarrierOrderByWithRelationInput | CarrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carriers.
     */
    cursor?: CarrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carriers.
     */
    distinct?: CarrierScalarFieldEnum | CarrierScalarFieldEnum[]
  }

  /**
   * Carrier findFirstOrThrow
   */
  export type CarrierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * Filter, which Carrier to fetch.
     */
    where?: CarrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carriers to fetch.
     */
    orderBy?: CarrierOrderByWithRelationInput | CarrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carriers.
     */
    cursor?: CarrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carriers.
     */
    distinct?: CarrierScalarFieldEnum | CarrierScalarFieldEnum[]
  }

  /**
   * Carrier findMany
   */
  export type CarrierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * Filter, which Carriers to fetch.
     */
    where?: CarrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carriers to fetch.
     */
    orderBy?: CarrierOrderByWithRelationInput | CarrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carriers.
     */
    cursor?: CarrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carriers.
     */
    skip?: number
    distinct?: CarrierScalarFieldEnum | CarrierScalarFieldEnum[]
  }

  /**
   * Carrier create
   */
  export type CarrierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * The data needed to create a Carrier.
     */
    data: XOR<CarrierCreateInput, CarrierUncheckedCreateInput>
  }

  /**
   * Carrier createMany
   */
  export type CarrierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carriers.
     */
    data: CarrierCreateManyInput | CarrierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carrier createManyAndReturn
   */
  export type CarrierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Carriers.
     */
    data: CarrierCreateManyInput | CarrierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carrier update
   */
  export type CarrierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * The data needed to update a Carrier.
     */
    data: XOR<CarrierUpdateInput, CarrierUncheckedUpdateInput>
    /**
     * Choose, which Carrier to update.
     */
    where: CarrierWhereUniqueInput
  }

  /**
   * Carrier updateMany
   */
  export type CarrierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carriers.
     */
    data: XOR<CarrierUpdateManyMutationInput, CarrierUncheckedUpdateManyInput>
    /**
     * Filter which Carriers to update
     */
    where?: CarrierWhereInput
  }

  /**
   * Carrier upsert
   */
  export type CarrierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * The filter to search for the Carrier to update in case it exists.
     */
    where: CarrierWhereUniqueInput
    /**
     * In case the Carrier found by the `where` argument doesn't exist, create a new Carrier with this data.
     */
    create: XOR<CarrierCreateInput, CarrierUncheckedCreateInput>
    /**
     * In case the Carrier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarrierUpdateInput, CarrierUncheckedUpdateInput>
  }

  /**
   * Carrier delete
   */
  export type CarrierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    /**
     * Filter which Carrier to delete.
     */
    where: CarrierWhereUniqueInput
  }

  /**
   * Carrier deleteMany
   */
  export type CarrierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carriers to delete
     */
    where?: CarrierWhereInput
  }

  /**
   * Carrier.carrierFormats
   */
  export type Carrier$carrierFormatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    where?: CarrierFormatWhereInput
    orderBy?: CarrierFormatOrderByWithRelationInput | CarrierFormatOrderByWithRelationInput[]
    cursor?: CarrierFormatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarrierFormatScalarFieldEnum | CarrierFormatScalarFieldEnum[]
  }

  /**
   * Carrier.dcsaEventMaps
   */
  export type Carrier$dcsaEventMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    where?: DCSAEventMapWhereInput
    orderBy?: DCSAEventMapOrderByWithRelationInput | DCSAEventMapOrderByWithRelationInput[]
    cursor?: DCSAEventMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DCSAEventMapScalarFieldEnum | DCSAEventMapScalarFieldEnum[]
  }

  /**
   * Carrier.demurrageRates
   */
  export type Carrier$demurrageRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    where?: DemurrageRateWhereInput
    orderBy?: DemurrageRateOrderByWithRelationInput | DemurrageRateOrderByWithRelationInput[]
    cursor?: DemurrageRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DemurrageRateScalarFieldEnum | DemurrageRateScalarFieldEnum[]
  }

  /**
   * Carrier without action
   */
  export type CarrierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
  }


  /**
   * Model Port
   */

  export type AggregatePort = {
    _count: PortCountAggregateOutputType | null
    _avg: PortAvgAggregateOutputType | null
    _sum: PortSumAggregateOutputType | null
    _min: PortMinAggregateOutputType | null
    _max: PortMaxAggregateOutputType | null
  }

  export type PortAvgAggregateOutputType = {
    defaultFreeDays: number | null
  }

  export type PortSumAggregateOutputType = {
    defaultFreeDays: number | null
  }

  export type PortMinAggregateOutputType = {
    portName: string | null
    portCode: string | null
    country: string | null
    countryCode: string | null
    region: string | null
    defaultFreeDays: number | null
    isActive: boolean | null
    acePortCode: string | null
    cbpDistrict: string | null
  }

  export type PortMaxAggregateOutputType = {
    portName: string | null
    portCode: string | null
    country: string | null
    countryCode: string | null
    region: string | null
    defaultFreeDays: number | null
    isActive: boolean | null
    acePortCode: string | null
    cbpDistrict: string | null
  }

  export type PortCountAggregateOutputType = {
    portName: number
    portCode: number
    country: number
    countryCode: number
    region: number
    defaultFreeDays: number
    isActive: number
    acePortCode: number
    cbpDistrict: number
    _all: number
  }


  export type PortAvgAggregateInputType = {
    defaultFreeDays?: true
  }

  export type PortSumAggregateInputType = {
    defaultFreeDays?: true
  }

  export type PortMinAggregateInputType = {
    portName?: true
    portCode?: true
    country?: true
    countryCode?: true
    region?: true
    defaultFreeDays?: true
    isActive?: true
    acePortCode?: true
    cbpDistrict?: true
  }

  export type PortMaxAggregateInputType = {
    portName?: true
    portCode?: true
    country?: true
    countryCode?: true
    region?: true
    defaultFreeDays?: true
    isActive?: true
    acePortCode?: true
    cbpDistrict?: true
  }

  export type PortCountAggregateInputType = {
    portName?: true
    portCode?: true
    country?: true
    countryCode?: true
    region?: true
    defaultFreeDays?: true
    isActive?: true
    acePortCode?: true
    cbpDistrict?: true
    _all?: true
  }

  export type PortAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Port to aggregate.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ports
    **/
    _count?: true | PortCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortMaxAggregateInputType
  }

  export type GetPortAggregateType<T extends PortAggregateArgs> = {
        [P in keyof T & keyof AggregatePort]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePort[P]>
      : GetScalarType<T[P], AggregatePort[P]>
  }




  export type PortGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortWhereInput
    orderBy?: PortOrderByWithAggregationInput | PortOrderByWithAggregationInput[]
    by: PortScalarFieldEnum[] | PortScalarFieldEnum
    having?: PortScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortCountAggregateInputType | true
    _avg?: PortAvgAggregateInputType
    _sum?: PortSumAggregateInputType
    _min?: PortMinAggregateInputType
    _max?: PortMaxAggregateInputType
  }

  export type PortGroupByOutputType = {
    portName: string
    portCode: string | null
    country: string | null
    countryCode: string | null
    region: string | null
    defaultFreeDays: number | null
    isActive: boolean
    acePortCode: string | null
    cbpDistrict: string | null
    _count: PortCountAggregateOutputType | null
    _avg: PortAvgAggregateOutputType | null
    _sum: PortSumAggregateOutputType | null
    _min: PortMinAggregateOutputType | null
    _max: PortMaxAggregateOutputType | null
  }

  type GetPortGroupByPayload<T extends PortGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortGroupByOutputType[P]>
            : GetScalarType<T[P], PortGroupByOutputType[P]>
        }
      >
    >


  export type PortSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portName?: boolean
    portCode?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    defaultFreeDays?: boolean
    isActive?: boolean
    acePortCode?: boolean
    cbpDistrict?: boolean
    demurrageRates?: boolean | Port$demurrageRatesArgs<ExtArgs>
    facilities?: boolean | Port$facilitiesArgs<ExtArgs>
    _count?: boolean | PortCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["port"]>

  export type PortSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portName?: boolean
    portCode?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    defaultFreeDays?: boolean
    isActive?: boolean
    acePortCode?: boolean
    cbpDistrict?: boolean
  }, ExtArgs["result"]["port"]>

  export type PortSelectScalar = {
    portName?: boolean
    portCode?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    defaultFreeDays?: boolean
    isActive?: boolean
    acePortCode?: boolean
    cbpDistrict?: boolean
  }

  export type PortInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    demurrageRates?: boolean | Port$demurrageRatesArgs<ExtArgs>
    facilities?: boolean | Port$facilitiesArgs<ExtArgs>
    _count?: boolean | PortCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PortPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Port"
    objects: {
      demurrageRates: Prisma.$DemurrageRatePayload<ExtArgs>[]
      facilities: Prisma.$FacilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      portName: string
      portCode: string | null
      country: string | null
      countryCode: string | null
      region: string | null
      defaultFreeDays: number | null
      isActive: boolean
      acePortCode: string | null
      cbpDistrict: string | null
    }, ExtArgs["result"]["port"]>
    composites: {}
  }

  type PortGetPayload<S extends boolean | null | undefined | PortDefaultArgs> = $Result.GetResult<Prisma.$PortPayload, S>

  type PortCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortCountAggregateInputType | true
    }

  export interface PortDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Port'], meta: { name: 'Port' } }
    /**
     * Find zero or one Port that matches the filter.
     * @param {PortFindUniqueArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortFindUniqueArgs>(args: SelectSubset<T, PortFindUniqueArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Port that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortFindUniqueOrThrowArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortFindUniqueOrThrowArgs>(args: SelectSubset<T, PortFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Port that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortFindFirstArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortFindFirstArgs>(args?: SelectSubset<T, PortFindFirstArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Port that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortFindFirstOrThrowArgs} args - Arguments to find a Port
     * @example
     * // Get one Port
     * const port = await prisma.port.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortFindFirstOrThrowArgs>(args?: SelectSubset<T, PortFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ports
     * const ports = await prisma.port.findMany()
     * 
     * // Get first 10 Ports
     * const ports = await prisma.port.findMany({ take: 10 })
     * 
     * // Only select the `portName`
     * const portWithPortNameOnly = await prisma.port.findMany({ select: { portName: true } })
     * 
     */
    findMany<T extends PortFindManyArgs>(args?: SelectSubset<T, PortFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Port.
     * @param {PortCreateArgs} args - Arguments to create a Port.
     * @example
     * // Create one Port
     * const Port = await prisma.port.create({
     *   data: {
     *     // ... data to create a Port
     *   }
     * })
     * 
     */
    create<T extends PortCreateArgs>(args: SelectSubset<T, PortCreateArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ports.
     * @param {PortCreateManyArgs} args - Arguments to create many Ports.
     * @example
     * // Create many Ports
     * const port = await prisma.port.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortCreateManyArgs>(args?: SelectSubset<T, PortCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ports and returns the data saved in the database.
     * @param {PortCreateManyAndReturnArgs} args - Arguments to create many Ports.
     * @example
     * // Create many Ports
     * const port = await prisma.port.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ports and only return the `portName`
     * const portWithPortNameOnly = await prisma.port.createManyAndReturn({ 
     *   select: { portName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortCreateManyAndReturnArgs>(args?: SelectSubset<T, PortCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Port.
     * @param {PortDeleteArgs} args - Arguments to delete one Port.
     * @example
     * // Delete one Port
     * const Port = await prisma.port.delete({
     *   where: {
     *     // ... filter to delete one Port
     *   }
     * })
     * 
     */
    delete<T extends PortDeleteArgs>(args: SelectSubset<T, PortDeleteArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Port.
     * @param {PortUpdateArgs} args - Arguments to update one Port.
     * @example
     * // Update one Port
     * const port = await prisma.port.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortUpdateArgs>(args: SelectSubset<T, PortUpdateArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ports.
     * @param {PortDeleteManyArgs} args - Arguments to filter Ports to delete.
     * @example
     * // Delete a few Ports
     * const { count } = await prisma.port.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortDeleteManyArgs>(args?: SelectSubset<T, PortDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ports
     * const port = await prisma.port.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortUpdateManyArgs>(args: SelectSubset<T, PortUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Port.
     * @param {PortUpsertArgs} args - Arguments to update or create a Port.
     * @example
     * // Update or create a Port
     * const port = await prisma.port.upsert({
     *   create: {
     *     // ... data to create a Port
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Port we want to update
     *   }
     * })
     */
    upsert<T extends PortUpsertArgs>(args: SelectSubset<T, PortUpsertArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortCountArgs} args - Arguments to filter Ports to count.
     * @example
     * // Count the number of Ports
     * const count = await prisma.port.count({
     *   where: {
     *     // ... the filter for the Ports we want to count
     *   }
     * })
    **/
    count<T extends PortCountArgs>(
      args?: Subset<T, PortCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Port.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortAggregateArgs>(args: Subset<T, PortAggregateArgs>): Prisma.PrismaPromise<GetPortAggregateType<T>>

    /**
     * Group by Port.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortGroupByArgs['orderBy'] }
        : { orderBy?: PortGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Port model
   */
  readonly fields: PortFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Port.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    demurrageRates<T extends Port$demurrageRatesArgs<ExtArgs> = {}>(args?: Subset<T, Port$demurrageRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findMany"> | Null>
    facilities<T extends Port$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Port$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Port model
   */ 
  interface PortFieldRefs {
    readonly portName: FieldRef<"Port", 'String'>
    readonly portCode: FieldRef<"Port", 'String'>
    readonly country: FieldRef<"Port", 'String'>
    readonly countryCode: FieldRef<"Port", 'String'>
    readonly region: FieldRef<"Port", 'String'>
    readonly defaultFreeDays: FieldRef<"Port", 'Int'>
    readonly isActive: FieldRef<"Port", 'Boolean'>
    readonly acePortCode: FieldRef<"Port", 'String'>
    readonly cbpDistrict: FieldRef<"Port", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Port findUnique
   */
  export type PortFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port findUniqueOrThrow
   */
  export type PortFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port findFirst
   */
  export type PortFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ports.
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ports.
     */
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Port findFirstOrThrow
   */
  export type PortFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Port to fetch.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ports.
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ports.
     */
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Port findMany
   */
  export type PortFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter, which Ports to fetch.
     */
    where?: PortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ports to fetch.
     */
    orderBy?: PortOrderByWithRelationInput | PortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ports.
     */
    cursor?: PortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ports.
     */
    skip?: number
    distinct?: PortScalarFieldEnum | PortScalarFieldEnum[]
  }

  /**
   * Port create
   */
  export type PortCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * The data needed to create a Port.
     */
    data: XOR<PortCreateInput, PortUncheckedCreateInput>
  }

  /**
   * Port createMany
   */
  export type PortCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ports.
     */
    data: PortCreateManyInput | PortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Port createManyAndReturn
   */
  export type PortCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ports.
     */
    data: PortCreateManyInput | PortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Port update
   */
  export type PortUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * The data needed to update a Port.
     */
    data: XOR<PortUpdateInput, PortUncheckedUpdateInput>
    /**
     * Choose, which Port to update.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port updateMany
   */
  export type PortUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ports.
     */
    data: XOR<PortUpdateManyMutationInput, PortUncheckedUpdateManyInput>
    /**
     * Filter which Ports to update
     */
    where?: PortWhereInput
  }

  /**
   * Port upsert
   */
  export type PortUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * The filter to search for the Port to update in case it exists.
     */
    where: PortWhereUniqueInput
    /**
     * In case the Port found by the `where` argument doesn't exist, create a new Port with this data.
     */
    create: XOR<PortCreateInput, PortUncheckedCreateInput>
    /**
     * In case the Port was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortUpdateInput, PortUncheckedUpdateInput>
  }

  /**
   * Port delete
   */
  export type PortDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    /**
     * Filter which Port to delete.
     */
    where: PortWhereUniqueInput
  }

  /**
   * Port deleteMany
   */
  export type PortDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ports to delete
     */
    where?: PortWhereInput
  }

  /**
   * Port.demurrageRates
   */
  export type Port$demurrageRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    where?: DemurrageRateWhereInput
    orderBy?: DemurrageRateOrderByWithRelationInput | DemurrageRateOrderByWithRelationInput[]
    cursor?: DemurrageRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DemurrageRateScalarFieldEnum | DemurrageRateScalarFieldEnum[]
  }

  /**
   * Port.facilities
   */
  export type Port$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Port without action
   */
  export type PortDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
  }


  /**
   * Model Forwarder
   */

  export type AggregateForwarder = {
    _count: ForwarderCountAggregateOutputType | null
    _min: ForwarderMinAggregateOutputType | null
    _max: ForwarderMaxAggregateOutputType | null
  }

  export type ForwarderMinAggregateOutputType = {
    forwarderName: string | null
    shortName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    notes: string | null
    isActive: boolean | null
    customsBroker: string | null
    aceFilerCode: string | null
  }

  export type ForwarderMaxAggregateOutputType = {
    forwarderName: string | null
    shortName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    notes: string | null
    isActive: boolean | null
    customsBroker: string | null
    aceFilerCode: string | null
  }

  export type ForwarderCountAggregateOutputType = {
    forwarderName: number
    shortName: number
    contactName: number
    contactEmail: number
    contactPhone: number
    address: number
    notes: number
    isActive: number
    customsBroker: number
    aceFilerCode: number
    _all: number
  }


  export type ForwarderMinAggregateInputType = {
    forwarderName?: true
    shortName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    notes?: true
    isActive?: true
    customsBroker?: true
    aceFilerCode?: true
  }

  export type ForwarderMaxAggregateInputType = {
    forwarderName?: true
    shortName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    notes?: true
    isActive?: true
    customsBroker?: true
    aceFilerCode?: true
  }

  export type ForwarderCountAggregateInputType = {
    forwarderName?: true
    shortName?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    notes?: true
    isActive?: true
    customsBroker?: true
    aceFilerCode?: true
    _all?: true
  }

  export type ForwarderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forwarder to aggregate.
     */
    where?: ForwarderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forwarders to fetch.
     */
    orderBy?: ForwarderOrderByWithRelationInput | ForwarderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForwarderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forwarders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forwarders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forwarders
    **/
    _count?: true | ForwarderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForwarderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForwarderMaxAggregateInputType
  }

  export type GetForwarderAggregateType<T extends ForwarderAggregateArgs> = {
        [P in keyof T & keyof AggregateForwarder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForwarder[P]>
      : GetScalarType<T[P], AggregateForwarder[P]>
  }




  export type ForwarderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForwarderWhereInput
    orderBy?: ForwarderOrderByWithAggregationInput | ForwarderOrderByWithAggregationInput[]
    by: ForwarderScalarFieldEnum[] | ForwarderScalarFieldEnum
    having?: ForwarderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForwarderCountAggregateInputType | true
    _min?: ForwarderMinAggregateInputType
    _max?: ForwarderMaxAggregateInputType
  }

  export type ForwarderGroupByOutputType = {
    forwarderName: string
    shortName: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    notes: string | null
    isActive: boolean
    customsBroker: string | null
    aceFilerCode: string | null
    _count: ForwarderCountAggregateOutputType | null
    _min: ForwarderMinAggregateOutputType | null
    _max: ForwarderMaxAggregateOutputType | null
  }

  type GetForwarderGroupByPayload<T extends ForwarderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForwarderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForwarderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForwarderGroupByOutputType[P]>
            : GetScalarType<T[P], ForwarderGroupByOutputType[P]>
        }
      >
    >


  export type ForwarderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    forwarderName?: boolean
    shortName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    customsBroker?: boolean
    aceFilerCode?: boolean
  }, ExtArgs["result"]["forwarder"]>

  export type ForwarderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    forwarderName?: boolean
    shortName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    customsBroker?: boolean
    aceFilerCode?: boolean
  }, ExtArgs["result"]["forwarder"]>

  export type ForwarderSelectScalar = {
    forwarderName?: boolean
    shortName?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    notes?: boolean
    isActive?: boolean
    customsBroker?: boolean
    aceFilerCode?: boolean
  }


  export type $ForwarderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Forwarder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      forwarderName: string
      shortName: string | null
      contactName: string | null
      contactEmail: string | null
      contactPhone: string | null
      address: string | null
      notes: string | null
      isActive: boolean
      customsBroker: string | null
      aceFilerCode: string | null
    }, ExtArgs["result"]["forwarder"]>
    composites: {}
  }

  type ForwarderGetPayload<S extends boolean | null | undefined | ForwarderDefaultArgs> = $Result.GetResult<Prisma.$ForwarderPayload, S>

  type ForwarderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForwarderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForwarderCountAggregateInputType | true
    }

  export interface ForwarderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Forwarder'], meta: { name: 'Forwarder' } }
    /**
     * Find zero or one Forwarder that matches the filter.
     * @param {ForwarderFindUniqueArgs} args - Arguments to find a Forwarder
     * @example
     * // Get one Forwarder
     * const forwarder = await prisma.forwarder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForwarderFindUniqueArgs>(args: SelectSubset<T, ForwarderFindUniqueArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Forwarder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForwarderFindUniqueOrThrowArgs} args - Arguments to find a Forwarder
     * @example
     * // Get one Forwarder
     * const forwarder = await prisma.forwarder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForwarderFindUniqueOrThrowArgs>(args: SelectSubset<T, ForwarderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Forwarder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderFindFirstArgs} args - Arguments to find a Forwarder
     * @example
     * // Get one Forwarder
     * const forwarder = await prisma.forwarder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForwarderFindFirstArgs>(args?: SelectSubset<T, ForwarderFindFirstArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Forwarder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderFindFirstOrThrowArgs} args - Arguments to find a Forwarder
     * @example
     * // Get one Forwarder
     * const forwarder = await prisma.forwarder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForwarderFindFirstOrThrowArgs>(args?: SelectSubset<T, ForwarderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Forwarders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forwarders
     * const forwarders = await prisma.forwarder.findMany()
     * 
     * // Get first 10 Forwarders
     * const forwarders = await prisma.forwarder.findMany({ take: 10 })
     * 
     * // Only select the `forwarderName`
     * const forwarderWithForwarderNameOnly = await prisma.forwarder.findMany({ select: { forwarderName: true } })
     * 
     */
    findMany<T extends ForwarderFindManyArgs>(args?: SelectSubset<T, ForwarderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Forwarder.
     * @param {ForwarderCreateArgs} args - Arguments to create a Forwarder.
     * @example
     * // Create one Forwarder
     * const Forwarder = await prisma.forwarder.create({
     *   data: {
     *     // ... data to create a Forwarder
     *   }
     * })
     * 
     */
    create<T extends ForwarderCreateArgs>(args: SelectSubset<T, ForwarderCreateArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Forwarders.
     * @param {ForwarderCreateManyArgs} args - Arguments to create many Forwarders.
     * @example
     * // Create many Forwarders
     * const forwarder = await prisma.forwarder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForwarderCreateManyArgs>(args?: SelectSubset<T, ForwarderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forwarders and returns the data saved in the database.
     * @param {ForwarderCreateManyAndReturnArgs} args - Arguments to create many Forwarders.
     * @example
     * // Create many Forwarders
     * const forwarder = await prisma.forwarder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forwarders and only return the `forwarderName`
     * const forwarderWithForwarderNameOnly = await prisma.forwarder.createManyAndReturn({ 
     *   select: { forwarderName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForwarderCreateManyAndReturnArgs>(args?: SelectSubset<T, ForwarderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Forwarder.
     * @param {ForwarderDeleteArgs} args - Arguments to delete one Forwarder.
     * @example
     * // Delete one Forwarder
     * const Forwarder = await prisma.forwarder.delete({
     *   where: {
     *     // ... filter to delete one Forwarder
     *   }
     * })
     * 
     */
    delete<T extends ForwarderDeleteArgs>(args: SelectSubset<T, ForwarderDeleteArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Forwarder.
     * @param {ForwarderUpdateArgs} args - Arguments to update one Forwarder.
     * @example
     * // Update one Forwarder
     * const forwarder = await prisma.forwarder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForwarderUpdateArgs>(args: SelectSubset<T, ForwarderUpdateArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Forwarders.
     * @param {ForwarderDeleteManyArgs} args - Arguments to filter Forwarders to delete.
     * @example
     * // Delete a few Forwarders
     * const { count } = await prisma.forwarder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForwarderDeleteManyArgs>(args?: SelectSubset<T, ForwarderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forwarders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forwarders
     * const forwarder = await prisma.forwarder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForwarderUpdateManyArgs>(args: SelectSubset<T, ForwarderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Forwarder.
     * @param {ForwarderUpsertArgs} args - Arguments to update or create a Forwarder.
     * @example
     * // Update or create a Forwarder
     * const forwarder = await prisma.forwarder.upsert({
     *   create: {
     *     // ... data to create a Forwarder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Forwarder we want to update
     *   }
     * })
     */
    upsert<T extends ForwarderUpsertArgs>(args: SelectSubset<T, ForwarderUpsertArgs<ExtArgs>>): Prisma__ForwarderClient<$Result.GetResult<Prisma.$ForwarderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Forwarders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderCountArgs} args - Arguments to filter Forwarders to count.
     * @example
     * // Count the number of Forwarders
     * const count = await prisma.forwarder.count({
     *   where: {
     *     // ... the filter for the Forwarders we want to count
     *   }
     * })
    **/
    count<T extends ForwarderCountArgs>(
      args?: Subset<T, ForwarderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForwarderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Forwarder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForwarderAggregateArgs>(args: Subset<T, ForwarderAggregateArgs>): Prisma.PrismaPromise<GetForwarderAggregateType<T>>

    /**
     * Group by Forwarder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForwarderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForwarderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForwarderGroupByArgs['orderBy'] }
        : { orderBy?: ForwarderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForwarderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForwarderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Forwarder model
   */
  readonly fields: ForwarderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Forwarder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForwarderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Forwarder model
   */ 
  interface ForwarderFieldRefs {
    readonly forwarderName: FieldRef<"Forwarder", 'String'>
    readonly shortName: FieldRef<"Forwarder", 'String'>
    readonly contactName: FieldRef<"Forwarder", 'String'>
    readonly contactEmail: FieldRef<"Forwarder", 'String'>
    readonly contactPhone: FieldRef<"Forwarder", 'String'>
    readonly address: FieldRef<"Forwarder", 'String'>
    readonly notes: FieldRef<"Forwarder", 'String'>
    readonly isActive: FieldRef<"Forwarder", 'Boolean'>
    readonly customsBroker: FieldRef<"Forwarder", 'String'>
    readonly aceFilerCode: FieldRef<"Forwarder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Forwarder findUnique
   */
  export type ForwarderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * Filter, which Forwarder to fetch.
     */
    where: ForwarderWhereUniqueInput
  }

  /**
   * Forwarder findUniqueOrThrow
   */
  export type ForwarderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * Filter, which Forwarder to fetch.
     */
    where: ForwarderWhereUniqueInput
  }

  /**
   * Forwarder findFirst
   */
  export type ForwarderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * Filter, which Forwarder to fetch.
     */
    where?: ForwarderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forwarders to fetch.
     */
    orderBy?: ForwarderOrderByWithRelationInput | ForwarderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forwarders.
     */
    cursor?: ForwarderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forwarders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forwarders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forwarders.
     */
    distinct?: ForwarderScalarFieldEnum | ForwarderScalarFieldEnum[]
  }

  /**
   * Forwarder findFirstOrThrow
   */
  export type ForwarderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * Filter, which Forwarder to fetch.
     */
    where?: ForwarderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forwarders to fetch.
     */
    orderBy?: ForwarderOrderByWithRelationInput | ForwarderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forwarders.
     */
    cursor?: ForwarderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forwarders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forwarders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forwarders.
     */
    distinct?: ForwarderScalarFieldEnum | ForwarderScalarFieldEnum[]
  }

  /**
   * Forwarder findMany
   */
  export type ForwarderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * Filter, which Forwarders to fetch.
     */
    where?: ForwarderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forwarders to fetch.
     */
    orderBy?: ForwarderOrderByWithRelationInput | ForwarderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forwarders.
     */
    cursor?: ForwarderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forwarders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forwarders.
     */
    skip?: number
    distinct?: ForwarderScalarFieldEnum | ForwarderScalarFieldEnum[]
  }

  /**
   * Forwarder create
   */
  export type ForwarderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * The data needed to create a Forwarder.
     */
    data: XOR<ForwarderCreateInput, ForwarderUncheckedCreateInput>
  }

  /**
   * Forwarder createMany
   */
  export type ForwarderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forwarders.
     */
    data: ForwarderCreateManyInput | ForwarderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Forwarder createManyAndReturn
   */
  export type ForwarderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Forwarders.
     */
    data: ForwarderCreateManyInput | ForwarderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Forwarder update
   */
  export type ForwarderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * The data needed to update a Forwarder.
     */
    data: XOR<ForwarderUpdateInput, ForwarderUncheckedUpdateInput>
    /**
     * Choose, which Forwarder to update.
     */
    where: ForwarderWhereUniqueInput
  }

  /**
   * Forwarder updateMany
   */
  export type ForwarderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forwarders.
     */
    data: XOR<ForwarderUpdateManyMutationInput, ForwarderUncheckedUpdateManyInput>
    /**
     * Filter which Forwarders to update
     */
    where?: ForwarderWhereInput
  }

  /**
   * Forwarder upsert
   */
  export type ForwarderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * The filter to search for the Forwarder to update in case it exists.
     */
    where: ForwarderWhereUniqueInput
    /**
     * In case the Forwarder found by the `where` argument doesn't exist, create a new Forwarder with this data.
     */
    create: XOR<ForwarderCreateInput, ForwarderUncheckedCreateInput>
    /**
     * In case the Forwarder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForwarderUpdateInput, ForwarderUncheckedUpdateInput>
  }

  /**
   * Forwarder delete
   */
  export type ForwarderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
    /**
     * Filter which Forwarder to delete.
     */
    where: ForwarderWhereUniqueInput
  }

  /**
   * Forwarder deleteMany
   */
  export type ForwarderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forwarders to delete
     */
    where?: ForwarderWhereInput
  }

  /**
   * Forwarder without action
   */
  export type ForwarderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forwarder
     */
    select?: ForwarderSelect<ExtArgs> | null
  }


  /**
   * Model DemurrageRate
   */

  export type AggregateDemurrageRate = {
    _count: DemurrageRateCountAggregateOutputType | null
    _avg: DemurrageRateAvgAggregateOutputType | null
    _sum: DemurrageRateSumAggregateOutputType | null
    _min: DemurrageRateMinAggregateOutputType | null
    _max: DemurrageRateMaxAggregateOutputType | null
  }

  export type DemurrageRateAvgAggregateOutputType = {
    freeDays: number | null
    dailyRate: number | null
  }

  export type DemurrageRateSumAggregateOutputType = {
    freeDays: number | null
    dailyRate: number | null
  }

  export type DemurrageRateMinAggregateOutputType = {
    name: string | null
    carrierId: string | null
    portId: string | null
    containerType: string | null
    freeDays: number | null
    dailyRate: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    notes: string | null
  }

  export type DemurrageRateMaxAggregateOutputType = {
    name: string | null
    carrierId: string | null
    portId: string | null
    containerType: string | null
    freeDays: number | null
    dailyRate: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    notes: string | null
  }

  export type DemurrageRateCountAggregateOutputType = {
    name: number
    carrierId: number
    portId: number
    containerType: number
    freeDays: number
    dailyRate: number
    effectiveFrom: number
    effectiveTo: number
    notes: number
    _all: number
  }


  export type DemurrageRateAvgAggregateInputType = {
    freeDays?: true
    dailyRate?: true
  }

  export type DemurrageRateSumAggregateInputType = {
    freeDays?: true
    dailyRate?: true
  }

  export type DemurrageRateMinAggregateInputType = {
    name?: true
    carrierId?: true
    portId?: true
    containerType?: true
    freeDays?: true
    dailyRate?: true
    effectiveFrom?: true
    effectiveTo?: true
    notes?: true
  }

  export type DemurrageRateMaxAggregateInputType = {
    name?: true
    carrierId?: true
    portId?: true
    containerType?: true
    freeDays?: true
    dailyRate?: true
    effectiveFrom?: true
    effectiveTo?: true
    notes?: true
  }

  export type DemurrageRateCountAggregateInputType = {
    name?: true
    carrierId?: true
    portId?: true
    containerType?: true
    freeDays?: true
    dailyRate?: true
    effectiveFrom?: true
    effectiveTo?: true
    notes?: true
    _all?: true
  }

  export type DemurrageRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DemurrageRate to aggregate.
     */
    where?: DemurrageRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemurrageRates to fetch.
     */
    orderBy?: DemurrageRateOrderByWithRelationInput | DemurrageRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DemurrageRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemurrageRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemurrageRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DemurrageRates
    **/
    _count?: true | DemurrageRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DemurrageRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DemurrageRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DemurrageRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DemurrageRateMaxAggregateInputType
  }

  export type GetDemurrageRateAggregateType<T extends DemurrageRateAggregateArgs> = {
        [P in keyof T & keyof AggregateDemurrageRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemurrageRate[P]>
      : GetScalarType<T[P], AggregateDemurrageRate[P]>
  }




  export type DemurrageRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemurrageRateWhereInput
    orderBy?: DemurrageRateOrderByWithAggregationInput | DemurrageRateOrderByWithAggregationInput[]
    by: DemurrageRateScalarFieldEnum[] | DemurrageRateScalarFieldEnum
    having?: DemurrageRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DemurrageRateCountAggregateInputType | true
    _avg?: DemurrageRateAvgAggregateInputType
    _sum?: DemurrageRateSumAggregateInputType
    _min?: DemurrageRateMinAggregateInputType
    _max?: DemurrageRateMaxAggregateInputType
  }

  export type DemurrageRateGroupByOutputType = {
    name: string
    carrierId: string | null
    portId: string | null
    containerType: string | null
    freeDays: number | null
    dailyRate: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    notes: string | null
    _count: DemurrageRateCountAggregateOutputType | null
    _avg: DemurrageRateAvgAggregateOutputType | null
    _sum: DemurrageRateSumAggregateOutputType | null
    _min: DemurrageRateMinAggregateOutputType | null
    _max: DemurrageRateMaxAggregateOutputType | null
  }

  type GetDemurrageRateGroupByPayload<T extends DemurrageRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DemurrageRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DemurrageRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DemurrageRateGroupByOutputType[P]>
            : GetScalarType<T[P], DemurrageRateGroupByOutputType[P]>
        }
      >
    >


  export type DemurrageRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    carrierId?: boolean
    portId?: boolean
    containerType?: boolean
    freeDays?: boolean
    dailyRate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    notes?: boolean
    port?: boolean | DemurrageRate$portArgs<ExtArgs>
    carrier?: boolean | DemurrageRate$carrierArgs<ExtArgs>
  }, ExtArgs["result"]["demurrageRate"]>

  export type DemurrageRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    carrierId?: boolean
    portId?: boolean
    containerType?: boolean
    freeDays?: boolean
    dailyRate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    notes?: boolean
    port?: boolean | DemurrageRate$portArgs<ExtArgs>
    carrier?: boolean | DemurrageRate$carrierArgs<ExtArgs>
  }, ExtArgs["result"]["demurrageRate"]>

  export type DemurrageRateSelectScalar = {
    name?: boolean
    carrierId?: boolean
    portId?: boolean
    containerType?: boolean
    freeDays?: boolean
    dailyRate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    notes?: boolean
  }

  export type DemurrageRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    port?: boolean | DemurrageRate$portArgs<ExtArgs>
    carrier?: boolean | DemurrageRate$carrierArgs<ExtArgs>
  }
  export type DemurrageRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    port?: boolean | DemurrageRate$portArgs<ExtArgs>
    carrier?: boolean | DemurrageRate$carrierArgs<ExtArgs>
  }

  export type $DemurrageRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DemurrageRate"
    objects: {
      port: Prisma.$PortPayload<ExtArgs> | null
      carrier: Prisma.$CarrierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      carrierId: string | null
      portId: string | null
      containerType: string | null
      freeDays: number | null
      dailyRate: number | null
      effectiveFrom: Date | null
      effectiveTo: Date | null
      notes: string | null
    }, ExtArgs["result"]["demurrageRate"]>
    composites: {}
  }

  type DemurrageRateGetPayload<S extends boolean | null | undefined | DemurrageRateDefaultArgs> = $Result.GetResult<Prisma.$DemurrageRatePayload, S>

  type DemurrageRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DemurrageRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DemurrageRateCountAggregateInputType | true
    }

  export interface DemurrageRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DemurrageRate'], meta: { name: 'DemurrageRate' } }
    /**
     * Find zero or one DemurrageRate that matches the filter.
     * @param {DemurrageRateFindUniqueArgs} args - Arguments to find a DemurrageRate
     * @example
     * // Get one DemurrageRate
     * const demurrageRate = await prisma.demurrageRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DemurrageRateFindUniqueArgs>(args: SelectSubset<T, DemurrageRateFindUniqueArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DemurrageRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DemurrageRateFindUniqueOrThrowArgs} args - Arguments to find a DemurrageRate
     * @example
     * // Get one DemurrageRate
     * const demurrageRate = await prisma.demurrageRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DemurrageRateFindUniqueOrThrowArgs>(args: SelectSubset<T, DemurrageRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DemurrageRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateFindFirstArgs} args - Arguments to find a DemurrageRate
     * @example
     * // Get one DemurrageRate
     * const demurrageRate = await prisma.demurrageRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DemurrageRateFindFirstArgs>(args?: SelectSubset<T, DemurrageRateFindFirstArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DemurrageRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateFindFirstOrThrowArgs} args - Arguments to find a DemurrageRate
     * @example
     * // Get one DemurrageRate
     * const demurrageRate = await prisma.demurrageRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DemurrageRateFindFirstOrThrowArgs>(args?: SelectSubset<T, DemurrageRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DemurrageRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DemurrageRates
     * const demurrageRates = await prisma.demurrageRate.findMany()
     * 
     * // Get first 10 DemurrageRates
     * const demurrageRates = await prisma.demurrageRate.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const demurrageRateWithNameOnly = await prisma.demurrageRate.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends DemurrageRateFindManyArgs>(args?: SelectSubset<T, DemurrageRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DemurrageRate.
     * @param {DemurrageRateCreateArgs} args - Arguments to create a DemurrageRate.
     * @example
     * // Create one DemurrageRate
     * const DemurrageRate = await prisma.demurrageRate.create({
     *   data: {
     *     // ... data to create a DemurrageRate
     *   }
     * })
     * 
     */
    create<T extends DemurrageRateCreateArgs>(args: SelectSubset<T, DemurrageRateCreateArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DemurrageRates.
     * @param {DemurrageRateCreateManyArgs} args - Arguments to create many DemurrageRates.
     * @example
     * // Create many DemurrageRates
     * const demurrageRate = await prisma.demurrageRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DemurrageRateCreateManyArgs>(args?: SelectSubset<T, DemurrageRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DemurrageRates and returns the data saved in the database.
     * @param {DemurrageRateCreateManyAndReturnArgs} args - Arguments to create many DemurrageRates.
     * @example
     * // Create many DemurrageRates
     * const demurrageRate = await prisma.demurrageRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DemurrageRates and only return the `name`
     * const demurrageRateWithNameOnly = await prisma.demurrageRate.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DemurrageRateCreateManyAndReturnArgs>(args?: SelectSubset<T, DemurrageRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DemurrageRate.
     * @param {DemurrageRateDeleteArgs} args - Arguments to delete one DemurrageRate.
     * @example
     * // Delete one DemurrageRate
     * const DemurrageRate = await prisma.demurrageRate.delete({
     *   where: {
     *     // ... filter to delete one DemurrageRate
     *   }
     * })
     * 
     */
    delete<T extends DemurrageRateDeleteArgs>(args: SelectSubset<T, DemurrageRateDeleteArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DemurrageRate.
     * @param {DemurrageRateUpdateArgs} args - Arguments to update one DemurrageRate.
     * @example
     * // Update one DemurrageRate
     * const demurrageRate = await prisma.demurrageRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DemurrageRateUpdateArgs>(args: SelectSubset<T, DemurrageRateUpdateArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DemurrageRates.
     * @param {DemurrageRateDeleteManyArgs} args - Arguments to filter DemurrageRates to delete.
     * @example
     * // Delete a few DemurrageRates
     * const { count } = await prisma.demurrageRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DemurrageRateDeleteManyArgs>(args?: SelectSubset<T, DemurrageRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DemurrageRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DemurrageRates
     * const demurrageRate = await prisma.demurrageRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DemurrageRateUpdateManyArgs>(args: SelectSubset<T, DemurrageRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DemurrageRate.
     * @param {DemurrageRateUpsertArgs} args - Arguments to update or create a DemurrageRate.
     * @example
     * // Update or create a DemurrageRate
     * const demurrageRate = await prisma.demurrageRate.upsert({
     *   create: {
     *     // ... data to create a DemurrageRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DemurrageRate we want to update
     *   }
     * })
     */
    upsert<T extends DemurrageRateUpsertArgs>(args: SelectSubset<T, DemurrageRateUpsertArgs<ExtArgs>>): Prisma__DemurrageRateClient<$Result.GetResult<Prisma.$DemurrageRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DemurrageRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateCountArgs} args - Arguments to filter DemurrageRates to count.
     * @example
     * // Count the number of DemurrageRates
     * const count = await prisma.demurrageRate.count({
     *   where: {
     *     // ... the filter for the DemurrageRates we want to count
     *   }
     * })
    **/
    count<T extends DemurrageRateCountArgs>(
      args?: Subset<T, DemurrageRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemurrageRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DemurrageRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemurrageRateAggregateArgs>(args: Subset<T, DemurrageRateAggregateArgs>): Prisma.PrismaPromise<GetDemurrageRateAggregateType<T>>

    /**
     * Group by DemurrageRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemurrageRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DemurrageRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DemurrageRateGroupByArgs['orderBy'] }
        : { orderBy?: DemurrageRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DemurrageRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemurrageRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DemurrageRate model
   */
  readonly fields: DemurrageRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DemurrageRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DemurrageRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    port<T extends DemurrageRate$portArgs<ExtArgs> = {}>(args?: Subset<T, DemurrageRate$portArgs<ExtArgs>>): Prisma__PortClient<$Result.GetResult<Prisma.$PortPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    carrier<T extends DemurrageRate$carrierArgs<ExtArgs> = {}>(args?: Subset<T, DemurrageRate$carrierArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DemurrageRate model
   */ 
  interface DemurrageRateFieldRefs {
    readonly name: FieldRef<"DemurrageRate", 'String'>
    readonly carrierId: FieldRef<"DemurrageRate", 'String'>
    readonly portId: FieldRef<"DemurrageRate", 'String'>
    readonly containerType: FieldRef<"DemurrageRate", 'String'>
    readonly freeDays: FieldRef<"DemurrageRate", 'Int'>
    readonly dailyRate: FieldRef<"DemurrageRate", 'Float'>
    readonly effectiveFrom: FieldRef<"DemurrageRate", 'DateTime'>
    readonly effectiveTo: FieldRef<"DemurrageRate", 'DateTime'>
    readonly notes: FieldRef<"DemurrageRate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DemurrageRate findUnique
   */
  export type DemurrageRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * Filter, which DemurrageRate to fetch.
     */
    where: DemurrageRateWhereUniqueInput
  }

  /**
   * DemurrageRate findUniqueOrThrow
   */
  export type DemurrageRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * Filter, which DemurrageRate to fetch.
     */
    where: DemurrageRateWhereUniqueInput
  }

  /**
   * DemurrageRate findFirst
   */
  export type DemurrageRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * Filter, which DemurrageRate to fetch.
     */
    where?: DemurrageRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemurrageRates to fetch.
     */
    orderBy?: DemurrageRateOrderByWithRelationInput | DemurrageRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DemurrageRates.
     */
    cursor?: DemurrageRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemurrageRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemurrageRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DemurrageRates.
     */
    distinct?: DemurrageRateScalarFieldEnum | DemurrageRateScalarFieldEnum[]
  }

  /**
   * DemurrageRate findFirstOrThrow
   */
  export type DemurrageRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * Filter, which DemurrageRate to fetch.
     */
    where?: DemurrageRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemurrageRates to fetch.
     */
    orderBy?: DemurrageRateOrderByWithRelationInput | DemurrageRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DemurrageRates.
     */
    cursor?: DemurrageRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemurrageRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemurrageRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DemurrageRates.
     */
    distinct?: DemurrageRateScalarFieldEnum | DemurrageRateScalarFieldEnum[]
  }

  /**
   * DemurrageRate findMany
   */
  export type DemurrageRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * Filter, which DemurrageRates to fetch.
     */
    where?: DemurrageRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemurrageRates to fetch.
     */
    orderBy?: DemurrageRateOrderByWithRelationInput | DemurrageRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DemurrageRates.
     */
    cursor?: DemurrageRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemurrageRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemurrageRates.
     */
    skip?: number
    distinct?: DemurrageRateScalarFieldEnum | DemurrageRateScalarFieldEnum[]
  }

  /**
   * DemurrageRate create
   */
  export type DemurrageRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * The data needed to create a DemurrageRate.
     */
    data: XOR<DemurrageRateCreateInput, DemurrageRateUncheckedCreateInput>
  }

  /**
   * DemurrageRate createMany
   */
  export type DemurrageRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DemurrageRates.
     */
    data: DemurrageRateCreateManyInput | DemurrageRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DemurrageRate createManyAndReturn
   */
  export type DemurrageRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DemurrageRates.
     */
    data: DemurrageRateCreateManyInput | DemurrageRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DemurrageRate update
   */
  export type DemurrageRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * The data needed to update a DemurrageRate.
     */
    data: XOR<DemurrageRateUpdateInput, DemurrageRateUncheckedUpdateInput>
    /**
     * Choose, which DemurrageRate to update.
     */
    where: DemurrageRateWhereUniqueInput
  }

  /**
   * DemurrageRate updateMany
   */
  export type DemurrageRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DemurrageRates.
     */
    data: XOR<DemurrageRateUpdateManyMutationInput, DemurrageRateUncheckedUpdateManyInput>
    /**
     * Filter which DemurrageRates to update
     */
    where?: DemurrageRateWhereInput
  }

  /**
   * DemurrageRate upsert
   */
  export type DemurrageRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * The filter to search for the DemurrageRate to update in case it exists.
     */
    where: DemurrageRateWhereUniqueInput
    /**
     * In case the DemurrageRate found by the `where` argument doesn't exist, create a new DemurrageRate with this data.
     */
    create: XOR<DemurrageRateCreateInput, DemurrageRateUncheckedCreateInput>
    /**
     * In case the DemurrageRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DemurrageRateUpdateInput, DemurrageRateUncheckedUpdateInput>
  }

  /**
   * DemurrageRate delete
   */
  export type DemurrageRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
    /**
     * Filter which DemurrageRate to delete.
     */
    where: DemurrageRateWhereUniqueInput
  }

  /**
   * DemurrageRate deleteMany
   */
  export type DemurrageRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DemurrageRates to delete
     */
    where?: DemurrageRateWhereInput
  }

  /**
   * DemurrageRate.port
   */
  export type DemurrageRate$portArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Port
     */
    select?: PortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortInclude<ExtArgs> | null
    where?: PortWhereInput
  }

  /**
   * DemurrageRate.carrier
   */
  export type DemurrageRate$carrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    where?: CarrierWhereInput
  }

  /**
   * DemurrageRate without action
   */
  export type DemurrageRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemurrageRate
     */
    select?: DemurrageRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemurrageRateInclude<ExtArgs> | null
  }


  /**
   * Model CarrierFormat
   */

  export type AggregateCarrierFormat = {
    _count: CarrierFormatCountAggregateOutputType | null
    _min: CarrierFormatMinAggregateOutputType | null
    _max: CarrierFormatMaxAggregateOutputType | null
  }

  export type CarrierFormatMinAggregateOutputType = {
    formatName: string | null
    carrierId: string | null
    formatType: string | null
    columnMapping: string | null
    sampleHeaders: string | null
    isActive: boolean | null
    notes: string | null
  }

  export type CarrierFormatMaxAggregateOutputType = {
    formatName: string | null
    carrierId: string | null
    formatType: string | null
    columnMapping: string | null
    sampleHeaders: string | null
    isActive: boolean | null
    notes: string | null
  }

  export type CarrierFormatCountAggregateOutputType = {
    formatName: number
    carrierId: number
    formatType: number
    columnMapping: number
    sampleHeaders: number
    isActive: number
    notes: number
    _all: number
  }


  export type CarrierFormatMinAggregateInputType = {
    formatName?: true
    carrierId?: true
    formatType?: true
    columnMapping?: true
    sampleHeaders?: true
    isActive?: true
    notes?: true
  }

  export type CarrierFormatMaxAggregateInputType = {
    formatName?: true
    carrierId?: true
    formatType?: true
    columnMapping?: true
    sampleHeaders?: true
    isActive?: true
    notes?: true
  }

  export type CarrierFormatCountAggregateInputType = {
    formatName?: true
    carrierId?: true
    formatType?: true
    columnMapping?: true
    sampleHeaders?: true
    isActive?: true
    notes?: true
    _all?: true
  }

  export type CarrierFormatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarrierFormat to aggregate.
     */
    where?: CarrierFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrierFormats to fetch.
     */
    orderBy?: CarrierFormatOrderByWithRelationInput | CarrierFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarrierFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrierFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrierFormats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarrierFormats
    **/
    _count?: true | CarrierFormatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarrierFormatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarrierFormatMaxAggregateInputType
  }

  export type GetCarrierFormatAggregateType<T extends CarrierFormatAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrierFormat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrierFormat[P]>
      : GetScalarType<T[P], AggregateCarrierFormat[P]>
  }




  export type CarrierFormatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarrierFormatWhereInput
    orderBy?: CarrierFormatOrderByWithAggregationInput | CarrierFormatOrderByWithAggregationInput[]
    by: CarrierFormatScalarFieldEnum[] | CarrierFormatScalarFieldEnum
    having?: CarrierFormatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarrierFormatCountAggregateInputType | true
    _min?: CarrierFormatMinAggregateInputType
    _max?: CarrierFormatMaxAggregateInputType
  }

  export type CarrierFormatGroupByOutputType = {
    formatName: string
    carrierId: string | null
    formatType: string | null
    columnMapping: string | null
    sampleHeaders: string | null
    isActive: boolean
    notes: string | null
    _count: CarrierFormatCountAggregateOutputType | null
    _min: CarrierFormatMinAggregateOutputType | null
    _max: CarrierFormatMaxAggregateOutputType | null
  }

  type GetCarrierFormatGroupByPayload<T extends CarrierFormatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarrierFormatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarrierFormatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarrierFormatGroupByOutputType[P]>
            : GetScalarType<T[P], CarrierFormatGroupByOutputType[P]>
        }
      >
    >


  export type CarrierFormatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formatName?: boolean
    carrierId?: boolean
    formatType?: boolean
    columnMapping?: boolean
    sampleHeaders?: boolean
    isActive?: boolean
    notes?: boolean
    carrier?: boolean | CarrierFormat$carrierArgs<ExtArgs>
    importLogs?: boolean | CarrierFormat$importLogsArgs<ExtArgs>
    _count?: boolean | CarrierFormatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrierFormat"]>

  export type CarrierFormatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formatName?: boolean
    carrierId?: boolean
    formatType?: boolean
    columnMapping?: boolean
    sampleHeaders?: boolean
    isActive?: boolean
    notes?: boolean
    carrier?: boolean | CarrierFormat$carrierArgs<ExtArgs>
  }, ExtArgs["result"]["carrierFormat"]>

  export type CarrierFormatSelectScalar = {
    formatName?: boolean
    carrierId?: boolean
    formatType?: boolean
    columnMapping?: boolean
    sampleHeaders?: boolean
    isActive?: boolean
    notes?: boolean
  }

  export type CarrierFormatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrier?: boolean | CarrierFormat$carrierArgs<ExtArgs>
    importLogs?: boolean | CarrierFormat$importLogsArgs<ExtArgs>
    _count?: boolean | CarrierFormatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarrierFormatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrier?: boolean | CarrierFormat$carrierArgs<ExtArgs>
  }

  export type $CarrierFormatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CarrierFormat"
    objects: {
      carrier: Prisma.$CarrierPayload<ExtArgs> | null
      importLogs: Prisma.$ImportLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      formatName: string
      carrierId: string | null
      formatType: string | null
      columnMapping: string | null
      sampleHeaders: string | null
      isActive: boolean
      notes: string | null
    }, ExtArgs["result"]["carrierFormat"]>
    composites: {}
  }

  type CarrierFormatGetPayload<S extends boolean | null | undefined | CarrierFormatDefaultArgs> = $Result.GetResult<Prisma.$CarrierFormatPayload, S>

  type CarrierFormatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarrierFormatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarrierFormatCountAggregateInputType | true
    }

  export interface CarrierFormatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CarrierFormat'], meta: { name: 'CarrierFormat' } }
    /**
     * Find zero or one CarrierFormat that matches the filter.
     * @param {CarrierFormatFindUniqueArgs} args - Arguments to find a CarrierFormat
     * @example
     * // Get one CarrierFormat
     * const carrierFormat = await prisma.carrierFormat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarrierFormatFindUniqueArgs>(args: SelectSubset<T, CarrierFormatFindUniqueArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CarrierFormat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CarrierFormatFindUniqueOrThrowArgs} args - Arguments to find a CarrierFormat
     * @example
     * // Get one CarrierFormat
     * const carrierFormat = await prisma.carrierFormat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarrierFormatFindUniqueOrThrowArgs>(args: SelectSubset<T, CarrierFormatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CarrierFormat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatFindFirstArgs} args - Arguments to find a CarrierFormat
     * @example
     * // Get one CarrierFormat
     * const carrierFormat = await prisma.carrierFormat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarrierFormatFindFirstArgs>(args?: SelectSubset<T, CarrierFormatFindFirstArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CarrierFormat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatFindFirstOrThrowArgs} args - Arguments to find a CarrierFormat
     * @example
     * // Get one CarrierFormat
     * const carrierFormat = await prisma.carrierFormat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarrierFormatFindFirstOrThrowArgs>(args?: SelectSubset<T, CarrierFormatFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CarrierFormats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarrierFormats
     * const carrierFormats = await prisma.carrierFormat.findMany()
     * 
     * // Get first 10 CarrierFormats
     * const carrierFormats = await prisma.carrierFormat.findMany({ take: 10 })
     * 
     * // Only select the `formatName`
     * const carrierFormatWithFormatNameOnly = await prisma.carrierFormat.findMany({ select: { formatName: true } })
     * 
     */
    findMany<T extends CarrierFormatFindManyArgs>(args?: SelectSubset<T, CarrierFormatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CarrierFormat.
     * @param {CarrierFormatCreateArgs} args - Arguments to create a CarrierFormat.
     * @example
     * // Create one CarrierFormat
     * const CarrierFormat = await prisma.carrierFormat.create({
     *   data: {
     *     // ... data to create a CarrierFormat
     *   }
     * })
     * 
     */
    create<T extends CarrierFormatCreateArgs>(args: SelectSubset<T, CarrierFormatCreateArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CarrierFormats.
     * @param {CarrierFormatCreateManyArgs} args - Arguments to create many CarrierFormats.
     * @example
     * // Create many CarrierFormats
     * const carrierFormat = await prisma.carrierFormat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarrierFormatCreateManyArgs>(args?: SelectSubset<T, CarrierFormatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CarrierFormats and returns the data saved in the database.
     * @param {CarrierFormatCreateManyAndReturnArgs} args - Arguments to create many CarrierFormats.
     * @example
     * // Create many CarrierFormats
     * const carrierFormat = await prisma.carrierFormat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CarrierFormats and only return the `formatName`
     * const carrierFormatWithFormatNameOnly = await prisma.carrierFormat.createManyAndReturn({ 
     *   select: { formatName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarrierFormatCreateManyAndReturnArgs>(args?: SelectSubset<T, CarrierFormatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CarrierFormat.
     * @param {CarrierFormatDeleteArgs} args - Arguments to delete one CarrierFormat.
     * @example
     * // Delete one CarrierFormat
     * const CarrierFormat = await prisma.carrierFormat.delete({
     *   where: {
     *     // ... filter to delete one CarrierFormat
     *   }
     * })
     * 
     */
    delete<T extends CarrierFormatDeleteArgs>(args: SelectSubset<T, CarrierFormatDeleteArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CarrierFormat.
     * @param {CarrierFormatUpdateArgs} args - Arguments to update one CarrierFormat.
     * @example
     * // Update one CarrierFormat
     * const carrierFormat = await prisma.carrierFormat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarrierFormatUpdateArgs>(args: SelectSubset<T, CarrierFormatUpdateArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CarrierFormats.
     * @param {CarrierFormatDeleteManyArgs} args - Arguments to filter CarrierFormats to delete.
     * @example
     * // Delete a few CarrierFormats
     * const { count } = await prisma.carrierFormat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarrierFormatDeleteManyArgs>(args?: SelectSubset<T, CarrierFormatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarrierFormats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarrierFormats
     * const carrierFormat = await prisma.carrierFormat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarrierFormatUpdateManyArgs>(args: SelectSubset<T, CarrierFormatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CarrierFormat.
     * @param {CarrierFormatUpsertArgs} args - Arguments to update or create a CarrierFormat.
     * @example
     * // Update or create a CarrierFormat
     * const carrierFormat = await prisma.carrierFormat.upsert({
     *   create: {
     *     // ... data to create a CarrierFormat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarrierFormat we want to update
     *   }
     * })
     */
    upsert<T extends CarrierFormatUpsertArgs>(args: SelectSubset<T, CarrierFormatUpsertArgs<ExtArgs>>): Prisma__CarrierFormatClient<$Result.GetResult<Prisma.$CarrierFormatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CarrierFormats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatCountArgs} args - Arguments to filter CarrierFormats to count.
     * @example
     * // Count the number of CarrierFormats
     * const count = await prisma.carrierFormat.count({
     *   where: {
     *     // ... the filter for the CarrierFormats we want to count
     *   }
     * })
    **/
    count<T extends CarrierFormatCountArgs>(
      args?: Subset<T, CarrierFormatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarrierFormatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarrierFormat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarrierFormatAggregateArgs>(args: Subset<T, CarrierFormatAggregateArgs>): Prisma.PrismaPromise<GetCarrierFormatAggregateType<T>>

    /**
     * Group by CarrierFormat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrierFormatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarrierFormatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarrierFormatGroupByArgs['orderBy'] }
        : { orderBy?: CarrierFormatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarrierFormatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarrierFormatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CarrierFormat model
   */
  readonly fields: CarrierFormatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarrierFormat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarrierFormatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carrier<T extends CarrierFormat$carrierArgs<ExtArgs> = {}>(args?: Subset<T, CarrierFormat$carrierArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    importLogs<T extends CarrierFormat$importLogsArgs<ExtArgs> = {}>(args?: Subset<T, CarrierFormat$importLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CarrierFormat model
   */ 
  interface CarrierFormatFieldRefs {
    readonly formatName: FieldRef<"CarrierFormat", 'String'>
    readonly carrierId: FieldRef<"CarrierFormat", 'String'>
    readonly formatType: FieldRef<"CarrierFormat", 'String'>
    readonly columnMapping: FieldRef<"CarrierFormat", 'String'>
    readonly sampleHeaders: FieldRef<"CarrierFormat", 'String'>
    readonly isActive: FieldRef<"CarrierFormat", 'Boolean'>
    readonly notes: FieldRef<"CarrierFormat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CarrierFormat findUnique
   */
  export type CarrierFormatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * Filter, which CarrierFormat to fetch.
     */
    where: CarrierFormatWhereUniqueInput
  }

  /**
   * CarrierFormat findUniqueOrThrow
   */
  export type CarrierFormatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * Filter, which CarrierFormat to fetch.
     */
    where: CarrierFormatWhereUniqueInput
  }

  /**
   * CarrierFormat findFirst
   */
  export type CarrierFormatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * Filter, which CarrierFormat to fetch.
     */
    where?: CarrierFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrierFormats to fetch.
     */
    orderBy?: CarrierFormatOrderByWithRelationInput | CarrierFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarrierFormats.
     */
    cursor?: CarrierFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrierFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrierFormats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarrierFormats.
     */
    distinct?: CarrierFormatScalarFieldEnum | CarrierFormatScalarFieldEnum[]
  }

  /**
   * CarrierFormat findFirstOrThrow
   */
  export type CarrierFormatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * Filter, which CarrierFormat to fetch.
     */
    where?: CarrierFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrierFormats to fetch.
     */
    orderBy?: CarrierFormatOrderByWithRelationInput | CarrierFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarrierFormats.
     */
    cursor?: CarrierFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrierFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrierFormats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarrierFormats.
     */
    distinct?: CarrierFormatScalarFieldEnum | CarrierFormatScalarFieldEnum[]
  }

  /**
   * CarrierFormat findMany
   */
  export type CarrierFormatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * Filter, which CarrierFormats to fetch.
     */
    where?: CarrierFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrierFormats to fetch.
     */
    orderBy?: CarrierFormatOrderByWithRelationInput | CarrierFormatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarrierFormats.
     */
    cursor?: CarrierFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrierFormats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrierFormats.
     */
    skip?: number
    distinct?: CarrierFormatScalarFieldEnum | CarrierFormatScalarFieldEnum[]
  }

  /**
   * CarrierFormat create
   */
  export type CarrierFormatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * The data needed to create a CarrierFormat.
     */
    data: XOR<CarrierFormatCreateInput, CarrierFormatUncheckedCreateInput>
  }

  /**
   * CarrierFormat createMany
   */
  export type CarrierFormatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CarrierFormats.
     */
    data: CarrierFormatCreateManyInput | CarrierFormatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CarrierFormat createManyAndReturn
   */
  export type CarrierFormatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CarrierFormats.
     */
    data: CarrierFormatCreateManyInput | CarrierFormatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarrierFormat update
   */
  export type CarrierFormatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * The data needed to update a CarrierFormat.
     */
    data: XOR<CarrierFormatUpdateInput, CarrierFormatUncheckedUpdateInput>
    /**
     * Choose, which CarrierFormat to update.
     */
    where: CarrierFormatWhereUniqueInput
  }

  /**
   * CarrierFormat updateMany
   */
  export type CarrierFormatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CarrierFormats.
     */
    data: XOR<CarrierFormatUpdateManyMutationInput, CarrierFormatUncheckedUpdateManyInput>
    /**
     * Filter which CarrierFormats to update
     */
    where?: CarrierFormatWhereInput
  }

  /**
   * CarrierFormat upsert
   */
  export type CarrierFormatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * The filter to search for the CarrierFormat to update in case it exists.
     */
    where: CarrierFormatWhereUniqueInput
    /**
     * In case the CarrierFormat found by the `where` argument doesn't exist, create a new CarrierFormat with this data.
     */
    create: XOR<CarrierFormatCreateInput, CarrierFormatUncheckedCreateInput>
    /**
     * In case the CarrierFormat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarrierFormatUpdateInput, CarrierFormatUncheckedUpdateInput>
  }

  /**
   * CarrierFormat delete
   */
  export type CarrierFormatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
    /**
     * Filter which CarrierFormat to delete.
     */
    where: CarrierFormatWhereUniqueInput
  }

  /**
   * CarrierFormat deleteMany
   */
  export type CarrierFormatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarrierFormats to delete
     */
    where?: CarrierFormatWhereInput
  }

  /**
   * CarrierFormat.carrier
   */
  export type CarrierFormat$carrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    where?: CarrierWhereInput
  }

  /**
   * CarrierFormat.importLogs
   */
  export type CarrierFormat$importLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    where?: ImportLogWhereInput
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    cursor?: ImportLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * CarrierFormat without action
   */
  export type CarrierFormatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrierFormat
     */
    select?: CarrierFormatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierFormatInclude<ExtArgs> | null
  }


  /**
   * Model DCSAEventMap
   */

  export type AggregateDCSAEventMap = {
    _count: DCSAEventMapCountAggregateOutputType | null
    _min: DCSAEventMapMinAggregateOutputType | null
    _max: DCSAEventMapMaxAggregateOutputType | null
  }

  export type DCSAEventMapMinAggregateOutputType = {
    name: string | null
    carrierId: string | null
    sourceEventCode: string | null
    sourceEventName: string | null
    dcsaEventType: string | null
    transitStageName: string | null
    eventCategory: string | null
    notes: string | null
    isActive: boolean | null
  }

  export type DCSAEventMapMaxAggregateOutputType = {
    name: string | null
    carrierId: string | null
    sourceEventCode: string | null
    sourceEventName: string | null
    dcsaEventType: string | null
    transitStageName: string | null
    eventCategory: string | null
    notes: string | null
    isActive: boolean | null
  }

  export type DCSAEventMapCountAggregateOutputType = {
    name: number
    carrierId: number
    sourceEventCode: number
    sourceEventName: number
    dcsaEventType: number
    transitStageName: number
    eventCategory: number
    notes: number
    isActive: number
    _all: number
  }


  export type DCSAEventMapMinAggregateInputType = {
    name?: true
    carrierId?: true
    sourceEventCode?: true
    sourceEventName?: true
    dcsaEventType?: true
    transitStageName?: true
    eventCategory?: true
    notes?: true
    isActive?: true
  }

  export type DCSAEventMapMaxAggregateInputType = {
    name?: true
    carrierId?: true
    sourceEventCode?: true
    sourceEventName?: true
    dcsaEventType?: true
    transitStageName?: true
    eventCategory?: true
    notes?: true
    isActive?: true
  }

  export type DCSAEventMapCountAggregateInputType = {
    name?: true
    carrierId?: true
    sourceEventCode?: true
    sourceEventName?: true
    dcsaEventType?: true
    transitStageName?: true
    eventCategory?: true
    notes?: true
    isActive?: true
    _all?: true
  }

  export type DCSAEventMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DCSAEventMap to aggregate.
     */
    where?: DCSAEventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DCSAEventMaps to fetch.
     */
    orderBy?: DCSAEventMapOrderByWithRelationInput | DCSAEventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DCSAEventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DCSAEventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DCSAEventMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DCSAEventMaps
    **/
    _count?: true | DCSAEventMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DCSAEventMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DCSAEventMapMaxAggregateInputType
  }

  export type GetDCSAEventMapAggregateType<T extends DCSAEventMapAggregateArgs> = {
        [P in keyof T & keyof AggregateDCSAEventMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDCSAEventMap[P]>
      : GetScalarType<T[P], AggregateDCSAEventMap[P]>
  }




  export type DCSAEventMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DCSAEventMapWhereInput
    orderBy?: DCSAEventMapOrderByWithAggregationInput | DCSAEventMapOrderByWithAggregationInput[]
    by: DCSAEventMapScalarFieldEnum[] | DCSAEventMapScalarFieldEnum
    having?: DCSAEventMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DCSAEventMapCountAggregateInputType | true
    _min?: DCSAEventMapMinAggregateInputType
    _max?: DCSAEventMapMaxAggregateInputType
  }

  export type DCSAEventMapGroupByOutputType = {
    name: string
    carrierId: string | null
    sourceEventCode: string | null
    sourceEventName: string | null
    dcsaEventType: string | null
    transitStageName: string | null
    eventCategory: string | null
    notes: string | null
    isActive: boolean
    _count: DCSAEventMapCountAggregateOutputType | null
    _min: DCSAEventMapMinAggregateOutputType | null
    _max: DCSAEventMapMaxAggregateOutputType | null
  }

  type GetDCSAEventMapGroupByPayload<T extends DCSAEventMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DCSAEventMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DCSAEventMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DCSAEventMapGroupByOutputType[P]>
            : GetScalarType<T[P], DCSAEventMapGroupByOutputType[P]>
        }
      >
    >


  export type DCSAEventMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    carrierId?: boolean
    sourceEventCode?: boolean
    sourceEventName?: boolean
    dcsaEventType?: boolean
    transitStageName?: boolean
    eventCategory?: boolean
    notes?: boolean
    isActive?: boolean
    transitStage?: boolean | DCSAEventMap$transitStageArgs<ExtArgs>
    carrier?: boolean | DCSAEventMap$carrierArgs<ExtArgs>
  }, ExtArgs["result"]["dCSAEventMap"]>

  export type DCSAEventMapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    carrierId?: boolean
    sourceEventCode?: boolean
    sourceEventName?: boolean
    dcsaEventType?: boolean
    transitStageName?: boolean
    eventCategory?: boolean
    notes?: boolean
    isActive?: boolean
    transitStage?: boolean | DCSAEventMap$transitStageArgs<ExtArgs>
    carrier?: boolean | DCSAEventMap$carrierArgs<ExtArgs>
  }, ExtArgs["result"]["dCSAEventMap"]>

  export type DCSAEventMapSelectScalar = {
    name?: boolean
    carrierId?: boolean
    sourceEventCode?: boolean
    sourceEventName?: boolean
    dcsaEventType?: boolean
    transitStageName?: boolean
    eventCategory?: boolean
    notes?: boolean
    isActive?: boolean
  }

  export type DCSAEventMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transitStage?: boolean | DCSAEventMap$transitStageArgs<ExtArgs>
    carrier?: boolean | DCSAEventMap$carrierArgs<ExtArgs>
  }
  export type DCSAEventMapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transitStage?: boolean | DCSAEventMap$transitStageArgs<ExtArgs>
    carrier?: boolean | DCSAEventMap$carrierArgs<ExtArgs>
  }

  export type $DCSAEventMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DCSAEventMap"
    objects: {
      transitStage: Prisma.$TransitStagePayload<ExtArgs> | null
      carrier: Prisma.$CarrierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      carrierId: string | null
      sourceEventCode: string | null
      sourceEventName: string | null
      dcsaEventType: string | null
      transitStageName: string | null
      eventCategory: string | null
      notes: string | null
      isActive: boolean
    }, ExtArgs["result"]["dCSAEventMap"]>
    composites: {}
  }

  type DCSAEventMapGetPayload<S extends boolean | null | undefined | DCSAEventMapDefaultArgs> = $Result.GetResult<Prisma.$DCSAEventMapPayload, S>

  type DCSAEventMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DCSAEventMapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DCSAEventMapCountAggregateInputType | true
    }

  export interface DCSAEventMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DCSAEventMap'], meta: { name: 'DCSAEventMap' } }
    /**
     * Find zero or one DCSAEventMap that matches the filter.
     * @param {DCSAEventMapFindUniqueArgs} args - Arguments to find a DCSAEventMap
     * @example
     * // Get one DCSAEventMap
     * const dCSAEventMap = await prisma.dCSAEventMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DCSAEventMapFindUniqueArgs>(args: SelectSubset<T, DCSAEventMapFindUniqueArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DCSAEventMap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DCSAEventMapFindUniqueOrThrowArgs} args - Arguments to find a DCSAEventMap
     * @example
     * // Get one DCSAEventMap
     * const dCSAEventMap = await prisma.dCSAEventMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DCSAEventMapFindUniqueOrThrowArgs>(args: SelectSubset<T, DCSAEventMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DCSAEventMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapFindFirstArgs} args - Arguments to find a DCSAEventMap
     * @example
     * // Get one DCSAEventMap
     * const dCSAEventMap = await prisma.dCSAEventMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DCSAEventMapFindFirstArgs>(args?: SelectSubset<T, DCSAEventMapFindFirstArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DCSAEventMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapFindFirstOrThrowArgs} args - Arguments to find a DCSAEventMap
     * @example
     * // Get one DCSAEventMap
     * const dCSAEventMap = await prisma.dCSAEventMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DCSAEventMapFindFirstOrThrowArgs>(args?: SelectSubset<T, DCSAEventMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DCSAEventMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DCSAEventMaps
     * const dCSAEventMaps = await prisma.dCSAEventMap.findMany()
     * 
     * // Get first 10 DCSAEventMaps
     * const dCSAEventMaps = await prisma.dCSAEventMap.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const dCSAEventMapWithNameOnly = await prisma.dCSAEventMap.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends DCSAEventMapFindManyArgs>(args?: SelectSubset<T, DCSAEventMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DCSAEventMap.
     * @param {DCSAEventMapCreateArgs} args - Arguments to create a DCSAEventMap.
     * @example
     * // Create one DCSAEventMap
     * const DCSAEventMap = await prisma.dCSAEventMap.create({
     *   data: {
     *     // ... data to create a DCSAEventMap
     *   }
     * })
     * 
     */
    create<T extends DCSAEventMapCreateArgs>(args: SelectSubset<T, DCSAEventMapCreateArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DCSAEventMaps.
     * @param {DCSAEventMapCreateManyArgs} args - Arguments to create many DCSAEventMaps.
     * @example
     * // Create many DCSAEventMaps
     * const dCSAEventMap = await prisma.dCSAEventMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DCSAEventMapCreateManyArgs>(args?: SelectSubset<T, DCSAEventMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DCSAEventMaps and returns the data saved in the database.
     * @param {DCSAEventMapCreateManyAndReturnArgs} args - Arguments to create many DCSAEventMaps.
     * @example
     * // Create many DCSAEventMaps
     * const dCSAEventMap = await prisma.dCSAEventMap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DCSAEventMaps and only return the `name`
     * const dCSAEventMapWithNameOnly = await prisma.dCSAEventMap.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DCSAEventMapCreateManyAndReturnArgs>(args?: SelectSubset<T, DCSAEventMapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DCSAEventMap.
     * @param {DCSAEventMapDeleteArgs} args - Arguments to delete one DCSAEventMap.
     * @example
     * // Delete one DCSAEventMap
     * const DCSAEventMap = await prisma.dCSAEventMap.delete({
     *   where: {
     *     // ... filter to delete one DCSAEventMap
     *   }
     * })
     * 
     */
    delete<T extends DCSAEventMapDeleteArgs>(args: SelectSubset<T, DCSAEventMapDeleteArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DCSAEventMap.
     * @param {DCSAEventMapUpdateArgs} args - Arguments to update one DCSAEventMap.
     * @example
     * // Update one DCSAEventMap
     * const dCSAEventMap = await prisma.dCSAEventMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DCSAEventMapUpdateArgs>(args: SelectSubset<T, DCSAEventMapUpdateArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DCSAEventMaps.
     * @param {DCSAEventMapDeleteManyArgs} args - Arguments to filter DCSAEventMaps to delete.
     * @example
     * // Delete a few DCSAEventMaps
     * const { count } = await prisma.dCSAEventMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DCSAEventMapDeleteManyArgs>(args?: SelectSubset<T, DCSAEventMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DCSAEventMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DCSAEventMaps
     * const dCSAEventMap = await prisma.dCSAEventMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DCSAEventMapUpdateManyArgs>(args: SelectSubset<T, DCSAEventMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DCSAEventMap.
     * @param {DCSAEventMapUpsertArgs} args - Arguments to update or create a DCSAEventMap.
     * @example
     * // Update or create a DCSAEventMap
     * const dCSAEventMap = await prisma.dCSAEventMap.upsert({
     *   create: {
     *     // ... data to create a DCSAEventMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DCSAEventMap we want to update
     *   }
     * })
     */
    upsert<T extends DCSAEventMapUpsertArgs>(args: SelectSubset<T, DCSAEventMapUpsertArgs<ExtArgs>>): Prisma__DCSAEventMapClient<$Result.GetResult<Prisma.$DCSAEventMapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DCSAEventMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapCountArgs} args - Arguments to filter DCSAEventMaps to count.
     * @example
     * // Count the number of DCSAEventMaps
     * const count = await prisma.dCSAEventMap.count({
     *   where: {
     *     // ... the filter for the DCSAEventMaps we want to count
     *   }
     * })
    **/
    count<T extends DCSAEventMapCountArgs>(
      args?: Subset<T, DCSAEventMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DCSAEventMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DCSAEventMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DCSAEventMapAggregateArgs>(args: Subset<T, DCSAEventMapAggregateArgs>): Prisma.PrismaPromise<GetDCSAEventMapAggregateType<T>>

    /**
     * Group by DCSAEventMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCSAEventMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DCSAEventMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DCSAEventMapGroupByArgs['orderBy'] }
        : { orderBy?: DCSAEventMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DCSAEventMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDCSAEventMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DCSAEventMap model
   */
  readonly fields: DCSAEventMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DCSAEventMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DCSAEventMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transitStage<T extends DCSAEventMap$transitStageArgs<ExtArgs> = {}>(args?: Subset<T, DCSAEventMap$transitStageArgs<ExtArgs>>): Prisma__TransitStageClient<$Result.GetResult<Prisma.$TransitStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    carrier<T extends DCSAEventMap$carrierArgs<ExtArgs> = {}>(args?: Subset<T, DCSAEventMap$carrierArgs<ExtArgs>>): Prisma__CarrierClient<$Result.GetResult<Prisma.$CarrierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DCSAEventMap model
   */ 
  interface DCSAEventMapFieldRefs {
    readonly name: FieldRef<"DCSAEventMap", 'String'>
    readonly carrierId: FieldRef<"DCSAEventMap", 'String'>
    readonly sourceEventCode: FieldRef<"DCSAEventMap", 'String'>
    readonly sourceEventName: FieldRef<"DCSAEventMap", 'String'>
    readonly dcsaEventType: FieldRef<"DCSAEventMap", 'String'>
    readonly transitStageName: FieldRef<"DCSAEventMap", 'String'>
    readonly eventCategory: FieldRef<"DCSAEventMap", 'String'>
    readonly notes: FieldRef<"DCSAEventMap", 'String'>
    readonly isActive: FieldRef<"DCSAEventMap", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DCSAEventMap findUnique
   */
  export type DCSAEventMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * Filter, which DCSAEventMap to fetch.
     */
    where: DCSAEventMapWhereUniqueInput
  }

  /**
   * DCSAEventMap findUniqueOrThrow
   */
  export type DCSAEventMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * Filter, which DCSAEventMap to fetch.
     */
    where: DCSAEventMapWhereUniqueInput
  }

  /**
   * DCSAEventMap findFirst
   */
  export type DCSAEventMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * Filter, which DCSAEventMap to fetch.
     */
    where?: DCSAEventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DCSAEventMaps to fetch.
     */
    orderBy?: DCSAEventMapOrderByWithRelationInput | DCSAEventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DCSAEventMaps.
     */
    cursor?: DCSAEventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DCSAEventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DCSAEventMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DCSAEventMaps.
     */
    distinct?: DCSAEventMapScalarFieldEnum | DCSAEventMapScalarFieldEnum[]
  }

  /**
   * DCSAEventMap findFirstOrThrow
   */
  export type DCSAEventMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * Filter, which DCSAEventMap to fetch.
     */
    where?: DCSAEventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DCSAEventMaps to fetch.
     */
    orderBy?: DCSAEventMapOrderByWithRelationInput | DCSAEventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DCSAEventMaps.
     */
    cursor?: DCSAEventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DCSAEventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DCSAEventMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DCSAEventMaps.
     */
    distinct?: DCSAEventMapScalarFieldEnum | DCSAEventMapScalarFieldEnum[]
  }

  /**
   * DCSAEventMap findMany
   */
  export type DCSAEventMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * Filter, which DCSAEventMaps to fetch.
     */
    where?: DCSAEventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DCSAEventMaps to fetch.
     */
    orderBy?: DCSAEventMapOrderByWithRelationInput | DCSAEventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DCSAEventMaps.
     */
    cursor?: DCSAEventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DCSAEventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DCSAEventMaps.
     */
    skip?: number
    distinct?: DCSAEventMapScalarFieldEnum | DCSAEventMapScalarFieldEnum[]
  }

  /**
   * DCSAEventMap create
   */
  export type DCSAEventMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * The data needed to create a DCSAEventMap.
     */
    data: XOR<DCSAEventMapCreateInput, DCSAEventMapUncheckedCreateInput>
  }

  /**
   * DCSAEventMap createMany
   */
  export type DCSAEventMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DCSAEventMaps.
     */
    data: DCSAEventMapCreateManyInput | DCSAEventMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DCSAEventMap createManyAndReturn
   */
  export type DCSAEventMapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DCSAEventMaps.
     */
    data: DCSAEventMapCreateManyInput | DCSAEventMapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DCSAEventMap update
   */
  export type DCSAEventMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * The data needed to update a DCSAEventMap.
     */
    data: XOR<DCSAEventMapUpdateInput, DCSAEventMapUncheckedUpdateInput>
    /**
     * Choose, which DCSAEventMap to update.
     */
    where: DCSAEventMapWhereUniqueInput
  }

  /**
   * DCSAEventMap updateMany
   */
  export type DCSAEventMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DCSAEventMaps.
     */
    data: XOR<DCSAEventMapUpdateManyMutationInput, DCSAEventMapUncheckedUpdateManyInput>
    /**
     * Filter which DCSAEventMaps to update
     */
    where?: DCSAEventMapWhereInput
  }

  /**
   * DCSAEventMap upsert
   */
  export type DCSAEventMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * The filter to search for the DCSAEventMap to update in case it exists.
     */
    where: DCSAEventMapWhereUniqueInput
    /**
     * In case the DCSAEventMap found by the `where` argument doesn't exist, create a new DCSAEventMap with this data.
     */
    create: XOR<DCSAEventMapCreateInput, DCSAEventMapUncheckedCreateInput>
    /**
     * In case the DCSAEventMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DCSAEventMapUpdateInput, DCSAEventMapUncheckedUpdateInput>
  }

  /**
   * DCSAEventMap delete
   */
  export type DCSAEventMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
    /**
     * Filter which DCSAEventMap to delete.
     */
    where: DCSAEventMapWhereUniqueInput
  }

  /**
   * DCSAEventMap deleteMany
   */
  export type DCSAEventMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DCSAEventMaps to delete
     */
    where?: DCSAEventMapWhereInput
  }

  /**
   * DCSAEventMap.transitStage
   */
  export type DCSAEventMap$transitStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransitStage
     */
    select?: TransitStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransitStageInclude<ExtArgs> | null
    where?: TransitStageWhereInput
  }

  /**
   * DCSAEventMap.carrier
   */
  export type DCSAEventMap$carrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrier
     */
    select?: CarrierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrierInclude<ExtArgs> | null
    where?: CarrierWhereInput
  }

  /**
   * DCSAEventMap without action
   */
  export type DCSAEventMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DCSAEventMap
     */
    select?: DCSAEventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DCSAEventMapInclude<ExtArgs> | null
  }


  /**
   * Model AttentionFlag
   */

  export type AggregateAttentionFlag = {
    _count: AttentionFlagCountAggregateOutputType | null
    _min: AttentionFlagMinAggregateOutputType | null
    _max: AttentionFlagMaxAggregateOutputType | null
  }

  export type AttentionFlagMinAggregateOutputType = {
    id: string | null
    containerId: string | null
    reason: string | null
    priority: string | null
    flaggedBy: string | null
    flaggedOn: Date | null
    owner: string | null
    notes: string | null
    resolved: boolean | null
    resolvedBy: string | null
    resolvedDate: Date | null
    resolutionNote: string | null
  }

  export type AttentionFlagMaxAggregateOutputType = {
    id: string | null
    containerId: string | null
    reason: string | null
    priority: string | null
    flaggedBy: string | null
    flaggedOn: Date | null
    owner: string | null
    notes: string | null
    resolved: boolean | null
    resolvedBy: string | null
    resolvedDate: Date | null
    resolutionNote: string | null
  }

  export type AttentionFlagCountAggregateOutputType = {
    id: number
    containerId: number
    reason: number
    priority: number
    flaggedBy: number
    flaggedOn: number
    owner: number
    notes: number
    resolved: number
    resolvedBy: number
    resolvedDate: number
    resolutionNote: number
    _all: number
  }


  export type AttentionFlagMinAggregateInputType = {
    id?: true
    containerId?: true
    reason?: true
    priority?: true
    flaggedBy?: true
    flaggedOn?: true
    owner?: true
    notes?: true
    resolved?: true
    resolvedBy?: true
    resolvedDate?: true
    resolutionNote?: true
  }

  export type AttentionFlagMaxAggregateInputType = {
    id?: true
    containerId?: true
    reason?: true
    priority?: true
    flaggedBy?: true
    flaggedOn?: true
    owner?: true
    notes?: true
    resolved?: true
    resolvedBy?: true
    resolvedDate?: true
    resolutionNote?: true
  }

  export type AttentionFlagCountAggregateInputType = {
    id?: true
    containerId?: true
    reason?: true
    priority?: true
    flaggedBy?: true
    flaggedOn?: true
    owner?: true
    notes?: true
    resolved?: true
    resolvedBy?: true
    resolvedDate?: true
    resolutionNote?: true
    _all?: true
  }

  export type AttentionFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttentionFlag to aggregate.
     */
    where?: AttentionFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttentionFlags to fetch.
     */
    orderBy?: AttentionFlagOrderByWithRelationInput | AttentionFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttentionFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttentionFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttentionFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttentionFlags
    **/
    _count?: true | AttentionFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttentionFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttentionFlagMaxAggregateInputType
  }

  export type GetAttentionFlagAggregateType<T extends AttentionFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateAttentionFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttentionFlag[P]>
      : GetScalarType<T[P], AggregateAttentionFlag[P]>
  }




  export type AttentionFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttentionFlagWhereInput
    orderBy?: AttentionFlagOrderByWithAggregationInput | AttentionFlagOrderByWithAggregationInput[]
    by: AttentionFlagScalarFieldEnum[] | AttentionFlagScalarFieldEnum
    having?: AttentionFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttentionFlagCountAggregateInputType | true
    _min?: AttentionFlagMinAggregateInputType
    _max?: AttentionFlagMaxAggregateInputType
  }

  export type AttentionFlagGroupByOutputType = {
    id: string
    containerId: string
    reason: string
    priority: string
    flaggedBy: string | null
    flaggedOn: Date
    owner: string | null
    notes: string | null
    resolved: boolean
    resolvedBy: string | null
    resolvedDate: Date | null
    resolutionNote: string | null
    _count: AttentionFlagCountAggregateOutputType | null
    _min: AttentionFlagMinAggregateOutputType | null
    _max: AttentionFlagMaxAggregateOutputType | null
  }

  type GetAttentionFlagGroupByPayload<T extends AttentionFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttentionFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttentionFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttentionFlagGroupByOutputType[P]>
            : GetScalarType<T[P], AttentionFlagGroupByOutputType[P]>
        }
      >
    >


  export type AttentionFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    reason?: boolean
    priority?: boolean
    flaggedBy?: boolean
    flaggedOn?: boolean
    owner?: boolean
    notes?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedDate?: boolean
    resolutionNote?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attentionFlag"]>

  export type AttentionFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    reason?: boolean
    priority?: boolean
    flaggedBy?: boolean
    flaggedOn?: boolean
    owner?: boolean
    notes?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedDate?: boolean
    resolutionNote?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attentionFlag"]>

  export type AttentionFlagSelectScalar = {
    id?: boolean
    containerId?: boolean
    reason?: boolean
    priority?: boolean
    flaggedBy?: boolean
    flaggedOn?: boolean
    owner?: boolean
    notes?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedDate?: boolean
    resolutionNote?: boolean
  }

  export type AttentionFlagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }
  export type AttentionFlagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }

  export type $AttentionFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttentionFlag"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerId: string
      reason: string
      priority: string
      flaggedBy: string | null
      flaggedOn: Date
      owner: string | null
      notes: string | null
      resolved: boolean
      resolvedBy: string | null
      resolvedDate: Date | null
      resolutionNote: string | null
    }, ExtArgs["result"]["attentionFlag"]>
    composites: {}
  }

  type AttentionFlagGetPayload<S extends boolean | null | undefined | AttentionFlagDefaultArgs> = $Result.GetResult<Prisma.$AttentionFlagPayload, S>

  type AttentionFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttentionFlagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttentionFlagCountAggregateInputType | true
    }

  export interface AttentionFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttentionFlag'], meta: { name: 'AttentionFlag' } }
    /**
     * Find zero or one AttentionFlag that matches the filter.
     * @param {AttentionFlagFindUniqueArgs} args - Arguments to find a AttentionFlag
     * @example
     * // Get one AttentionFlag
     * const attentionFlag = await prisma.attentionFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttentionFlagFindUniqueArgs>(args: SelectSubset<T, AttentionFlagFindUniqueArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttentionFlag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttentionFlagFindUniqueOrThrowArgs} args - Arguments to find a AttentionFlag
     * @example
     * // Get one AttentionFlag
     * const attentionFlag = await prisma.attentionFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttentionFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, AttentionFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttentionFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagFindFirstArgs} args - Arguments to find a AttentionFlag
     * @example
     * // Get one AttentionFlag
     * const attentionFlag = await prisma.attentionFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttentionFlagFindFirstArgs>(args?: SelectSubset<T, AttentionFlagFindFirstArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttentionFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagFindFirstOrThrowArgs} args - Arguments to find a AttentionFlag
     * @example
     * // Get one AttentionFlag
     * const attentionFlag = await prisma.attentionFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttentionFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, AttentionFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttentionFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttentionFlags
     * const attentionFlags = await prisma.attentionFlag.findMany()
     * 
     * // Get first 10 AttentionFlags
     * const attentionFlags = await prisma.attentionFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attentionFlagWithIdOnly = await prisma.attentionFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttentionFlagFindManyArgs>(args?: SelectSubset<T, AttentionFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttentionFlag.
     * @param {AttentionFlagCreateArgs} args - Arguments to create a AttentionFlag.
     * @example
     * // Create one AttentionFlag
     * const AttentionFlag = await prisma.attentionFlag.create({
     *   data: {
     *     // ... data to create a AttentionFlag
     *   }
     * })
     * 
     */
    create<T extends AttentionFlagCreateArgs>(args: SelectSubset<T, AttentionFlagCreateArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttentionFlags.
     * @param {AttentionFlagCreateManyArgs} args - Arguments to create many AttentionFlags.
     * @example
     * // Create many AttentionFlags
     * const attentionFlag = await prisma.attentionFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttentionFlagCreateManyArgs>(args?: SelectSubset<T, AttentionFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttentionFlags and returns the data saved in the database.
     * @param {AttentionFlagCreateManyAndReturnArgs} args - Arguments to create many AttentionFlags.
     * @example
     * // Create many AttentionFlags
     * const attentionFlag = await prisma.attentionFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttentionFlags and only return the `id`
     * const attentionFlagWithIdOnly = await prisma.attentionFlag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttentionFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, AttentionFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttentionFlag.
     * @param {AttentionFlagDeleteArgs} args - Arguments to delete one AttentionFlag.
     * @example
     * // Delete one AttentionFlag
     * const AttentionFlag = await prisma.attentionFlag.delete({
     *   where: {
     *     // ... filter to delete one AttentionFlag
     *   }
     * })
     * 
     */
    delete<T extends AttentionFlagDeleteArgs>(args: SelectSubset<T, AttentionFlagDeleteArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttentionFlag.
     * @param {AttentionFlagUpdateArgs} args - Arguments to update one AttentionFlag.
     * @example
     * // Update one AttentionFlag
     * const attentionFlag = await prisma.attentionFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttentionFlagUpdateArgs>(args: SelectSubset<T, AttentionFlagUpdateArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttentionFlags.
     * @param {AttentionFlagDeleteManyArgs} args - Arguments to filter AttentionFlags to delete.
     * @example
     * // Delete a few AttentionFlags
     * const { count } = await prisma.attentionFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttentionFlagDeleteManyArgs>(args?: SelectSubset<T, AttentionFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttentionFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttentionFlags
     * const attentionFlag = await prisma.attentionFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttentionFlagUpdateManyArgs>(args: SelectSubset<T, AttentionFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttentionFlag.
     * @param {AttentionFlagUpsertArgs} args - Arguments to update or create a AttentionFlag.
     * @example
     * // Update or create a AttentionFlag
     * const attentionFlag = await prisma.attentionFlag.upsert({
     *   create: {
     *     // ... data to create a AttentionFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttentionFlag we want to update
     *   }
     * })
     */
    upsert<T extends AttentionFlagUpsertArgs>(args: SelectSubset<T, AttentionFlagUpsertArgs<ExtArgs>>): Prisma__AttentionFlagClient<$Result.GetResult<Prisma.$AttentionFlagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttentionFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagCountArgs} args - Arguments to filter AttentionFlags to count.
     * @example
     * // Count the number of AttentionFlags
     * const count = await prisma.attentionFlag.count({
     *   where: {
     *     // ... the filter for the AttentionFlags we want to count
     *   }
     * })
    **/
    count<T extends AttentionFlagCountArgs>(
      args?: Subset<T, AttentionFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttentionFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttentionFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttentionFlagAggregateArgs>(args: Subset<T, AttentionFlagAggregateArgs>): Prisma.PrismaPromise<GetAttentionFlagAggregateType<T>>

    /**
     * Group by AttentionFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttentionFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttentionFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttentionFlagGroupByArgs['orderBy'] }
        : { orderBy?: AttentionFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttentionFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttentionFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttentionFlag model
   */
  readonly fields: AttentionFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttentionFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttentionFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttentionFlag model
   */ 
  interface AttentionFlagFieldRefs {
    readonly id: FieldRef<"AttentionFlag", 'String'>
    readonly containerId: FieldRef<"AttentionFlag", 'String'>
    readonly reason: FieldRef<"AttentionFlag", 'String'>
    readonly priority: FieldRef<"AttentionFlag", 'String'>
    readonly flaggedBy: FieldRef<"AttentionFlag", 'String'>
    readonly flaggedOn: FieldRef<"AttentionFlag", 'DateTime'>
    readonly owner: FieldRef<"AttentionFlag", 'String'>
    readonly notes: FieldRef<"AttentionFlag", 'String'>
    readonly resolved: FieldRef<"AttentionFlag", 'Boolean'>
    readonly resolvedBy: FieldRef<"AttentionFlag", 'String'>
    readonly resolvedDate: FieldRef<"AttentionFlag", 'DateTime'>
    readonly resolutionNote: FieldRef<"AttentionFlag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttentionFlag findUnique
   */
  export type AttentionFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * Filter, which AttentionFlag to fetch.
     */
    where: AttentionFlagWhereUniqueInput
  }

  /**
   * AttentionFlag findUniqueOrThrow
   */
  export type AttentionFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * Filter, which AttentionFlag to fetch.
     */
    where: AttentionFlagWhereUniqueInput
  }

  /**
   * AttentionFlag findFirst
   */
  export type AttentionFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * Filter, which AttentionFlag to fetch.
     */
    where?: AttentionFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttentionFlags to fetch.
     */
    orderBy?: AttentionFlagOrderByWithRelationInput | AttentionFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttentionFlags.
     */
    cursor?: AttentionFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttentionFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttentionFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttentionFlags.
     */
    distinct?: AttentionFlagScalarFieldEnum | AttentionFlagScalarFieldEnum[]
  }

  /**
   * AttentionFlag findFirstOrThrow
   */
  export type AttentionFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * Filter, which AttentionFlag to fetch.
     */
    where?: AttentionFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttentionFlags to fetch.
     */
    orderBy?: AttentionFlagOrderByWithRelationInput | AttentionFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttentionFlags.
     */
    cursor?: AttentionFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttentionFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttentionFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttentionFlags.
     */
    distinct?: AttentionFlagScalarFieldEnum | AttentionFlagScalarFieldEnum[]
  }

  /**
   * AttentionFlag findMany
   */
  export type AttentionFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * Filter, which AttentionFlags to fetch.
     */
    where?: AttentionFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttentionFlags to fetch.
     */
    orderBy?: AttentionFlagOrderByWithRelationInput | AttentionFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttentionFlags.
     */
    cursor?: AttentionFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttentionFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttentionFlags.
     */
    skip?: number
    distinct?: AttentionFlagScalarFieldEnum | AttentionFlagScalarFieldEnum[]
  }

  /**
   * AttentionFlag create
   */
  export type AttentionFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * The data needed to create a AttentionFlag.
     */
    data: XOR<AttentionFlagCreateInput, AttentionFlagUncheckedCreateInput>
  }

  /**
   * AttentionFlag createMany
   */
  export type AttentionFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttentionFlags.
     */
    data: AttentionFlagCreateManyInput | AttentionFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttentionFlag createManyAndReturn
   */
  export type AttentionFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttentionFlags.
     */
    data: AttentionFlagCreateManyInput | AttentionFlagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttentionFlag update
   */
  export type AttentionFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * The data needed to update a AttentionFlag.
     */
    data: XOR<AttentionFlagUpdateInput, AttentionFlagUncheckedUpdateInput>
    /**
     * Choose, which AttentionFlag to update.
     */
    where: AttentionFlagWhereUniqueInput
  }

  /**
   * AttentionFlag updateMany
   */
  export type AttentionFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttentionFlags.
     */
    data: XOR<AttentionFlagUpdateManyMutationInput, AttentionFlagUncheckedUpdateManyInput>
    /**
     * Filter which AttentionFlags to update
     */
    where?: AttentionFlagWhereInput
  }

  /**
   * AttentionFlag upsert
   */
  export type AttentionFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * The filter to search for the AttentionFlag to update in case it exists.
     */
    where: AttentionFlagWhereUniqueInput
    /**
     * In case the AttentionFlag found by the `where` argument doesn't exist, create a new AttentionFlag with this data.
     */
    create: XOR<AttentionFlagCreateInput, AttentionFlagUncheckedCreateInput>
    /**
     * In case the AttentionFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttentionFlagUpdateInput, AttentionFlagUncheckedUpdateInput>
  }

  /**
   * AttentionFlag delete
   */
  export type AttentionFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
    /**
     * Filter which AttentionFlag to delete.
     */
    where: AttentionFlagWhereUniqueInput
  }

  /**
   * AttentionFlag deleteMany
   */
  export type AttentionFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttentionFlags to delete
     */
    where?: AttentionFlagWhereInput
  }

  /**
   * AttentionFlag without action
   */
  export type AttentionFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttentionFlag
     */
    select?: AttentionFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttentionFlagInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    containerId: string | null
    shipmentId: string | null
    action: string | null
    actor: string | null
    detail: string | null
    source: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    containerId: string | null
    shipmentId: string | null
    action: string | null
    actor: string | null
    detail: string | null
    source: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    containerId: number
    shipmentId: number
    action: number
    actor: number
    detail: number
    source: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    containerId?: true
    shipmentId?: true
    action?: true
    actor?: true
    detail?: true
    source?: true
    metadata?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    containerId?: true
    shipmentId?: true
    action?: true
    actor?: true
    detail?: true
    source?: true
    metadata?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    containerId?: true
    shipmentId?: true
    action?: true
    actor?: true
    detail?: true
    source?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    containerId: string | null
    shipmentId: string | null
    action: string
    actor: string | null
    detail: string | null
    source: string | null
    metadata: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    shipmentId?: boolean
    action?: boolean
    actor?: boolean
    detail?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    container?: boolean | ActivityLog$containerArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    shipmentId?: boolean
    action?: boolean
    actor?: boolean
    detail?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    container?: boolean | ActivityLog$containerArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    containerId?: boolean
    shipmentId?: boolean
    action?: boolean
    actor?: boolean
    detail?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ActivityLog$containerArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ActivityLog$containerArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerId: string | null
      shipmentId: string | null
      action: string
      actor: string | null
      detail: string | null
      source: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ActivityLog$containerArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$containerArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly containerId: FieldRef<"ActivityLog", 'String'>
    readonly shipmentId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly actor: FieldRef<"ActivityLog", 'String'>
    readonly detail: FieldRef<"ActivityLog", 'String'>
    readonly source: FieldRef<"ActivityLog", 'String'>
    readonly metadata: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog.container
   */
  export type ActivityLog$containerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model StatusOverride
   */

  export type AggregateStatusOverride = {
    _count: StatusOverrideCountAggregateOutputType | null
    _min: StatusOverrideMinAggregateOutputType | null
    _max: StatusOverrideMaxAggregateOutputType | null
  }

  export type StatusOverrideMinAggregateOutputType = {
    id: string | null
    containerNumber: string | null
    previousStatus: string | null
    newStatus: string | null
    reason: string | null
    overriddenBy: string | null
    overriddenAt: Date | null
  }

  export type StatusOverrideMaxAggregateOutputType = {
    id: string | null
    containerNumber: string | null
    previousStatus: string | null
    newStatus: string | null
    reason: string | null
    overriddenBy: string | null
    overriddenAt: Date | null
  }

  export type StatusOverrideCountAggregateOutputType = {
    id: number
    containerNumber: number
    previousStatus: number
    newStatus: number
    reason: number
    overriddenBy: number
    overriddenAt: number
    _all: number
  }


  export type StatusOverrideMinAggregateInputType = {
    id?: true
    containerNumber?: true
    previousStatus?: true
    newStatus?: true
    reason?: true
    overriddenBy?: true
    overriddenAt?: true
  }

  export type StatusOverrideMaxAggregateInputType = {
    id?: true
    containerNumber?: true
    previousStatus?: true
    newStatus?: true
    reason?: true
    overriddenBy?: true
    overriddenAt?: true
  }

  export type StatusOverrideCountAggregateInputType = {
    id?: true
    containerNumber?: true
    previousStatus?: true
    newStatus?: true
    reason?: true
    overriddenBy?: true
    overriddenAt?: true
    _all?: true
  }

  export type StatusOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusOverride to aggregate.
     */
    where?: StatusOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusOverrides to fetch.
     */
    orderBy?: StatusOverrideOrderByWithRelationInput | StatusOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusOverrides
    **/
    _count?: true | StatusOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusOverrideMaxAggregateInputType
  }

  export type GetStatusOverrideAggregateType<T extends StatusOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusOverride[P]>
      : GetScalarType<T[P], AggregateStatusOverride[P]>
  }




  export type StatusOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusOverrideWhereInput
    orderBy?: StatusOverrideOrderByWithAggregationInput | StatusOverrideOrderByWithAggregationInput[]
    by: StatusOverrideScalarFieldEnum[] | StatusOverrideScalarFieldEnum
    having?: StatusOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusOverrideCountAggregateInputType | true
    _min?: StatusOverrideMinAggregateInputType
    _max?: StatusOverrideMaxAggregateInputType
  }

  export type StatusOverrideGroupByOutputType = {
    id: string
    containerNumber: string
    previousStatus: string | null
    newStatus: string
    reason: string
    overriddenBy: string | null
    overriddenAt: Date
    _count: StatusOverrideCountAggregateOutputType | null
    _min: StatusOverrideMinAggregateOutputType | null
    _max: StatusOverrideMaxAggregateOutputType | null
  }

  type GetStatusOverrideGroupByPayload<T extends StatusOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], StatusOverrideGroupByOutputType[P]>
        }
      >
    >


  export type StatusOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerNumber?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    reason?: boolean
    overriddenBy?: boolean
    overriddenAt?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusOverride"]>

  export type StatusOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerNumber?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    reason?: boolean
    overriddenBy?: boolean
    overriddenAt?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusOverride"]>

  export type StatusOverrideSelectScalar = {
    id?: boolean
    containerNumber?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    reason?: boolean
    overriddenBy?: boolean
    overriddenAt?: boolean
  }

  export type StatusOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }
  export type StatusOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }

  export type $StatusOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusOverride"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerNumber: string
      previousStatus: string | null
      newStatus: string
      reason: string
      overriddenBy: string | null
      overriddenAt: Date
    }, ExtArgs["result"]["statusOverride"]>
    composites: {}
  }

  type StatusOverrideGetPayload<S extends boolean | null | undefined | StatusOverrideDefaultArgs> = $Result.GetResult<Prisma.$StatusOverridePayload, S>

  type StatusOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatusOverrideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatusOverrideCountAggregateInputType | true
    }

  export interface StatusOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusOverride'], meta: { name: 'StatusOverride' } }
    /**
     * Find zero or one StatusOverride that matches the filter.
     * @param {StatusOverrideFindUniqueArgs} args - Arguments to find a StatusOverride
     * @example
     * // Get one StatusOverride
     * const statusOverride = await prisma.statusOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusOverrideFindUniqueArgs>(args: SelectSubset<T, StatusOverrideFindUniqueArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatusOverride that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatusOverrideFindUniqueOrThrowArgs} args - Arguments to find a StatusOverride
     * @example
     * // Get one StatusOverride
     * const statusOverride = await prisma.statusOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatusOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideFindFirstArgs} args - Arguments to find a StatusOverride
     * @example
     * // Get one StatusOverride
     * const statusOverride = await prisma.statusOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusOverrideFindFirstArgs>(args?: SelectSubset<T, StatusOverrideFindFirstArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatusOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideFindFirstOrThrowArgs} args - Arguments to find a StatusOverride
     * @example
     * // Get one StatusOverride
     * const statusOverride = await prisma.statusOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatusOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusOverrides
     * const statusOverrides = await prisma.statusOverride.findMany()
     * 
     * // Get first 10 StatusOverrides
     * const statusOverrides = await prisma.statusOverride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusOverrideWithIdOnly = await prisma.statusOverride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusOverrideFindManyArgs>(args?: SelectSubset<T, StatusOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatusOverride.
     * @param {StatusOverrideCreateArgs} args - Arguments to create a StatusOverride.
     * @example
     * // Create one StatusOverride
     * const StatusOverride = await prisma.statusOverride.create({
     *   data: {
     *     // ... data to create a StatusOverride
     *   }
     * })
     * 
     */
    create<T extends StatusOverrideCreateArgs>(args: SelectSubset<T, StatusOverrideCreateArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatusOverrides.
     * @param {StatusOverrideCreateManyArgs} args - Arguments to create many StatusOverrides.
     * @example
     * // Create many StatusOverrides
     * const statusOverride = await prisma.statusOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusOverrideCreateManyArgs>(args?: SelectSubset<T, StatusOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatusOverrides and returns the data saved in the database.
     * @param {StatusOverrideCreateManyAndReturnArgs} args - Arguments to create many StatusOverrides.
     * @example
     * // Create many StatusOverrides
     * const statusOverride = await prisma.statusOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatusOverrides and only return the `id`
     * const statusOverrideWithIdOnly = await prisma.statusOverride.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatusOverride.
     * @param {StatusOverrideDeleteArgs} args - Arguments to delete one StatusOverride.
     * @example
     * // Delete one StatusOverride
     * const StatusOverride = await prisma.statusOverride.delete({
     *   where: {
     *     // ... filter to delete one StatusOverride
     *   }
     * })
     * 
     */
    delete<T extends StatusOverrideDeleteArgs>(args: SelectSubset<T, StatusOverrideDeleteArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatusOverride.
     * @param {StatusOverrideUpdateArgs} args - Arguments to update one StatusOverride.
     * @example
     * // Update one StatusOverride
     * const statusOverride = await prisma.statusOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusOverrideUpdateArgs>(args: SelectSubset<T, StatusOverrideUpdateArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatusOverrides.
     * @param {StatusOverrideDeleteManyArgs} args - Arguments to filter StatusOverrides to delete.
     * @example
     * // Delete a few StatusOverrides
     * const { count } = await prisma.statusOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusOverrideDeleteManyArgs>(args?: SelectSubset<T, StatusOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusOverrides
     * const statusOverride = await prisma.statusOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusOverrideUpdateManyArgs>(args: SelectSubset<T, StatusOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusOverride.
     * @param {StatusOverrideUpsertArgs} args - Arguments to update or create a StatusOverride.
     * @example
     * // Update or create a StatusOverride
     * const statusOverride = await prisma.statusOverride.upsert({
     *   create: {
     *     // ... data to create a StatusOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusOverride we want to update
     *   }
     * })
     */
    upsert<T extends StatusOverrideUpsertArgs>(args: SelectSubset<T, StatusOverrideUpsertArgs<ExtArgs>>): Prisma__StatusOverrideClient<$Result.GetResult<Prisma.$StatusOverridePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatusOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideCountArgs} args - Arguments to filter StatusOverrides to count.
     * @example
     * // Count the number of StatusOverrides
     * const count = await prisma.statusOverride.count({
     *   where: {
     *     // ... the filter for the StatusOverrides we want to count
     *   }
     * })
    **/
    count<T extends StatusOverrideCountArgs>(
      args?: Subset<T, StatusOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusOverrideAggregateArgs>(args: Subset<T, StatusOverrideAggregateArgs>): Prisma.PrismaPromise<GetStatusOverrideAggregateType<T>>

    /**
     * Group by StatusOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusOverrideGroupByArgs['orderBy'] }
        : { orderBy?: StatusOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusOverride model
   */
  readonly fields: StatusOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusOverride model
   */ 
  interface StatusOverrideFieldRefs {
    readonly id: FieldRef<"StatusOverride", 'String'>
    readonly containerNumber: FieldRef<"StatusOverride", 'String'>
    readonly previousStatus: FieldRef<"StatusOverride", 'String'>
    readonly newStatus: FieldRef<"StatusOverride", 'String'>
    readonly reason: FieldRef<"StatusOverride", 'String'>
    readonly overriddenBy: FieldRef<"StatusOverride", 'String'>
    readonly overriddenAt: FieldRef<"StatusOverride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusOverride findUnique
   */
  export type StatusOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * Filter, which StatusOverride to fetch.
     */
    where: StatusOverrideWhereUniqueInput
  }

  /**
   * StatusOverride findUniqueOrThrow
   */
  export type StatusOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * Filter, which StatusOverride to fetch.
     */
    where: StatusOverrideWhereUniqueInput
  }

  /**
   * StatusOverride findFirst
   */
  export type StatusOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * Filter, which StatusOverride to fetch.
     */
    where?: StatusOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusOverrides to fetch.
     */
    orderBy?: StatusOverrideOrderByWithRelationInput | StatusOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusOverrides.
     */
    cursor?: StatusOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusOverrides.
     */
    distinct?: StatusOverrideScalarFieldEnum | StatusOverrideScalarFieldEnum[]
  }

  /**
   * StatusOverride findFirstOrThrow
   */
  export type StatusOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * Filter, which StatusOverride to fetch.
     */
    where?: StatusOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusOverrides to fetch.
     */
    orderBy?: StatusOverrideOrderByWithRelationInput | StatusOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusOverrides.
     */
    cursor?: StatusOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusOverrides.
     */
    distinct?: StatusOverrideScalarFieldEnum | StatusOverrideScalarFieldEnum[]
  }

  /**
   * StatusOverride findMany
   */
  export type StatusOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * Filter, which StatusOverrides to fetch.
     */
    where?: StatusOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusOverrides to fetch.
     */
    orderBy?: StatusOverrideOrderByWithRelationInput | StatusOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusOverrides.
     */
    cursor?: StatusOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusOverrides.
     */
    skip?: number
    distinct?: StatusOverrideScalarFieldEnum | StatusOverrideScalarFieldEnum[]
  }

  /**
   * StatusOverride create
   */
  export type StatusOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusOverride.
     */
    data: XOR<StatusOverrideCreateInput, StatusOverrideUncheckedCreateInput>
  }

  /**
   * StatusOverride createMany
   */
  export type StatusOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusOverrides.
     */
    data: StatusOverrideCreateManyInput | StatusOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusOverride createManyAndReturn
   */
  export type StatusOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatusOverrides.
     */
    data: StatusOverrideCreateManyInput | StatusOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusOverride update
   */
  export type StatusOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusOverride.
     */
    data: XOR<StatusOverrideUpdateInput, StatusOverrideUncheckedUpdateInput>
    /**
     * Choose, which StatusOverride to update.
     */
    where: StatusOverrideWhereUniqueInput
  }

  /**
   * StatusOverride updateMany
   */
  export type StatusOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusOverrides.
     */
    data: XOR<StatusOverrideUpdateManyMutationInput, StatusOverrideUncheckedUpdateManyInput>
    /**
     * Filter which StatusOverrides to update
     */
    where?: StatusOverrideWhereInput
  }

  /**
   * StatusOverride upsert
   */
  export type StatusOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusOverride to update in case it exists.
     */
    where: StatusOverrideWhereUniqueInput
    /**
     * In case the StatusOverride found by the `where` argument doesn't exist, create a new StatusOverride with this data.
     */
    create: XOR<StatusOverrideCreateInput, StatusOverrideUncheckedCreateInput>
    /**
     * In case the StatusOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusOverrideUpdateInput, StatusOverrideUncheckedUpdateInput>
  }

  /**
   * StatusOverride delete
   */
  export type StatusOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
    /**
     * Filter which StatusOverride to delete.
     */
    where: StatusOverrideWhereUniqueInput
  }

  /**
   * StatusOverride deleteMany
   */
  export type StatusOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusOverrides to delete
     */
    where?: StatusOverrideWhereInput
  }

  /**
   * StatusOverride without action
   */
  export type StatusOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusOverride
     */
    select?: StatusOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusOverrideInclude<ExtArgs> | null
  }


  /**
   * Model RiskAssessment
   */

  export type AggregateRiskAssessment = {
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  export type RiskAssessmentAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type RiskAssessmentSumAggregateOutputType = {
    riskScore: number | null
  }

  export type RiskAssessmentMinAggregateOutputType = {
    id: string | null
    containerId: string | null
    riskScore: number | null
    riskFactors: string | null
    recommendations: string | null
    lastUpdated: Date | null
  }

  export type RiskAssessmentMaxAggregateOutputType = {
    id: string | null
    containerId: string | null
    riskScore: number | null
    riskFactors: string | null
    recommendations: string | null
    lastUpdated: Date | null
  }

  export type RiskAssessmentCountAggregateOutputType = {
    id: number
    containerId: number
    riskScore: number
    riskFactors: number
    recommendations: number
    lastUpdated: number
    _all: number
  }


  export type RiskAssessmentAvgAggregateInputType = {
    riskScore?: true
  }

  export type RiskAssessmentSumAggregateInputType = {
    riskScore?: true
  }

  export type RiskAssessmentMinAggregateInputType = {
    id?: true
    containerId?: true
    riskScore?: true
    riskFactors?: true
    recommendations?: true
    lastUpdated?: true
  }

  export type RiskAssessmentMaxAggregateInputType = {
    id?: true
    containerId?: true
    riskScore?: true
    riskFactors?: true
    recommendations?: true
    lastUpdated?: true
  }

  export type RiskAssessmentCountAggregateInputType = {
    id?: true
    containerId?: true
    riskScore?: true
    riskFactors?: true
    recommendations?: true
    lastUpdated?: true
    _all?: true
  }

  export type RiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessment to aggregate.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAssessments
    **/
    _count?: true | RiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type GetRiskAssessmentAggregateType<T extends RiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAssessment[P]>
      : GetScalarType<T[P], AggregateRiskAssessment[P]>
  }




  export type RiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithAggregationInput | RiskAssessmentOrderByWithAggregationInput[]
    by: RiskAssessmentScalarFieldEnum[] | RiskAssessmentScalarFieldEnum
    having?: RiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAssessmentCountAggregateInputType | true
    _avg?: RiskAssessmentAvgAggregateInputType
    _sum?: RiskAssessmentSumAggregateInputType
    _min?: RiskAssessmentMinAggregateInputType
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type RiskAssessmentGroupByOutputType = {
    id: string
    containerId: string
    riskScore: number
    riskFactors: string
    recommendations: string
    lastUpdated: Date
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  type GetRiskAssessmentGroupByPayload<T extends RiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type RiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    recommendations?: boolean
    lastUpdated?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    recommendations?: boolean
    lastUpdated?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectScalar = {
    id?: boolean
    containerId?: boolean
    riskScore?: boolean
    riskFactors?: boolean
    recommendations?: boolean
    lastUpdated?: boolean
  }

  export type RiskAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }
  export type RiskAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
  }

  export type $RiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAssessment"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      containerId: string
      riskScore: number
      riskFactors: string
      recommendations: string
      lastUpdated: Date
    }, ExtArgs["result"]["riskAssessment"]>
    composites: {}
  }

  type RiskAssessmentGetPayload<S extends boolean | null | undefined | RiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$RiskAssessmentPayload, S>

  type RiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskAssessmentCountAggregateInputType | true
    }

  export interface RiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAssessment'], meta: { name: 'RiskAssessment' } }
    /**
     * Find zero or one RiskAssessment that matches the filter.
     * @param {RiskAssessmentFindUniqueArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAssessmentFindUniqueArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAssessmentFindFirstArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany()
     * 
     * // Get first 10 RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAssessmentFindManyArgs>(args?: SelectSubset<T, RiskAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskAssessment.
     * @param {RiskAssessmentCreateArgs} args - Arguments to create a RiskAssessment.
     * @example
     * // Create one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.create({
     *   data: {
     *     // ... data to create a RiskAssessment
     *   }
     * })
     * 
     */
    create<T extends RiskAssessmentCreateArgs>(args: SelectSubset<T, RiskAssessmentCreateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskAssessments.
     * @param {RiskAssessmentCreateManyArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAssessmentCreateManyArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAssessments and returns the data saved in the database.
     * @param {RiskAssessmentCreateManyAndReturnArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAssessments and only return the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskAssessment.
     * @param {RiskAssessmentDeleteArgs} args - Arguments to delete one RiskAssessment.
     * @example
     * // Delete one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.delete({
     *   where: {
     *     // ... filter to delete one RiskAssessment
     *   }
     * })
     * 
     */
    delete<T extends RiskAssessmentDeleteArgs>(args: SelectSubset<T, RiskAssessmentDeleteArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskAssessment.
     * @param {RiskAssessmentUpdateArgs} args - Arguments to update one RiskAssessment.
     * @example
     * // Update one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAssessmentUpdateArgs>(args: SelectSubset<T, RiskAssessmentUpdateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskAssessments.
     * @param {RiskAssessmentDeleteManyArgs} args - Arguments to filter RiskAssessments to delete.
     * @example
     * // Delete a few RiskAssessments
     * const { count } = await prisma.riskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAssessmentDeleteManyArgs>(args?: SelectSubset<T, RiskAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAssessmentUpdateManyArgs>(args: SelectSubset<T, RiskAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskAssessment.
     * @param {RiskAssessmentUpsertArgs} args - Arguments to update or create a RiskAssessment.
     * @example
     * // Update or create a RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.upsert({
     *   create: {
     *     // ... data to create a RiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAssessment we want to update
     *   }
     * })
     */
    upsert<T extends RiskAssessmentUpsertArgs>(args: SelectSubset<T, RiskAssessmentUpsertArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentCountArgs} args - Arguments to filter RiskAssessments to count.
     * @example
     * // Count the number of RiskAssessments
     * const count = await prisma.riskAssessment.count({
     *   where: {
     *     // ... the filter for the RiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends RiskAssessmentCountArgs>(
      args?: Subset<T, RiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAssessmentAggregateArgs>(args: Subset<T, RiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetRiskAssessmentAggregateType<T>>

    /**
     * Group by RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: RiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAssessment model
   */
  readonly fields: RiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAssessment model
   */ 
  interface RiskAssessmentFieldRefs {
    readonly id: FieldRef<"RiskAssessment", 'String'>
    readonly containerId: FieldRef<"RiskAssessment", 'String'>
    readonly riskScore: FieldRef<"RiskAssessment", 'Int'>
    readonly riskFactors: FieldRef<"RiskAssessment", 'String'>
    readonly recommendations: FieldRef<"RiskAssessment", 'String'>
    readonly lastUpdated: FieldRef<"RiskAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskAssessment findUnique
   */
  export type RiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findUniqueOrThrow
   */
  export type RiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findFirst
   */
  export type RiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findFirstOrThrow
   */
  export type RiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findMany
   */
  export type RiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessments to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment create
   */
  export type RiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskAssessment.
     */
    data: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
  }

  /**
   * RiskAssessment createMany
   */
  export type RiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment createManyAndReturn
   */
  export type RiskAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAssessment update
   */
  export type RiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskAssessment.
     */
    data: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which RiskAssessment to update.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment updateMany
   */
  export type RiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAssessments.
     */
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which RiskAssessments to update
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment upsert
   */
  export type RiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskAssessment to update in case it exists.
     */
    where: RiskAssessmentWhereUniqueInput
    /**
     * In case the RiskAssessment found by the `where` argument doesn't exist, create a new RiskAssessment with this data.
     */
    create: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
    /**
     * In case the RiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
  }

  /**
   * RiskAssessment delete
   */
  export type RiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter which RiskAssessment to delete.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment deleteMany
   */
  export type RiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessments to delete
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment without action
   */
  export type RiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ImportLogScalarFieldEnum: {
    fileName: 'fileName',
    fileURL: 'fileURL',
    importedBy: 'importedBy',
    importedOn: 'importedOn',
    rowsProcessed: 'rowsProcessed',
    rowsSucceeded: 'rowsSucceeded',
    rowsFailed: 'rowsFailed',
    carrierFormatId: 'carrierFormatId',
    importType: 'importType',
    status: 'status',
    errorLog: 'errorLog',
    aiAnalysis: 'aiAnalysis',
    aiAnalyzedAt: 'aiAnalyzedAt'
  };

  export type ImportLogScalarFieldEnum = (typeof ImportLogScalarFieldEnum)[keyof typeof ImportLogScalarFieldEnum]


  export const RawRowScalarFieldEnum: {
    id: 'id',
    importLogId: 'importLogId',
    rowNumber: 'rowNumber',
    data: 'data'
  };

  export type RawRowScalarFieldEnum = (typeof RawRowScalarFieldEnum)[keyof typeof RawRowScalarFieldEnum]


  export const TransitStageScalarFieldEnum: {
    stageName: 'stageName',
    stageCode: 'stageCode',
    sequence: 'sequence',
    category: 'category',
    expectedDays: 'expectedDays',
    alertAfterDays: 'alertAfterDays',
    responsibleTeam: 'responsibleTeam',
    isActive: 'isActive',
    dcsaEventType: 'dcsaEventType',
    dcsaEventCategory: 'dcsaEventCategory',
    dcsaFacilityType: 'dcsaFacilityType'
  };

  export type TransitStageScalarFieldEnum = (typeof TransitStageScalarFieldEnum)[keyof typeof TransitStageScalarFieldEnum]


  export const ShipmentScalarFieldEnum: {
    shipmentReference: 'shipmentReference',
    hbl: 'hbl',
    mbl: 'mbl',
    bookingReference: 'bookingReference',
    shipmentType: 'shipmentType',
    carrier: 'carrier',
    forwarder: 'forwarder',
    shipper: 'shipper',
    consignee: 'consignee',
    pol: 'pol',
    pod: 'pod',
    finalDestination: 'finalDestination',
    contents: 'contents',
    supplier: 'supplier',
    totalWeight: 'totalWeight',
    totalPieces: 'totalPieces',
    customerReference: 'customerReference',
    poNumber: 'poNumber',
    incoTerms: 'incoTerms',
    expectedContainers: 'expectedContainers',
    blType: 'blType',
    blStatus: 'blStatus',
    paymentStatus: 'paymentStatus',
    paymentDueDate: 'paymentDueDate',
    amountDue: 'amountDue',
    releaseStatus: 'releaseStatus',
    releaseDate: 'releaseDate',
    holdReason: 'holdReason',
    notes: 'notes',
    aceEntryNumber: 'aceEntryNumber',
    aceEntryType: 'aceEntryType',
    dutyAmount: 'dutyAmount',
    liquidationStatus: 'liquidationStatus',
    liquidationDate: 'liquidationDate'
  };

  export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


  export const ContainerScalarFieldEnum: {
    containerNumber: 'containerNumber',
    containerType: 'containerType',
    currentStatus: 'currentStatus',
    currentLocation: 'currentLocation',
    currentVessel: 'currentVessel',
    currentVoyage: 'currentVoyage',
    mbl: 'mbl',
    carrier: 'carrier',
    pol: 'pol',
    pod: 'pod',
    etd: 'etd',
    atd: 'atd',
    eta: 'eta',
    ata: 'ata',
    lastFreeDay: 'lastFreeDay',
    detentionFreeDay: 'detentionFreeDay',
    statusLastUpdated: 'statusLastUpdated',
    hasException: 'hasException',
    exceptionType: 'exceptionType',
    exceptionOwner: 'exceptionOwner',
    exceptionNotes: 'exceptionNotes',
    exceptionDate: 'exceptionDate',
    manualPriority: 'manualPriority',
    priorityReason: 'priorityReason',
    prioritySetBy: 'prioritySetBy',
    prioritySetDate: 'prioritySetDate',
    notes: 'notes',
    emptyIndicator: 'emptyIndicator',
    sealNumber: 'sealNumber',
    grossWeight: 'grossWeight',
    carrierEventId: 'carrierEventId',
    aceEntryNumber: 'aceEntryNumber',
    aceDisposition: 'aceDisposition',
    aceStatus: 'aceStatus',
    aceLastUpdated: 'aceLastUpdated',
    pgaHold: 'pgaHold',
    pgaAgency: 'pgaAgency',
    pgaHoldReason: 'pgaHoldReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContainerScalarFieldEnum = (typeof ContainerScalarFieldEnum)[keyof typeof ContainerScalarFieldEnum]


  export const ShipmentContainerScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    containerId: 'containerId',
    piecesInContainer: 'piecesInContainer',
    weightInContainer: 'weightInContainer',
    notes: 'notes'
  };

  export type ShipmentContainerScalarFieldEnum = (typeof ShipmentContainerScalarFieldEnum)[keyof typeof ShipmentContainerScalarFieldEnum]


  export const ContainerEventScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    stageName: 'stageName',
    eventDateTime: 'eventDateTime',
    location: 'location',
    facilityId: 'facilityId',
    vessel: 'vessel',
    voyage: 'voyage',
    source: 'source',
    sourceFileId: 'sourceFileId',
    updatedBy: 'updatedBy',
    updatedOn: 'updatedOn',
    previousStatus: 'previousStatus',
    exceptionCleared: 'exceptionCleared',
    notes: 'notes',
    eventCategory: 'eventCategory',
    eventClassifier: 'eventClassifier',
    dcsaEventType: 'dcsaEventType',
    transportMode: 'transportMode',
    facilityType: 'facilityType',
    emptyIndicator: 'emptyIndicator',
    carrierEventId: 'carrierEventId'
  };

  export type ContainerEventScalarFieldEnum = (typeof ContainerEventScalarFieldEnum)[keyof typeof ContainerEventScalarFieldEnum]


  export const ShipmentEventScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    eventType: 'eventType',
    eventDateTime: 'eventDateTime',
    documentType: 'documentType',
    source: 'source',
    sourceFileId: 'sourceFileId',
    updatedBy: 'updatedBy',
    updatedOn: 'updatedOn',
    previousBLStatus: 'previousBLStatus',
    newBLStatus: 'newBLStatus',
    notes: 'notes',
    dcsaEventType: 'dcsaEventType',
    carrierEventId: 'carrierEventId'
  };

  export type ShipmentEventScalarFieldEnum = (typeof ShipmentEventScalarFieldEnum)[keyof typeof ShipmentEventScalarFieldEnum]


  export const ACEStatusLogScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    shipmentId: 'shipmentId',
    aceDisposition: 'aceDisposition',
    aceStatus: 'aceStatus',
    previousACEStatus: 'previousACEStatus',
    holdType: 'holdType',
    pgaAgency: 'pgaAgency',
    holdReason: 'holdReason',
    eventDateTime: 'eventDateTime',
    source: 'source',
    sourceFileId: 'sourceFileId',
    updatedOn: 'updatedOn',
    notes: 'notes'
  };

  export type ACEStatusLogScalarFieldEnum = (typeof ACEStatusLogScalarFieldEnum)[keyof typeof ACEStatusLogScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    facilityName: 'facilityName',
    facilityCode: 'facilityCode',
    facilityType: 'facilityType',
    portId: 'portId',
    address: 'address',
    unLocationCode: 'unLocationCode',
    isActive: 'isActive'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const CarrierScalarFieldEnum: {
    carrierName: 'carrierName',
    scac: 'scac',
    shortName: 'shortName',
    trackingURL: 'trackingURL',
    isActive: 'isActive',
    dcsaCompliant: 'dcsaCompliant',
    apiEndpoint: 'apiEndpoint',
    apiCredentialRef: 'apiCredentialRef'
  };

  export type CarrierScalarFieldEnum = (typeof CarrierScalarFieldEnum)[keyof typeof CarrierScalarFieldEnum]


  export const PortScalarFieldEnum: {
    portName: 'portName',
    portCode: 'portCode',
    country: 'country',
    countryCode: 'countryCode',
    region: 'region',
    defaultFreeDays: 'defaultFreeDays',
    isActive: 'isActive',
    acePortCode: 'acePortCode',
    cbpDistrict: 'cbpDistrict'
  };

  export type PortScalarFieldEnum = (typeof PortScalarFieldEnum)[keyof typeof PortScalarFieldEnum]


  export const ForwarderScalarFieldEnum: {
    forwarderName: 'forwarderName',
    shortName: 'shortName',
    contactName: 'contactName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    notes: 'notes',
    isActive: 'isActive',
    customsBroker: 'customsBroker',
    aceFilerCode: 'aceFilerCode'
  };

  export type ForwarderScalarFieldEnum = (typeof ForwarderScalarFieldEnum)[keyof typeof ForwarderScalarFieldEnum]


  export const DemurrageRateScalarFieldEnum: {
    name: 'name',
    carrierId: 'carrierId',
    portId: 'portId',
    containerType: 'containerType',
    freeDays: 'freeDays',
    dailyRate: 'dailyRate',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    notes: 'notes'
  };

  export type DemurrageRateScalarFieldEnum = (typeof DemurrageRateScalarFieldEnum)[keyof typeof DemurrageRateScalarFieldEnum]


  export const CarrierFormatScalarFieldEnum: {
    formatName: 'formatName',
    carrierId: 'carrierId',
    formatType: 'formatType',
    columnMapping: 'columnMapping',
    sampleHeaders: 'sampleHeaders',
    isActive: 'isActive',
    notes: 'notes'
  };

  export type CarrierFormatScalarFieldEnum = (typeof CarrierFormatScalarFieldEnum)[keyof typeof CarrierFormatScalarFieldEnum]


  export const DCSAEventMapScalarFieldEnum: {
    name: 'name',
    carrierId: 'carrierId',
    sourceEventCode: 'sourceEventCode',
    sourceEventName: 'sourceEventName',
    dcsaEventType: 'dcsaEventType',
    transitStageName: 'transitStageName',
    eventCategory: 'eventCategory',
    notes: 'notes',
    isActive: 'isActive'
  };

  export type DCSAEventMapScalarFieldEnum = (typeof DCSAEventMapScalarFieldEnum)[keyof typeof DCSAEventMapScalarFieldEnum]


  export const AttentionFlagScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    reason: 'reason',
    priority: 'priority',
    flaggedBy: 'flaggedBy',
    flaggedOn: 'flaggedOn',
    owner: 'owner',
    notes: 'notes',
    resolved: 'resolved',
    resolvedBy: 'resolvedBy',
    resolvedDate: 'resolvedDate',
    resolutionNote: 'resolutionNote'
  };

  export type AttentionFlagScalarFieldEnum = (typeof AttentionFlagScalarFieldEnum)[keyof typeof AttentionFlagScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    shipmentId: 'shipmentId',
    action: 'action',
    actor: 'actor',
    detail: 'detail',
    source: 'source',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const StatusOverrideScalarFieldEnum: {
    id: 'id',
    containerNumber: 'containerNumber',
    previousStatus: 'previousStatus',
    newStatus: 'newStatus',
    reason: 'reason',
    overriddenBy: 'overriddenBy',
    overriddenAt: 'overriddenAt'
  };

  export type StatusOverrideScalarFieldEnum = (typeof StatusOverrideScalarFieldEnum)[keyof typeof StatusOverrideScalarFieldEnum]


  export const RiskAssessmentScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    riskScore: 'riskScore',
    riskFactors: 'riskFactors',
    recommendations: 'recommendations',
    lastUpdated: 'lastUpdated'
  };

  export type RiskAssessmentScalarFieldEnum = (typeof RiskAssessmentScalarFieldEnum)[keyof typeof RiskAssessmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ImportLogWhereInput = {
    AND?: ImportLogWhereInput | ImportLogWhereInput[]
    OR?: ImportLogWhereInput[]
    NOT?: ImportLogWhereInput | ImportLogWhereInput[]
    fileName?: StringFilter<"ImportLog"> | string
    fileURL?: StringNullableFilter<"ImportLog"> | string | null
    importedBy?: StringNullableFilter<"ImportLog"> | string | null
    importedOn?: DateTimeFilter<"ImportLog"> | Date | string
    rowsProcessed?: IntFilter<"ImportLog"> | number
    rowsSucceeded?: IntFilter<"ImportLog"> | number
    rowsFailed?: IntFilter<"ImportLog"> | number
    carrierFormatId?: StringNullableFilter<"ImportLog"> | string | null
    importType?: StringNullableFilter<"ImportLog"> | string | null
    status?: StringFilter<"ImportLog"> | string
    errorLog?: StringNullableFilter<"ImportLog"> | string | null
    aiAnalysis?: JsonNullableFilter<"ImportLog">
    aiAnalyzedAt?: DateTimeNullableFilter<"ImportLog"> | Date | string | null
    aceStatusLogs?: ACEStatusLogListRelationFilter
    containerEvents?: ContainerEventListRelationFilter
    carrierFormat?: XOR<CarrierFormatNullableRelationFilter, CarrierFormatWhereInput> | null
    rawRows?: RawRowListRelationFilter
    shipmentEvents?: ShipmentEventListRelationFilter
  }

  export type ImportLogOrderByWithRelationInput = {
    fileName?: SortOrder
    fileURL?: SortOrderInput | SortOrder
    importedBy?: SortOrderInput | SortOrder
    importedOn?: SortOrder
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
    carrierFormatId?: SortOrderInput | SortOrder
    importType?: SortOrderInput | SortOrder
    status?: SortOrder
    errorLog?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    aiAnalyzedAt?: SortOrderInput | SortOrder
    aceStatusLogs?: ACEStatusLogOrderByRelationAggregateInput
    containerEvents?: ContainerEventOrderByRelationAggregateInput
    carrierFormat?: CarrierFormatOrderByWithRelationInput
    rawRows?: RawRowOrderByRelationAggregateInput
    shipmentEvents?: ShipmentEventOrderByRelationAggregateInput
  }

  export type ImportLogWhereUniqueInput = Prisma.AtLeast<{
    fileName?: string
    AND?: ImportLogWhereInput | ImportLogWhereInput[]
    OR?: ImportLogWhereInput[]
    NOT?: ImportLogWhereInput | ImportLogWhereInput[]
    fileURL?: StringNullableFilter<"ImportLog"> | string | null
    importedBy?: StringNullableFilter<"ImportLog"> | string | null
    importedOn?: DateTimeFilter<"ImportLog"> | Date | string
    rowsProcessed?: IntFilter<"ImportLog"> | number
    rowsSucceeded?: IntFilter<"ImportLog"> | number
    rowsFailed?: IntFilter<"ImportLog"> | number
    carrierFormatId?: StringNullableFilter<"ImportLog"> | string | null
    importType?: StringNullableFilter<"ImportLog"> | string | null
    status?: StringFilter<"ImportLog"> | string
    errorLog?: StringNullableFilter<"ImportLog"> | string | null
    aiAnalysis?: JsonNullableFilter<"ImportLog">
    aiAnalyzedAt?: DateTimeNullableFilter<"ImportLog"> | Date | string | null
    aceStatusLogs?: ACEStatusLogListRelationFilter
    containerEvents?: ContainerEventListRelationFilter
    carrierFormat?: XOR<CarrierFormatNullableRelationFilter, CarrierFormatWhereInput> | null
    rawRows?: RawRowListRelationFilter
    shipmentEvents?: ShipmentEventListRelationFilter
  }, "fileName">

  export type ImportLogOrderByWithAggregationInput = {
    fileName?: SortOrder
    fileURL?: SortOrderInput | SortOrder
    importedBy?: SortOrderInput | SortOrder
    importedOn?: SortOrder
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
    carrierFormatId?: SortOrderInput | SortOrder
    importType?: SortOrderInput | SortOrder
    status?: SortOrder
    errorLog?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    aiAnalyzedAt?: SortOrderInput | SortOrder
    _count?: ImportLogCountOrderByAggregateInput
    _avg?: ImportLogAvgOrderByAggregateInput
    _max?: ImportLogMaxOrderByAggregateInput
    _min?: ImportLogMinOrderByAggregateInput
    _sum?: ImportLogSumOrderByAggregateInput
  }

  export type ImportLogScalarWhereWithAggregatesInput = {
    AND?: ImportLogScalarWhereWithAggregatesInput | ImportLogScalarWhereWithAggregatesInput[]
    OR?: ImportLogScalarWhereWithAggregatesInput[]
    NOT?: ImportLogScalarWhereWithAggregatesInput | ImportLogScalarWhereWithAggregatesInput[]
    fileName?: StringWithAggregatesFilter<"ImportLog"> | string
    fileURL?: StringNullableWithAggregatesFilter<"ImportLog"> | string | null
    importedBy?: StringNullableWithAggregatesFilter<"ImportLog"> | string | null
    importedOn?: DateTimeWithAggregatesFilter<"ImportLog"> | Date | string
    rowsProcessed?: IntWithAggregatesFilter<"ImportLog"> | number
    rowsSucceeded?: IntWithAggregatesFilter<"ImportLog"> | number
    rowsFailed?: IntWithAggregatesFilter<"ImportLog"> | number
    carrierFormatId?: StringNullableWithAggregatesFilter<"ImportLog"> | string | null
    importType?: StringNullableWithAggregatesFilter<"ImportLog"> | string | null
    status?: StringWithAggregatesFilter<"ImportLog"> | string
    errorLog?: StringNullableWithAggregatesFilter<"ImportLog"> | string | null
    aiAnalysis?: JsonNullableWithAggregatesFilter<"ImportLog">
    aiAnalyzedAt?: DateTimeNullableWithAggregatesFilter<"ImportLog"> | Date | string | null
  }

  export type RawRowWhereInput = {
    AND?: RawRowWhereInput | RawRowWhereInput[]
    OR?: RawRowWhereInput[]
    NOT?: RawRowWhereInput | RawRowWhereInput[]
    id?: StringFilter<"RawRow"> | string
    importLogId?: StringFilter<"RawRow"> | string
    rowNumber?: IntFilter<"RawRow"> | number
    data?: StringFilter<"RawRow"> | string
    importLog?: XOR<ImportLogRelationFilter, ImportLogWhereInput>
  }

  export type RawRowOrderByWithRelationInput = {
    id?: SortOrder
    importLogId?: SortOrder
    rowNumber?: SortOrder
    data?: SortOrder
    importLog?: ImportLogOrderByWithRelationInput
  }

  export type RawRowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RawRowWhereInput | RawRowWhereInput[]
    OR?: RawRowWhereInput[]
    NOT?: RawRowWhereInput | RawRowWhereInput[]
    importLogId?: StringFilter<"RawRow"> | string
    rowNumber?: IntFilter<"RawRow"> | number
    data?: StringFilter<"RawRow"> | string
    importLog?: XOR<ImportLogRelationFilter, ImportLogWhereInput>
  }, "id">

  export type RawRowOrderByWithAggregationInput = {
    id?: SortOrder
    importLogId?: SortOrder
    rowNumber?: SortOrder
    data?: SortOrder
    _count?: RawRowCountOrderByAggregateInput
    _avg?: RawRowAvgOrderByAggregateInput
    _max?: RawRowMaxOrderByAggregateInput
    _min?: RawRowMinOrderByAggregateInput
    _sum?: RawRowSumOrderByAggregateInput
  }

  export type RawRowScalarWhereWithAggregatesInput = {
    AND?: RawRowScalarWhereWithAggregatesInput | RawRowScalarWhereWithAggregatesInput[]
    OR?: RawRowScalarWhereWithAggregatesInput[]
    NOT?: RawRowScalarWhereWithAggregatesInput | RawRowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RawRow"> | string
    importLogId?: StringWithAggregatesFilter<"RawRow"> | string
    rowNumber?: IntWithAggregatesFilter<"RawRow"> | number
    data?: StringWithAggregatesFilter<"RawRow"> | string
  }

  export type TransitStageWhereInput = {
    AND?: TransitStageWhereInput | TransitStageWhereInput[]
    OR?: TransitStageWhereInput[]
    NOT?: TransitStageWhereInput | TransitStageWhereInput[]
    stageName?: StringFilter<"TransitStage"> | string
    stageCode?: StringNullableFilter<"TransitStage"> | string | null
    sequence?: IntFilter<"TransitStage"> | number
    category?: StringNullableFilter<"TransitStage"> | string | null
    expectedDays?: IntNullableFilter<"TransitStage"> | number | null
    alertAfterDays?: IntNullableFilter<"TransitStage"> | number | null
    responsibleTeam?: StringNullableFilter<"TransitStage"> | string | null
    isActive?: BoolFilter<"TransitStage"> | boolean
    dcsaEventType?: StringNullableFilter<"TransitStage"> | string | null
    dcsaEventCategory?: StringNullableFilter<"TransitStage"> | string | null
    dcsaFacilityType?: StringNullableFilter<"TransitStage"> | string | null
    containers?: ContainerListRelationFilter
    previousEvents?: ContainerEventListRelationFilter
    containerEvents?: ContainerEventListRelationFilter
    dcsaEventMaps?: DCSAEventMapListRelationFilter
  }

  export type TransitStageOrderByWithRelationInput = {
    stageName?: SortOrder
    stageCode?: SortOrderInput | SortOrder
    sequence?: SortOrder
    category?: SortOrderInput | SortOrder
    expectedDays?: SortOrderInput | SortOrder
    alertAfterDays?: SortOrderInput | SortOrder
    responsibleTeam?: SortOrderInput | SortOrder
    isActive?: SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    dcsaEventCategory?: SortOrderInput | SortOrder
    dcsaFacilityType?: SortOrderInput | SortOrder
    containers?: ContainerOrderByRelationAggregateInput
    previousEvents?: ContainerEventOrderByRelationAggregateInput
    containerEvents?: ContainerEventOrderByRelationAggregateInput
    dcsaEventMaps?: DCSAEventMapOrderByRelationAggregateInput
  }

  export type TransitStageWhereUniqueInput = Prisma.AtLeast<{
    stageName?: string
    AND?: TransitStageWhereInput | TransitStageWhereInput[]
    OR?: TransitStageWhereInput[]
    NOT?: TransitStageWhereInput | TransitStageWhereInput[]
    stageCode?: StringNullableFilter<"TransitStage"> | string | null
    sequence?: IntFilter<"TransitStage"> | number
    category?: StringNullableFilter<"TransitStage"> | string | null
    expectedDays?: IntNullableFilter<"TransitStage"> | number | null
    alertAfterDays?: IntNullableFilter<"TransitStage"> | number | null
    responsibleTeam?: StringNullableFilter<"TransitStage"> | string | null
    isActive?: BoolFilter<"TransitStage"> | boolean
    dcsaEventType?: StringNullableFilter<"TransitStage"> | string | null
    dcsaEventCategory?: StringNullableFilter<"TransitStage"> | string | null
    dcsaFacilityType?: StringNullableFilter<"TransitStage"> | string | null
    containers?: ContainerListRelationFilter
    previousEvents?: ContainerEventListRelationFilter
    containerEvents?: ContainerEventListRelationFilter
    dcsaEventMaps?: DCSAEventMapListRelationFilter
  }, "stageName">

  export type TransitStageOrderByWithAggregationInput = {
    stageName?: SortOrder
    stageCode?: SortOrderInput | SortOrder
    sequence?: SortOrder
    category?: SortOrderInput | SortOrder
    expectedDays?: SortOrderInput | SortOrder
    alertAfterDays?: SortOrderInput | SortOrder
    responsibleTeam?: SortOrderInput | SortOrder
    isActive?: SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    dcsaEventCategory?: SortOrderInput | SortOrder
    dcsaFacilityType?: SortOrderInput | SortOrder
    _count?: TransitStageCountOrderByAggregateInput
    _avg?: TransitStageAvgOrderByAggregateInput
    _max?: TransitStageMaxOrderByAggregateInput
    _min?: TransitStageMinOrderByAggregateInput
    _sum?: TransitStageSumOrderByAggregateInput
  }

  export type TransitStageScalarWhereWithAggregatesInput = {
    AND?: TransitStageScalarWhereWithAggregatesInput | TransitStageScalarWhereWithAggregatesInput[]
    OR?: TransitStageScalarWhereWithAggregatesInput[]
    NOT?: TransitStageScalarWhereWithAggregatesInput | TransitStageScalarWhereWithAggregatesInput[]
    stageName?: StringWithAggregatesFilter<"TransitStage"> | string
    stageCode?: StringNullableWithAggregatesFilter<"TransitStage"> | string | null
    sequence?: IntWithAggregatesFilter<"TransitStage"> | number
    category?: StringNullableWithAggregatesFilter<"TransitStage"> | string | null
    expectedDays?: IntNullableWithAggregatesFilter<"TransitStage"> | number | null
    alertAfterDays?: IntNullableWithAggregatesFilter<"TransitStage"> | number | null
    responsibleTeam?: StringNullableWithAggregatesFilter<"TransitStage"> | string | null
    isActive?: BoolWithAggregatesFilter<"TransitStage"> | boolean
    dcsaEventType?: StringNullableWithAggregatesFilter<"TransitStage"> | string | null
    dcsaEventCategory?: StringNullableWithAggregatesFilter<"TransitStage"> | string | null
    dcsaFacilityType?: StringNullableWithAggregatesFilter<"TransitStage"> | string | null
  }

  export type ShipmentWhereInput = {
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    shipmentReference?: StringFilter<"Shipment"> | string
    hbl?: StringNullableFilter<"Shipment"> | string | null
    mbl?: StringNullableFilter<"Shipment"> | string | null
    bookingReference?: StringNullableFilter<"Shipment"> | string | null
    shipmentType?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    forwarder?: StringNullableFilter<"Shipment"> | string | null
    shipper?: StringNullableFilter<"Shipment"> | string | null
    consignee?: StringNullableFilter<"Shipment"> | string | null
    pol?: StringNullableFilter<"Shipment"> | string | null
    pod?: StringNullableFilter<"Shipment"> | string | null
    finalDestination?: StringNullableFilter<"Shipment"> | string | null
    contents?: StringNullableFilter<"Shipment"> | string | null
    supplier?: StringNullableFilter<"Shipment"> | string | null
    totalWeight?: FloatNullableFilter<"Shipment"> | number | null
    totalPieces?: IntNullableFilter<"Shipment"> | number | null
    customerReference?: StringNullableFilter<"Shipment"> | string | null
    poNumber?: StringNullableFilter<"Shipment"> | string | null
    incoTerms?: StringNullableFilter<"Shipment"> | string | null
    expectedContainers?: IntNullableFilter<"Shipment"> | number | null
    blType?: StringNullableFilter<"Shipment"> | string | null
    blStatus?: StringNullableFilter<"Shipment"> | string | null
    paymentStatus?: StringNullableFilter<"Shipment"> | string | null
    paymentDueDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    amountDue?: FloatNullableFilter<"Shipment"> | number | null
    releaseStatus?: StringNullableFilter<"Shipment"> | string | null
    releaseDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    holdReason?: StringNullableFilter<"Shipment"> | string | null
    notes?: StringNullableFilter<"Shipment"> | string | null
    aceEntryNumber?: StringNullableFilter<"Shipment"> | string | null
    aceEntryType?: StringNullableFilter<"Shipment"> | string | null
    dutyAmount?: FloatNullableFilter<"Shipment"> | number | null
    liquidationStatus?: StringNullableFilter<"Shipment"> | string | null
    liquidationDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    aceStatusLogs?: ACEStatusLogListRelationFilter
    shipmentContainers?: ShipmentContainerListRelationFilter
    shipmentEvents?: ShipmentEventListRelationFilter
  }

  export type ShipmentOrderByWithRelationInput = {
    shipmentReference?: SortOrder
    hbl?: SortOrderInput | SortOrder
    mbl?: SortOrderInput | SortOrder
    bookingReference?: SortOrderInput | SortOrder
    shipmentType?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    forwarder?: SortOrderInput | SortOrder
    shipper?: SortOrderInput | SortOrder
    consignee?: SortOrderInput | SortOrder
    pol?: SortOrderInput | SortOrder
    pod?: SortOrderInput | SortOrder
    finalDestination?: SortOrderInput | SortOrder
    contents?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    totalWeight?: SortOrderInput | SortOrder
    totalPieces?: SortOrderInput | SortOrder
    customerReference?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    incoTerms?: SortOrderInput | SortOrder
    expectedContainers?: SortOrderInput | SortOrder
    blType?: SortOrderInput | SortOrder
    blStatus?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    releaseStatus?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    holdReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    aceEntryNumber?: SortOrderInput | SortOrder
    aceEntryType?: SortOrderInput | SortOrder
    dutyAmount?: SortOrderInput | SortOrder
    liquidationStatus?: SortOrderInput | SortOrder
    liquidationDate?: SortOrderInput | SortOrder
    aceStatusLogs?: ACEStatusLogOrderByRelationAggregateInput
    shipmentContainers?: ShipmentContainerOrderByRelationAggregateInput
    shipmentEvents?: ShipmentEventOrderByRelationAggregateInput
  }

  export type ShipmentWhereUniqueInput = Prisma.AtLeast<{
    shipmentReference?: string
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    hbl?: StringNullableFilter<"Shipment"> | string | null
    mbl?: StringNullableFilter<"Shipment"> | string | null
    bookingReference?: StringNullableFilter<"Shipment"> | string | null
    shipmentType?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    forwarder?: StringNullableFilter<"Shipment"> | string | null
    shipper?: StringNullableFilter<"Shipment"> | string | null
    consignee?: StringNullableFilter<"Shipment"> | string | null
    pol?: StringNullableFilter<"Shipment"> | string | null
    pod?: StringNullableFilter<"Shipment"> | string | null
    finalDestination?: StringNullableFilter<"Shipment"> | string | null
    contents?: StringNullableFilter<"Shipment"> | string | null
    supplier?: StringNullableFilter<"Shipment"> | string | null
    totalWeight?: FloatNullableFilter<"Shipment"> | number | null
    totalPieces?: IntNullableFilter<"Shipment"> | number | null
    customerReference?: StringNullableFilter<"Shipment"> | string | null
    poNumber?: StringNullableFilter<"Shipment"> | string | null
    incoTerms?: StringNullableFilter<"Shipment"> | string | null
    expectedContainers?: IntNullableFilter<"Shipment"> | number | null
    blType?: StringNullableFilter<"Shipment"> | string | null
    blStatus?: StringNullableFilter<"Shipment"> | string | null
    paymentStatus?: StringNullableFilter<"Shipment"> | string | null
    paymentDueDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    amountDue?: FloatNullableFilter<"Shipment"> | number | null
    releaseStatus?: StringNullableFilter<"Shipment"> | string | null
    releaseDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    holdReason?: StringNullableFilter<"Shipment"> | string | null
    notes?: StringNullableFilter<"Shipment"> | string | null
    aceEntryNumber?: StringNullableFilter<"Shipment"> | string | null
    aceEntryType?: StringNullableFilter<"Shipment"> | string | null
    dutyAmount?: FloatNullableFilter<"Shipment"> | number | null
    liquidationStatus?: StringNullableFilter<"Shipment"> | string | null
    liquidationDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    aceStatusLogs?: ACEStatusLogListRelationFilter
    shipmentContainers?: ShipmentContainerListRelationFilter
    shipmentEvents?: ShipmentEventListRelationFilter
  }, "shipmentReference">

  export type ShipmentOrderByWithAggregationInput = {
    shipmentReference?: SortOrder
    hbl?: SortOrderInput | SortOrder
    mbl?: SortOrderInput | SortOrder
    bookingReference?: SortOrderInput | SortOrder
    shipmentType?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    forwarder?: SortOrderInput | SortOrder
    shipper?: SortOrderInput | SortOrder
    consignee?: SortOrderInput | SortOrder
    pol?: SortOrderInput | SortOrder
    pod?: SortOrderInput | SortOrder
    finalDestination?: SortOrderInput | SortOrder
    contents?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    totalWeight?: SortOrderInput | SortOrder
    totalPieces?: SortOrderInput | SortOrder
    customerReference?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    incoTerms?: SortOrderInput | SortOrder
    expectedContainers?: SortOrderInput | SortOrder
    blType?: SortOrderInput | SortOrder
    blStatus?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    releaseStatus?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    holdReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    aceEntryNumber?: SortOrderInput | SortOrder
    aceEntryType?: SortOrderInput | SortOrder
    dutyAmount?: SortOrderInput | SortOrder
    liquidationStatus?: SortOrderInput | SortOrder
    liquidationDate?: SortOrderInput | SortOrder
    _count?: ShipmentCountOrderByAggregateInput
    _avg?: ShipmentAvgOrderByAggregateInput
    _max?: ShipmentMaxOrderByAggregateInput
    _min?: ShipmentMinOrderByAggregateInput
    _sum?: ShipmentSumOrderByAggregateInput
  }

  export type ShipmentScalarWhereWithAggregatesInput = {
    AND?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    OR?: ShipmentScalarWhereWithAggregatesInput[]
    NOT?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    shipmentReference?: StringWithAggregatesFilter<"Shipment"> | string
    hbl?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    mbl?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    bookingReference?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    shipmentType?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    forwarder?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    shipper?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    consignee?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    pol?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    pod?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    finalDestination?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    contents?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    supplier?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    totalWeight?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    totalPieces?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    customerReference?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    poNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    incoTerms?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    expectedContainers?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    blType?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    blStatus?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    paymentStatus?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    paymentDueDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    amountDue?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    releaseStatus?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    holdReason?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    aceEntryNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    aceEntryType?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    dutyAmount?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    liquidationStatus?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    liquidationDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
  }

  export type ContainerWhereInput = {
    AND?: ContainerWhereInput | ContainerWhereInput[]
    OR?: ContainerWhereInput[]
    NOT?: ContainerWhereInput | ContainerWhereInput[]
    containerNumber?: StringFilter<"Container"> | string
    containerType?: StringNullableFilter<"Container"> | string | null
    currentStatus?: StringNullableFilter<"Container"> | string | null
    currentLocation?: StringNullableFilter<"Container"> | string | null
    currentVessel?: StringNullableFilter<"Container"> | string | null
    currentVoyage?: StringNullableFilter<"Container"> | string | null
    mbl?: StringNullableFilter<"Container"> | string | null
    carrier?: StringNullableFilter<"Container"> | string | null
    pol?: StringNullableFilter<"Container"> | string | null
    pod?: StringNullableFilter<"Container"> | string | null
    etd?: DateTimeNullableFilter<"Container"> | Date | string | null
    atd?: DateTimeNullableFilter<"Container"> | Date | string | null
    eta?: DateTimeNullableFilter<"Container"> | Date | string | null
    ata?: DateTimeNullableFilter<"Container"> | Date | string | null
    lastFreeDay?: DateTimeNullableFilter<"Container"> | Date | string | null
    detentionFreeDay?: DateTimeNullableFilter<"Container"> | Date | string | null
    statusLastUpdated?: DateTimeNullableFilter<"Container"> | Date | string | null
    hasException?: BoolFilter<"Container"> | boolean
    exceptionType?: StringNullableFilter<"Container"> | string | null
    exceptionOwner?: StringNullableFilter<"Container"> | string | null
    exceptionNotes?: StringNullableFilter<"Container"> | string | null
    exceptionDate?: DateTimeNullableFilter<"Container"> | Date | string | null
    manualPriority?: StringNullableFilter<"Container"> | string | null
    priorityReason?: StringNullableFilter<"Container"> | string | null
    prioritySetBy?: StringNullableFilter<"Container"> | string | null
    prioritySetDate?: DateTimeNullableFilter<"Container"> | Date | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    emptyIndicator?: BoolNullableFilter<"Container"> | boolean | null
    sealNumber?: StringNullableFilter<"Container"> | string | null
    grossWeight?: FloatNullableFilter<"Container"> | number | null
    carrierEventId?: StringNullableFilter<"Container"> | string | null
    aceEntryNumber?: StringNullableFilter<"Container"> | string | null
    aceDisposition?: StringNullableFilter<"Container"> | string | null
    aceStatus?: StringNullableFilter<"Container"> | string | null
    aceLastUpdated?: DateTimeNullableFilter<"Container"> | Date | string | null
    pgaHold?: BoolNullableFilter<"Container"> | boolean | null
    pgaAgency?: StringNullableFilter<"Container"> | string | null
    pgaHoldReason?: StringNullableFilter<"Container"> | string | null
    createdAt?: DateTimeFilter<"Container"> | Date | string
    updatedAt?: DateTimeFilter<"Container"> | Date | string
    aceStatusLogs?: ACEStatusLogListRelationFilter
    stage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    events?: ContainerEventListRelationFilter
    shipmentContainers?: ShipmentContainerListRelationFilter
    attentionFlags?: AttentionFlagListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    statusOverrides?: StatusOverrideListRelationFilter
    riskAssessment?: XOR<RiskAssessmentNullableRelationFilter, RiskAssessmentWhereInput> | null
  }

  export type ContainerOrderByWithRelationInput = {
    containerNumber?: SortOrder
    containerType?: SortOrderInput | SortOrder
    currentStatus?: SortOrderInput | SortOrder
    currentLocation?: SortOrderInput | SortOrder
    currentVessel?: SortOrderInput | SortOrder
    currentVoyage?: SortOrderInput | SortOrder
    mbl?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    pol?: SortOrderInput | SortOrder
    pod?: SortOrderInput | SortOrder
    etd?: SortOrderInput | SortOrder
    atd?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    ata?: SortOrderInput | SortOrder
    lastFreeDay?: SortOrderInput | SortOrder
    detentionFreeDay?: SortOrderInput | SortOrder
    statusLastUpdated?: SortOrderInput | SortOrder
    hasException?: SortOrder
    exceptionType?: SortOrderInput | SortOrder
    exceptionOwner?: SortOrderInput | SortOrder
    exceptionNotes?: SortOrderInput | SortOrder
    exceptionDate?: SortOrderInput | SortOrder
    manualPriority?: SortOrderInput | SortOrder
    priorityReason?: SortOrderInput | SortOrder
    prioritySetBy?: SortOrderInput | SortOrder
    prioritySetDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    emptyIndicator?: SortOrderInput | SortOrder
    sealNumber?: SortOrderInput | SortOrder
    grossWeight?: SortOrderInput | SortOrder
    carrierEventId?: SortOrderInput | SortOrder
    aceEntryNumber?: SortOrderInput | SortOrder
    aceDisposition?: SortOrderInput | SortOrder
    aceStatus?: SortOrderInput | SortOrder
    aceLastUpdated?: SortOrderInput | SortOrder
    pgaHold?: SortOrderInput | SortOrder
    pgaAgency?: SortOrderInput | SortOrder
    pgaHoldReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aceStatusLogs?: ACEStatusLogOrderByRelationAggregateInput
    stage?: TransitStageOrderByWithRelationInput
    events?: ContainerEventOrderByRelationAggregateInput
    shipmentContainers?: ShipmentContainerOrderByRelationAggregateInput
    attentionFlags?: AttentionFlagOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    statusOverrides?: StatusOverrideOrderByRelationAggregateInput
    riskAssessment?: RiskAssessmentOrderByWithRelationInput
  }

  export type ContainerWhereUniqueInput = Prisma.AtLeast<{
    containerNumber?: string
    AND?: ContainerWhereInput | ContainerWhereInput[]
    OR?: ContainerWhereInput[]
    NOT?: ContainerWhereInput | ContainerWhereInput[]
    containerType?: StringNullableFilter<"Container"> | string | null
    currentStatus?: StringNullableFilter<"Container"> | string | null
    currentLocation?: StringNullableFilter<"Container"> | string | null
    currentVessel?: StringNullableFilter<"Container"> | string | null
    currentVoyage?: StringNullableFilter<"Container"> | string | null
    mbl?: StringNullableFilter<"Container"> | string | null
    carrier?: StringNullableFilter<"Container"> | string | null
    pol?: StringNullableFilter<"Container"> | string | null
    pod?: StringNullableFilter<"Container"> | string | null
    etd?: DateTimeNullableFilter<"Container"> | Date | string | null
    atd?: DateTimeNullableFilter<"Container"> | Date | string | null
    eta?: DateTimeNullableFilter<"Container"> | Date | string | null
    ata?: DateTimeNullableFilter<"Container"> | Date | string | null
    lastFreeDay?: DateTimeNullableFilter<"Container"> | Date | string | null
    detentionFreeDay?: DateTimeNullableFilter<"Container"> | Date | string | null
    statusLastUpdated?: DateTimeNullableFilter<"Container"> | Date | string | null
    hasException?: BoolFilter<"Container"> | boolean
    exceptionType?: StringNullableFilter<"Container"> | string | null
    exceptionOwner?: StringNullableFilter<"Container"> | string | null
    exceptionNotes?: StringNullableFilter<"Container"> | string | null
    exceptionDate?: DateTimeNullableFilter<"Container"> | Date | string | null
    manualPriority?: StringNullableFilter<"Container"> | string | null
    priorityReason?: StringNullableFilter<"Container"> | string | null
    prioritySetBy?: StringNullableFilter<"Container"> | string | null
    prioritySetDate?: DateTimeNullableFilter<"Container"> | Date | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    emptyIndicator?: BoolNullableFilter<"Container"> | boolean | null
    sealNumber?: StringNullableFilter<"Container"> | string | null
    grossWeight?: FloatNullableFilter<"Container"> | number | null
    carrierEventId?: StringNullableFilter<"Container"> | string | null
    aceEntryNumber?: StringNullableFilter<"Container"> | string | null
    aceDisposition?: StringNullableFilter<"Container"> | string | null
    aceStatus?: StringNullableFilter<"Container"> | string | null
    aceLastUpdated?: DateTimeNullableFilter<"Container"> | Date | string | null
    pgaHold?: BoolNullableFilter<"Container"> | boolean | null
    pgaAgency?: StringNullableFilter<"Container"> | string | null
    pgaHoldReason?: StringNullableFilter<"Container"> | string | null
    createdAt?: DateTimeFilter<"Container"> | Date | string
    updatedAt?: DateTimeFilter<"Container"> | Date | string
    aceStatusLogs?: ACEStatusLogListRelationFilter
    stage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    events?: ContainerEventListRelationFilter
    shipmentContainers?: ShipmentContainerListRelationFilter
    attentionFlags?: AttentionFlagListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    statusOverrides?: StatusOverrideListRelationFilter
    riskAssessment?: XOR<RiskAssessmentNullableRelationFilter, RiskAssessmentWhereInput> | null
  }, "containerNumber">

  export type ContainerOrderByWithAggregationInput = {
    containerNumber?: SortOrder
    containerType?: SortOrderInput | SortOrder
    currentStatus?: SortOrderInput | SortOrder
    currentLocation?: SortOrderInput | SortOrder
    currentVessel?: SortOrderInput | SortOrder
    currentVoyage?: SortOrderInput | SortOrder
    mbl?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    pol?: SortOrderInput | SortOrder
    pod?: SortOrderInput | SortOrder
    etd?: SortOrderInput | SortOrder
    atd?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    ata?: SortOrderInput | SortOrder
    lastFreeDay?: SortOrderInput | SortOrder
    detentionFreeDay?: SortOrderInput | SortOrder
    statusLastUpdated?: SortOrderInput | SortOrder
    hasException?: SortOrder
    exceptionType?: SortOrderInput | SortOrder
    exceptionOwner?: SortOrderInput | SortOrder
    exceptionNotes?: SortOrderInput | SortOrder
    exceptionDate?: SortOrderInput | SortOrder
    manualPriority?: SortOrderInput | SortOrder
    priorityReason?: SortOrderInput | SortOrder
    prioritySetBy?: SortOrderInput | SortOrder
    prioritySetDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    emptyIndicator?: SortOrderInput | SortOrder
    sealNumber?: SortOrderInput | SortOrder
    grossWeight?: SortOrderInput | SortOrder
    carrierEventId?: SortOrderInput | SortOrder
    aceEntryNumber?: SortOrderInput | SortOrder
    aceDisposition?: SortOrderInput | SortOrder
    aceStatus?: SortOrderInput | SortOrder
    aceLastUpdated?: SortOrderInput | SortOrder
    pgaHold?: SortOrderInput | SortOrder
    pgaAgency?: SortOrderInput | SortOrder
    pgaHoldReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContainerCountOrderByAggregateInput
    _avg?: ContainerAvgOrderByAggregateInput
    _max?: ContainerMaxOrderByAggregateInput
    _min?: ContainerMinOrderByAggregateInput
    _sum?: ContainerSumOrderByAggregateInput
  }

  export type ContainerScalarWhereWithAggregatesInput = {
    AND?: ContainerScalarWhereWithAggregatesInput | ContainerScalarWhereWithAggregatesInput[]
    OR?: ContainerScalarWhereWithAggregatesInput[]
    NOT?: ContainerScalarWhereWithAggregatesInput | ContainerScalarWhereWithAggregatesInput[]
    containerNumber?: StringWithAggregatesFilter<"Container"> | string
    containerType?: StringNullableWithAggregatesFilter<"Container"> | string | null
    currentStatus?: StringNullableWithAggregatesFilter<"Container"> | string | null
    currentLocation?: StringNullableWithAggregatesFilter<"Container"> | string | null
    currentVessel?: StringNullableWithAggregatesFilter<"Container"> | string | null
    currentVoyage?: StringNullableWithAggregatesFilter<"Container"> | string | null
    mbl?: StringNullableWithAggregatesFilter<"Container"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"Container"> | string | null
    pol?: StringNullableWithAggregatesFilter<"Container"> | string | null
    pod?: StringNullableWithAggregatesFilter<"Container"> | string | null
    etd?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    atd?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    eta?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    ata?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    lastFreeDay?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    detentionFreeDay?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    statusLastUpdated?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    hasException?: BoolWithAggregatesFilter<"Container"> | boolean
    exceptionType?: StringNullableWithAggregatesFilter<"Container"> | string | null
    exceptionOwner?: StringNullableWithAggregatesFilter<"Container"> | string | null
    exceptionNotes?: StringNullableWithAggregatesFilter<"Container"> | string | null
    exceptionDate?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    manualPriority?: StringNullableWithAggregatesFilter<"Container"> | string | null
    priorityReason?: StringNullableWithAggregatesFilter<"Container"> | string | null
    prioritySetBy?: StringNullableWithAggregatesFilter<"Container"> | string | null
    prioritySetDate?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Container"> | string | null
    emptyIndicator?: BoolNullableWithAggregatesFilter<"Container"> | boolean | null
    sealNumber?: StringNullableWithAggregatesFilter<"Container"> | string | null
    grossWeight?: FloatNullableWithAggregatesFilter<"Container"> | number | null
    carrierEventId?: StringNullableWithAggregatesFilter<"Container"> | string | null
    aceEntryNumber?: StringNullableWithAggregatesFilter<"Container"> | string | null
    aceDisposition?: StringNullableWithAggregatesFilter<"Container"> | string | null
    aceStatus?: StringNullableWithAggregatesFilter<"Container"> | string | null
    aceLastUpdated?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    pgaHold?: BoolNullableWithAggregatesFilter<"Container"> | boolean | null
    pgaAgency?: StringNullableWithAggregatesFilter<"Container"> | string | null
    pgaHoldReason?: StringNullableWithAggregatesFilter<"Container"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Container"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Container"> | Date | string
  }

  export type ShipmentContainerWhereInput = {
    AND?: ShipmentContainerWhereInput | ShipmentContainerWhereInput[]
    OR?: ShipmentContainerWhereInput[]
    NOT?: ShipmentContainerWhereInput | ShipmentContainerWhereInput[]
    id?: StringFilter<"ShipmentContainer"> | string
    shipmentId?: StringFilter<"ShipmentContainer"> | string
    containerId?: StringFilter<"ShipmentContainer"> | string
    piecesInContainer?: IntNullableFilter<"ShipmentContainer"> | number | null
    weightInContainer?: FloatNullableFilter<"ShipmentContainer"> | number | null
    notes?: StringNullableFilter<"ShipmentContainer"> | string | null
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
  }

  export type ShipmentContainerOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    containerId?: SortOrder
    piecesInContainer?: SortOrderInput | SortOrder
    weightInContainer?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    container?: ContainerOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
  }

  export type ShipmentContainerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShipmentContainerWhereInput | ShipmentContainerWhereInput[]
    OR?: ShipmentContainerWhereInput[]
    NOT?: ShipmentContainerWhereInput | ShipmentContainerWhereInput[]
    shipmentId?: StringFilter<"ShipmentContainer"> | string
    containerId?: StringFilter<"ShipmentContainer"> | string
    piecesInContainer?: IntNullableFilter<"ShipmentContainer"> | number | null
    weightInContainer?: FloatNullableFilter<"ShipmentContainer"> | number | null
    notes?: StringNullableFilter<"ShipmentContainer"> | string | null
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
  }, "id">

  export type ShipmentContainerOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    containerId?: SortOrder
    piecesInContainer?: SortOrderInput | SortOrder
    weightInContainer?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ShipmentContainerCountOrderByAggregateInput
    _avg?: ShipmentContainerAvgOrderByAggregateInput
    _max?: ShipmentContainerMaxOrderByAggregateInput
    _min?: ShipmentContainerMinOrderByAggregateInput
    _sum?: ShipmentContainerSumOrderByAggregateInput
  }

  export type ShipmentContainerScalarWhereWithAggregatesInput = {
    AND?: ShipmentContainerScalarWhereWithAggregatesInput | ShipmentContainerScalarWhereWithAggregatesInput[]
    OR?: ShipmentContainerScalarWhereWithAggregatesInput[]
    NOT?: ShipmentContainerScalarWhereWithAggregatesInput | ShipmentContainerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShipmentContainer"> | string
    shipmentId?: StringWithAggregatesFilter<"ShipmentContainer"> | string
    containerId?: StringWithAggregatesFilter<"ShipmentContainer"> | string
    piecesInContainer?: IntNullableWithAggregatesFilter<"ShipmentContainer"> | number | null
    weightInContainer?: FloatNullableWithAggregatesFilter<"ShipmentContainer"> | number | null
    notes?: StringNullableWithAggregatesFilter<"ShipmentContainer"> | string | null
  }

  export type ContainerEventWhereInput = {
    AND?: ContainerEventWhereInput | ContainerEventWhereInput[]
    OR?: ContainerEventWhereInput[]
    NOT?: ContainerEventWhereInput | ContainerEventWhereInput[]
    id?: StringFilter<"ContainerEvent"> | string
    containerId?: StringFilter<"ContainerEvent"> | string
    stageName?: StringNullableFilter<"ContainerEvent"> | string | null
    eventDateTime?: DateTimeFilter<"ContainerEvent"> | Date | string
    location?: StringNullableFilter<"ContainerEvent"> | string | null
    facilityId?: StringNullableFilter<"ContainerEvent"> | string | null
    vessel?: StringNullableFilter<"ContainerEvent"> | string | null
    voyage?: StringNullableFilter<"ContainerEvent"> | string | null
    source?: StringNullableFilter<"ContainerEvent"> | string | null
    sourceFileId?: StringNullableFilter<"ContainerEvent"> | string | null
    updatedBy?: StringNullableFilter<"ContainerEvent"> | string | null
    updatedOn?: DateTimeNullableFilter<"ContainerEvent"> | Date | string | null
    previousStatus?: StringNullableFilter<"ContainerEvent"> | string | null
    exceptionCleared?: BoolNullableFilter<"ContainerEvent"> | boolean | null
    notes?: StringNullableFilter<"ContainerEvent"> | string | null
    eventCategory?: StringNullableFilter<"ContainerEvent"> | string | null
    eventClassifier?: StringNullableFilter<"ContainerEvent"> | string | null
    dcsaEventType?: StringNullableFilter<"ContainerEvent"> | string | null
    transportMode?: StringNullableFilter<"ContainerEvent"> | string | null
    facilityType?: StringNullableFilter<"ContainerEvent"> | string | null
    emptyIndicator?: BoolNullableFilter<"ContainerEvent"> | boolean | null
    carrierEventId?: StringNullableFilter<"ContainerEvent"> | string | null
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    importLog?: XOR<ImportLogNullableRelationFilter, ImportLogWhereInput> | null
    previousStage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    stage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }

  export type ContainerEventOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrder
    stageName?: SortOrderInput | SortOrder
    eventDateTime?: SortOrder
    location?: SortOrderInput | SortOrder
    facilityId?: SortOrderInput | SortOrder
    vessel?: SortOrderInput | SortOrder
    voyage?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceFileId?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedOn?: SortOrderInput | SortOrder
    previousStatus?: SortOrderInput | SortOrder
    exceptionCleared?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    eventCategory?: SortOrderInput | SortOrder
    eventClassifier?: SortOrderInput | SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    transportMode?: SortOrderInput | SortOrder
    facilityType?: SortOrderInput | SortOrder
    emptyIndicator?: SortOrderInput | SortOrder
    carrierEventId?: SortOrderInput | SortOrder
    facility?: FacilityOrderByWithRelationInput
    importLog?: ImportLogOrderByWithRelationInput
    previousStage?: TransitStageOrderByWithRelationInput
    stage?: TransitStageOrderByWithRelationInput
    container?: ContainerOrderByWithRelationInput
  }

  export type ContainerEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContainerEventWhereInput | ContainerEventWhereInput[]
    OR?: ContainerEventWhereInput[]
    NOT?: ContainerEventWhereInput | ContainerEventWhereInput[]
    containerId?: StringFilter<"ContainerEvent"> | string
    stageName?: StringNullableFilter<"ContainerEvent"> | string | null
    eventDateTime?: DateTimeFilter<"ContainerEvent"> | Date | string
    location?: StringNullableFilter<"ContainerEvent"> | string | null
    facilityId?: StringNullableFilter<"ContainerEvent"> | string | null
    vessel?: StringNullableFilter<"ContainerEvent"> | string | null
    voyage?: StringNullableFilter<"ContainerEvent"> | string | null
    source?: StringNullableFilter<"ContainerEvent"> | string | null
    sourceFileId?: StringNullableFilter<"ContainerEvent"> | string | null
    updatedBy?: StringNullableFilter<"ContainerEvent"> | string | null
    updatedOn?: DateTimeNullableFilter<"ContainerEvent"> | Date | string | null
    previousStatus?: StringNullableFilter<"ContainerEvent"> | string | null
    exceptionCleared?: BoolNullableFilter<"ContainerEvent"> | boolean | null
    notes?: StringNullableFilter<"ContainerEvent"> | string | null
    eventCategory?: StringNullableFilter<"ContainerEvent"> | string | null
    eventClassifier?: StringNullableFilter<"ContainerEvent"> | string | null
    dcsaEventType?: StringNullableFilter<"ContainerEvent"> | string | null
    transportMode?: StringNullableFilter<"ContainerEvent"> | string | null
    facilityType?: StringNullableFilter<"ContainerEvent"> | string | null
    emptyIndicator?: BoolNullableFilter<"ContainerEvent"> | boolean | null
    carrierEventId?: StringNullableFilter<"ContainerEvent"> | string | null
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    importLog?: XOR<ImportLogNullableRelationFilter, ImportLogWhereInput> | null
    previousStage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    stage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }, "id">

  export type ContainerEventOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrder
    stageName?: SortOrderInput | SortOrder
    eventDateTime?: SortOrder
    location?: SortOrderInput | SortOrder
    facilityId?: SortOrderInput | SortOrder
    vessel?: SortOrderInput | SortOrder
    voyage?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceFileId?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedOn?: SortOrderInput | SortOrder
    previousStatus?: SortOrderInput | SortOrder
    exceptionCleared?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    eventCategory?: SortOrderInput | SortOrder
    eventClassifier?: SortOrderInput | SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    transportMode?: SortOrderInput | SortOrder
    facilityType?: SortOrderInput | SortOrder
    emptyIndicator?: SortOrderInput | SortOrder
    carrierEventId?: SortOrderInput | SortOrder
    _count?: ContainerEventCountOrderByAggregateInput
    _max?: ContainerEventMaxOrderByAggregateInput
    _min?: ContainerEventMinOrderByAggregateInput
  }

  export type ContainerEventScalarWhereWithAggregatesInput = {
    AND?: ContainerEventScalarWhereWithAggregatesInput | ContainerEventScalarWhereWithAggregatesInput[]
    OR?: ContainerEventScalarWhereWithAggregatesInput[]
    NOT?: ContainerEventScalarWhereWithAggregatesInput | ContainerEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContainerEvent"> | string
    containerId?: StringWithAggregatesFilter<"ContainerEvent"> | string
    stageName?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    eventDateTime?: DateTimeWithAggregatesFilter<"ContainerEvent"> | Date | string
    location?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    facilityId?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    vessel?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    voyage?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    source?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    sourceFileId?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    updatedOn?: DateTimeNullableWithAggregatesFilter<"ContainerEvent"> | Date | string | null
    previousStatus?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    exceptionCleared?: BoolNullableWithAggregatesFilter<"ContainerEvent"> | boolean | null
    notes?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    eventCategory?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    eventClassifier?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    dcsaEventType?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    transportMode?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    facilityType?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
    emptyIndicator?: BoolNullableWithAggregatesFilter<"ContainerEvent"> | boolean | null
    carrierEventId?: StringNullableWithAggregatesFilter<"ContainerEvent"> | string | null
  }

  export type ShipmentEventWhereInput = {
    AND?: ShipmentEventWhereInput | ShipmentEventWhereInput[]
    OR?: ShipmentEventWhereInput[]
    NOT?: ShipmentEventWhereInput | ShipmentEventWhereInput[]
    id?: StringFilter<"ShipmentEvent"> | string
    shipmentId?: StringFilter<"ShipmentEvent"> | string
    eventType?: StringFilter<"ShipmentEvent"> | string
    eventDateTime?: DateTimeFilter<"ShipmentEvent"> | Date | string
    documentType?: StringNullableFilter<"ShipmentEvent"> | string | null
    source?: StringNullableFilter<"ShipmentEvent"> | string | null
    sourceFileId?: StringNullableFilter<"ShipmentEvent"> | string | null
    updatedBy?: StringNullableFilter<"ShipmentEvent"> | string | null
    updatedOn?: DateTimeNullableFilter<"ShipmentEvent"> | Date | string | null
    previousBLStatus?: StringNullableFilter<"ShipmentEvent"> | string | null
    newBLStatus?: StringNullableFilter<"ShipmentEvent"> | string | null
    notes?: StringNullableFilter<"ShipmentEvent"> | string | null
    dcsaEventType?: StringNullableFilter<"ShipmentEvent"> | string | null
    carrierEventId?: StringNullableFilter<"ShipmentEvent"> | string | null
    importLog?: XOR<ImportLogNullableRelationFilter, ImportLogWhereInput> | null
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
  }

  export type ShipmentEventOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    eventType?: SortOrder
    eventDateTime?: SortOrder
    documentType?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceFileId?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedOn?: SortOrderInput | SortOrder
    previousBLStatus?: SortOrderInput | SortOrder
    newBLStatus?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    carrierEventId?: SortOrderInput | SortOrder
    importLog?: ImportLogOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
  }

  export type ShipmentEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShipmentEventWhereInput | ShipmentEventWhereInput[]
    OR?: ShipmentEventWhereInput[]
    NOT?: ShipmentEventWhereInput | ShipmentEventWhereInput[]
    shipmentId?: StringFilter<"ShipmentEvent"> | string
    eventType?: StringFilter<"ShipmentEvent"> | string
    eventDateTime?: DateTimeFilter<"ShipmentEvent"> | Date | string
    documentType?: StringNullableFilter<"ShipmentEvent"> | string | null
    source?: StringNullableFilter<"ShipmentEvent"> | string | null
    sourceFileId?: StringNullableFilter<"ShipmentEvent"> | string | null
    updatedBy?: StringNullableFilter<"ShipmentEvent"> | string | null
    updatedOn?: DateTimeNullableFilter<"ShipmentEvent"> | Date | string | null
    previousBLStatus?: StringNullableFilter<"ShipmentEvent"> | string | null
    newBLStatus?: StringNullableFilter<"ShipmentEvent"> | string | null
    notes?: StringNullableFilter<"ShipmentEvent"> | string | null
    dcsaEventType?: StringNullableFilter<"ShipmentEvent"> | string | null
    carrierEventId?: StringNullableFilter<"ShipmentEvent"> | string | null
    importLog?: XOR<ImportLogNullableRelationFilter, ImportLogWhereInput> | null
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
  }, "id">

  export type ShipmentEventOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    eventType?: SortOrder
    eventDateTime?: SortOrder
    documentType?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceFileId?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedOn?: SortOrderInput | SortOrder
    previousBLStatus?: SortOrderInput | SortOrder
    newBLStatus?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    carrierEventId?: SortOrderInput | SortOrder
    _count?: ShipmentEventCountOrderByAggregateInput
    _max?: ShipmentEventMaxOrderByAggregateInput
    _min?: ShipmentEventMinOrderByAggregateInput
  }

  export type ShipmentEventScalarWhereWithAggregatesInput = {
    AND?: ShipmentEventScalarWhereWithAggregatesInput | ShipmentEventScalarWhereWithAggregatesInput[]
    OR?: ShipmentEventScalarWhereWithAggregatesInput[]
    NOT?: ShipmentEventScalarWhereWithAggregatesInput | ShipmentEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShipmentEvent"> | string
    shipmentId?: StringWithAggregatesFilter<"ShipmentEvent"> | string
    eventType?: StringWithAggregatesFilter<"ShipmentEvent"> | string
    eventDateTime?: DateTimeWithAggregatesFilter<"ShipmentEvent"> | Date | string
    documentType?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    source?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    sourceFileId?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    updatedOn?: DateTimeNullableWithAggregatesFilter<"ShipmentEvent"> | Date | string | null
    previousBLStatus?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    newBLStatus?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    dcsaEventType?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
    carrierEventId?: StringNullableWithAggregatesFilter<"ShipmentEvent"> | string | null
  }

  export type ACEStatusLogWhereInput = {
    AND?: ACEStatusLogWhereInput | ACEStatusLogWhereInput[]
    OR?: ACEStatusLogWhereInput[]
    NOT?: ACEStatusLogWhereInput | ACEStatusLogWhereInput[]
    id?: StringFilter<"ACEStatusLog"> | string
    containerId?: StringNullableFilter<"ACEStatusLog"> | string | null
    shipmentId?: StringNullableFilter<"ACEStatusLog"> | string | null
    aceDisposition?: StringNullableFilter<"ACEStatusLog"> | string | null
    aceStatus?: StringNullableFilter<"ACEStatusLog"> | string | null
    previousACEStatus?: StringNullableFilter<"ACEStatusLog"> | string | null
    holdType?: StringNullableFilter<"ACEStatusLog"> | string | null
    pgaAgency?: StringNullableFilter<"ACEStatusLog"> | string | null
    holdReason?: StringNullableFilter<"ACEStatusLog"> | string | null
    eventDateTime?: DateTimeNullableFilter<"ACEStatusLog"> | Date | string | null
    source?: StringNullableFilter<"ACEStatusLog"> | string | null
    sourceFileId?: StringNullableFilter<"ACEStatusLog"> | string | null
    updatedOn?: DateTimeNullableFilter<"ACEStatusLog"> | Date | string | null
    notes?: StringNullableFilter<"ACEStatusLog"> | string | null
    importLog?: XOR<ImportLogNullableRelationFilter, ImportLogWhereInput> | null
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
    container?: XOR<ContainerNullableRelationFilter, ContainerWhereInput> | null
  }

  export type ACEStatusLogOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    aceDisposition?: SortOrderInput | SortOrder
    aceStatus?: SortOrderInput | SortOrder
    previousACEStatus?: SortOrderInput | SortOrder
    holdType?: SortOrderInput | SortOrder
    pgaAgency?: SortOrderInput | SortOrder
    holdReason?: SortOrderInput | SortOrder
    eventDateTime?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceFileId?: SortOrderInput | SortOrder
    updatedOn?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    importLog?: ImportLogOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
    container?: ContainerOrderByWithRelationInput
  }

  export type ACEStatusLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ACEStatusLogWhereInput | ACEStatusLogWhereInput[]
    OR?: ACEStatusLogWhereInput[]
    NOT?: ACEStatusLogWhereInput | ACEStatusLogWhereInput[]
    containerId?: StringNullableFilter<"ACEStatusLog"> | string | null
    shipmentId?: StringNullableFilter<"ACEStatusLog"> | string | null
    aceDisposition?: StringNullableFilter<"ACEStatusLog"> | string | null
    aceStatus?: StringNullableFilter<"ACEStatusLog"> | string | null
    previousACEStatus?: StringNullableFilter<"ACEStatusLog"> | string | null
    holdType?: StringNullableFilter<"ACEStatusLog"> | string | null
    pgaAgency?: StringNullableFilter<"ACEStatusLog"> | string | null
    holdReason?: StringNullableFilter<"ACEStatusLog"> | string | null
    eventDateTime?: DateTimeNullableFilter<"ACEStatusLog"> | Date | string | null
    source?: StringNullableFilter<"ACEStatusLog"> | string | null
    sourceFileId?: StringNullableFilter<"ACEStatusLog"> | string | null
    updatedOn?: DateTimeNullableFilter<"ACEStatusLog"> | Date | string | null
    notes?: StringNullableFilter<"ACEStatusLog"> | string | null
    importLog?: XOR<ImportLogNullableRelationFilter, ImportLogWhereInput> | null
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
    container?: XOR<ContainerNullableRelationFilter, ContainerWhereInput> | null
  }, "id">

  export type ACEStatusLogOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    aceDisposition?: SortOrderInput | SortOrder
    aceStatus?: SortOrderInput | SortOrder
    previousACEStatus?: SortOrderInput | SortOrder
    holdType?: SortOrderInput | SortOrder
    pgaAgency?: SortOrderInput | SortOrder
    holdReason?: SortOrderInput | SortOrder
    eventDateTime?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceFileId?: SortOrderInput | SortOrder
    updatedOn?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ACEStatusLogCountOrderByAggregateInput
    _max?: ACEStatusLogMaxOrderByAggregateInput
    _min?: ACEStatusLogMinOrderByAggregateInput
  }

  export type ACEStatusLogScalarWhereWithAggregatesInput = {
    AND?: ACEStatusLogScalarWhereWithAggregatesInput | ACEStatusLogScalarWhereWithAggregatesInput[]
    OR?: ACEStatusLogScalarWhereWithAggregatesInput[]
    NOT?: ACEStatusLogScalarWhereWithAggregatesInput | ACEStatusLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ACEStatusLog"> | string
    containerId?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    shipmentId?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    aceDisposition?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    aceStatus?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    previousACEStatus?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    holdType?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    pgaAgency?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    holdReason?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    eventDateTime?: DateTimeNullableWithAggregatesFilter<"ACEStatusLog"> | Date | string | null
    source?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    sourceFileId?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
    updatedOn?: DateTimeNullableWithAggregatesFilter<"ACEStatusLog"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ACEStatusLog"> | string | null
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    facilityName?: StringFilter<"Facility"> | string
    facilityCode?: StringNullableFilter<"Facility"> | string | null
    facilityType?: StringNullableFilter<"Facility"> | string | null
    portId?: StringNullableFilter<"Facility"> | string | null
    address?: StringNullableFilter<"Facility"> | string | null
    unLocationCode?: StringNullableFilter<"Facility"> | string | null
    isActive?: BoolFilter<"Facility"> | boolean
    containerEvents?: ContainerEventListRelationFilter
    port?: XOR<PortNullableRelationFilter, PortWhereInput> | null
  }

  export type FacilityOrderByWithRelationInput = {
    facilityName?: SortOrder
    facilityCode?: SortOrderInput | SortOrder
    facilityType?: SortOrderInput | SortOrder
    portId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    unLocationCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    containerEvents?: ContainerEventOrderByRelationAggregateInput
    port?: PortOrderByWithRelationInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    facilityName?: string
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    facilityCode?: StringNullableFilter<"Facility"> | string | null
    facilityType?: StringNullableFilter<"Facility"> | string | null
    portId?: StringNullableFilter<"Facility"> | string | null
    address?: StringNullableFilter<"Facility"> | string | null
    unLocationCode?: StringNullableFilter<"Facility"> | string | null
    isActive?: BoolFilter<"Facility"> | boolean
    containerEvents?: ContainerEventListRelationFilter
    port?: XOR<PortNullableRelationFilter, PortWhereInput> | null
  }, "facilityName">

  export type FacilityOrderByWithAggregationInput = {
    facilityName?: SortOrder
    facilityCode?: SortOrderInput | SortOrder
    facilityType?: SortOrderInput | SortOrder
    portId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    unLocationCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    facilityName?: StringWithAggregatesFilter<"Facility"> | string
    facilityCode?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    facilityType?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    portId?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    address?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    unLocationCode?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    isActive?: BoolWithAggregatesFilter<"Facility"> | boolean
  }

  export type CarrierWhereInput = {
    AND?: CarrierWhereInput | CarrierWhereInput[]
    OR?: CarrierWhereInput[]
    NOT?: CarrierWhereInput | CarrierWhereInput[]
    carrierName?: StringFilter<"Carrier"> | string
    scac?: StringNullableFilter<"Carrier"> | string | null
    shortName?: StringNullableFilter<"Carrier"> | string | null
    trackingURL?: StringNullableFilter<"Carrier"> | string | null
    isActive?: BoolFilter<"Carrier"> | boolean
    dcsaCompliant?: BoolNullableFilter<"Carrier"> | boolean | null
    apiEndpoint?: StringNullableFilter<"Carrier"> | string | null
    apiCredentialRef?: StringNullableFilter<"Carrier"> | string | null
    carrierFormats?: CarrierFormatListRelationFilter
    dcsaEventMaps?: DCSAEventMapListRelationFilter
    demurrageRates?: DemurrageRateListRelationFilter
  }

  export type CarrierOrderByWithRelationInput = {
    carrierName?: SortOrder
    scac?: SortOrderInput | SortOrder
    shortName?: SortOrderInput | SortOrder
    trackingURL?: SortOrderInput | SortOrder
    isActive?: SortOrder
    dcsaCompliant?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    apiCredentialRef?: SortOrderInput | SortOrder
    carrierFormats?: CarrierFormatOrderByRelationAggregateInput
    dcsaEventMaps?: DCSAEventMapOrderByRelationAggregateInput
    demurrageRates?: DemurrageRateOrderByRelationAggregateInput
  }

  export type CarrierWhereUniqueInput = Prisma.AtLeast<{
    carrierName?: string
    AND?: CarrierWhereInput | CarrierWhereInput[]
    OR?: CarrierWhereInput[]
    NOT?: CarrierWhereInput | CarrierWhereInput[]
    scac?: StringNullableFilter<"Carrier"> | string | null
    shortName?: StringNullableFilter<"Carrier"> | string | null
    trackingURL?: StringNullableFilter<"Carrier"> | string | null
    isActive?: BoolFilter<"Carrier"> | boolean
    dcsaCompliant?: BoolNullableFilter<"Carrier"> | boolean | null
    apiEndpoint?: StringNullableFilter<"Carrier"> | string | null
    apiCredentialRef?: StringNullableFilter<"Carrier"> | string | null
    carrierFormats?: CarrierFormatListRelationFilter
    dcsaEventMaps?: DCSAEventMapListRelationFilter
    demurrageRates?: DemurrageRateListRelationFilter
  }, "carrierName">

  export type CarrierOrderByWithAggregationInput = {
    carrierName?: SortOrder
    scac?: SortOrderInput | SortOrder
    shortName?: SortOrderInput | SortOrder
    trackingURL?: SortOrderInput | SortOrder
    isActive?: SortOrder
    dcsaCompliant?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    apiCredentialRef?: SortOrderInput | SortOrder
    _count?: CarrierCountOrderByAggregateInput
    _max?: CarrierMaxOrderByAggregateInput
    _min?: CarrierMinOrderByAggregateInput
  }

  export type CarrierScalarWhereWithAggregatesInput = {
    AND?: CarrierScalarWhereWithAggregatesInput | CarrierScalarWhereWithAggregatesInput[]
    OR?: CarrierScalarWhereWithAggregatesInput[]
    NOT?: CarrierScalarWhereWithAggregatesInput | CarrierScalarWhereWithAggregatesInput[]
    carrierName?: StringWithAggregatesFilter<"Carrier"> | string
    scac?: StringNullableWithAggregatesFilter<"Carrier"> | string | null
    shortName?: StringNullableWithAggregatesFilter<"Carrier"> | string | null
    trackingURL?: StringNullableWithAggregatesFilter<"Carrier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Carrier"> | boolean
    dcsaCompliant?: BoolNullableWithAggregatesFilter<"Carrier"> | boolean | null
    apiEndpoint?: StringNullableWithAggregatesFilter<"Carrier"> | string | null
    apiCredentialRef?: StringNullableWithAggregatesFilter<"Carrier"> | string | null
  }

  export type PortWhereInput = {
    AND?: PortWhereInput | PortWhereInput[]
    OR?: PortWhereInput[]
    NOT?: PortWhereInput | PortWhereInput[]
    portName?: StringFilter<"Port"> | string
    portCode?: StringNullableFilter<"Port"> | string | null
    country?: StringNullableFilter<"Port"> | string | null
    countryCode?: StringNullableFilter<"Port"> | string | null
    region?: StringNullableFilter<"Port"> | string | null
    defaultFreeDays?: IntNullableFilter<"Port"> | number | null
    isActive?: BoolFilter<"Port"> | boolean
    acePortCode?: StringNullableFilter<"Port"> | string | null
    cbpDistrict?: StringNullableFilter<"Port"> | string | null
    demurrageRates?: DemurrageRateListRelationFilter
    facilities?: FacilityListRelationFilter
  }

  export type PortOrderByWithRelationInput = {
    portName?: SortOrder
    portCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    defaultFreeDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    acePortCode?: SortOrderInput | SortOrder
    cbpDistrict?: SortOrderInput | SortOrder
    demurrageRates?: DemurrageRateOrderByRelationAggregateInput
    facilities?: FacilityOrderByRelationAggregateInput
  }

  export type PortWhereUniqueInput = Prisma.AtLeast<{
    portName?: string
    AND?: PortWhereInput | PortWhereInput[]
    OR?: PortWhereInput[]
    NOT?: PortWhereInput | PortWhereInput[]
    portCode?: StringNullableFilter<"Port"> | string | null
    country?: StringNullableFilter<"Port"> | string | null
    countryCode?: StringNullableFilter<"Port"> | string | null
    region?: StringNullableFilter<"Port"> | string | null
    defaultFreeDays?: IntNullableFilter<"Port"> | number | null
    isActive?: BoolFilter<"Port"> | boolean
    acePortCode?: StringNullableFilter<"Port"> | string | null
    cbpDistrict?: StringNullableFilter<"Port"> | string | null
    demurrageRates?: DemurrageRateListRelationFilter
    facilities?: FacilityListRelationFilter
  }, "portName">

  export type PortOrderByWithAggregationInput = {
    portName?: SortOrder
    portCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    defaultFreeDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    acePortCode?: SortOrderInput | SortOrder
    cbpDistrict?: SortOrderInput | SortOrder
    _count?: PortCountOrderByAggregateInput
    _avg?: PortAvgOrderByAggregateInput
    _max?: PortMaxOrderByAggregateInput
    _min?: PortMinOrderByAggregateInput
    _sum?: PortSumOrderByAggregateInput
  }

  export type PortScalarWhereWithAggregatesInput = {
    AND?: PortScalarWhereWithAggregatesInput | PortScalarWhereWithAggregatesInput[]
    OR?: PortScalarWhereWithAggregatesInput[]
    NOT?: PortScalarWhereWithAggregatesInput | PortScalarWhereWithAggregatesInput[]
    portName?: StringWithAggregatesFilter<"Port"> | string
    portCode?: StringNullableWithAggregatesFilter<"Port"> | string | null
    country?: StringNullableWithAggregatesFilter<"Port"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"Port"> | string | null
    region?: StringNullableWithAggregatesFilter<"Port"> | string | null
    defaultFreeDays?: IntNullableWithAggregatesFilter<"Port"> | number | null
    isActive?: BoolWithAggregatesFilter<"Port"> | boolean
    acePortCode?: StringNullableWithAggregatesFilter<"Port"> | string | null
    cbpDistrict?: StringNullableWithAggregatesFilter<"Port"> | string | null
  }

  export type ForwarderWhereInput = {
    AND?: ForwarderWhereInput | ForwarderWhereInput[]
    OR?: ForwarderWhereInput[]
    NOT?: ForwarderWhereInput | ForwarderWhereInput[]
    forwarderName?: StringFilter<"Forwarder"> | string
    shortName?: StringNullableFilter<"Forwarder"> | string | null
    contactName?: StringNullableFilter<"Forwarder"> | string | null
    contactEmail?: StringNullableFilter<"Forwarder"> | string | null
    contactPhone?: StringNullableFilter<"Forwarder"> | string | null
    address?: StringNullableFilter<"Forwarder"> | string | null
    notes?: StringNullableFilter<"Forwarder"> | string | null
    isActive?: BoolFilter<"Forwarder"> | boolean
    customsBroker?: StringNullableFilter<"Forwarder"> | string | null
    aceFilerCode?: StringNullableFilter<"Forwarder"> | string | null
  }

  export type ForwarderOrderByWithRelationInput = {
    forwarderName?: SortOrder
    shortName?: SortOrderInput | SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customsBroker?: SortOrderInput | SortOrder
    aceFilerCode?: SortOrderInput | SortOrder
  }

  export type ForwarderWhereUniqueInput = Prisma.AtLeast<{
    forwarderName?: string
    AND?: ForwarderWhereInput | ForwarderWhereInput[]
    OR?: ForwarderWhereInput[]
    NOT?: ForwarderWhereInput | ForwarderWhereInput[]
    shortName?: StringNullableFilter<"Forwarder"> | string | null
    contactName?: StringNullableFilter<"Forwarder"> | string | null
    contactEmail?: StringNullableFilter<"Forwarder"> | string | null
    contactPhone?: StringNullableFilter<"Forwarder"> | string | null
    address?: StringNullableFilter<"Forwarder"> | string | null
    notes?: StringNullableFilter<"Forwarder"> | string | null
    isActive?: BoolFilter<"Forwarder"> | boolean
    customsBroker?: StringNullableFilter<"Forwarder"> | string | null
    aceFilerCode?: StringNullableFilter<"Forwarder"> | string | null
  }, "forwarderName">

  export type ForwarderOrderByWithAggregationInput = {
    forwarderName?: SortOrder
    shortName?: SortOrderInput | SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customsBroker?: SortOrderInput | SortOrder
    aceFilerCode?: SortOrderInput | SortOrder
    _count?: ForwarderCountOrderByAggregateInput
    _max?: ForwarderMaxOrderByAggregateInput
    _min?: ForwarderMinOrderByAggregateInput
  }

  export type ForwarderScalarWhereWithAggregatesInput = {
    AND?: ForwarderScalarWhereWithAggregatesInput | ForwarderScalarWhereWithAggregatesInput[]
    OR?: ForwarderScalarWhereWithAggregatesInput[]
    NOT?: ForwarderScalarWhereWithAggregatesInput | ForwarderScalarWhereWithAggregatesInput[]
    forwarderName?: StringWithAggregatesFilter<"Forwarder"> | string
    shortName?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    contactName?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    address?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    isActive?: BoolWithAggregatesFilter<"Forwarder"> | boolean
    customsBroker?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
    aceFilerCode?: StringNullableWithAggregatesFilter<"Forwarder"> | string | null
  }

  export type DemurrageRateWhereInput = {
    AND?: DemurrageRateWhereInput | DemurrageRateWhereInput[]
    OR?: DemurrageRateWhereInput[]
    NOT?: DemurrageRateWhereInput | DemurrageRateWhereInput[]
    name?: StringFilter<"DemurrageRate"> | string
    carrierId?: StringNullableFilter<"DemurrageRate"> | string | null
    portId?: StringNullableFilter<"DemurrageRate"> | string | null
    containerType?: StringNullableFilter<"DemurrageRate"> | string | null
    freeDays?: IntNullableFilter<"DemurrageRate"> | number | null
    dailyRate?: FloatNullableFilter<"DemurrageRate"> | number | null
    effectiveFrom?: DateTimeNullableFilter<"DemurrageRate"> | Date | string | null
    effectiveTo?: DateTimeNullableFilter<"DemurrageRate"> | Date | string | null
    notes?: StringNullableFilter<"DemurrageRate"> | string | null
    port?: XOR<PortNullableRelationFilter, PortWhereInput> | null
    carrier?: XOR<CarrierNullableRelationFilter, CarrierWhereInput> | null
  }

  export type DemurrageRateOrderByWithRelationInput = {
    name?: SortOrder
    carrierId?: SortOrderInput | SortOrder
    portId?: SortOrderInput | SortOrder
    containerType?: SortOrderInput | SortOrder
    freeDays?: SortOrderInput | SortOrder
    dailyRate?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrderInput | SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    port?: PortOrderByWithRelationInput
    carrier?: CarrierOrderByWithRelationInput
  }

  export type DemurrageRateWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: DemurrageRateWhereInput | DemurrageRateWhereInput[]
    OR?: DemurrageRateWhereInput[]
    NOT?: DemurrageRateWhereInput | DemurrageRateWhereInput[]
    carrierId?: StringNullableFilter<"DemurrageRate"> | string | null
    portId?: StringNullableFilter<"DemurrageRate"> | string | null
    containerType?: StringNullableFilter<"DemurrageRate"> | string | null
    freeDays?: IntNullableFilter<"DemurrageRate"> | number | null
    dailyRate?: FloatNullableFilter<"DemurrageRate"> | number | null
    effectiveFrom?: DateTimeNullableFilter<"DemurrageRate"> | Date | string | null
    effectiveTo?: DateTimeNullableFilter<"DemurrageRate"> | Date | string | null
    notes?: StringNullableFilter<"DemurrageRate"> | string | null
    port?: XOR<PortNullableRelationFilter, PortWhereInput> | null
    carrier?: XOR<CarrierNullableRelationFilter, CarrierWhereInput> | null
  }, "name">

  export type DemurrageRateOrderByWithAggregationInput = {
    name?: SortOrder
    carrierId?: SortOrderInput | SortOrder
    portId?: SortOrderInput | SortOrder
    containerType?: SortOrderInput | SortOrder
    freeDays?: SortOrderInput | SortOrder
    dailyRate?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrderInput | SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: DemurrageRateCountOrderByAggregateInput
    _avg?: DemurrageRateAvgOrderByAggregateInput
    _max?: DemurrageRateMaxOrderByAggregateInput
    _min?: DemurrageRateMinOrderByAggregateInput
    _sum?: DemurrageRateSumOrderByAggregateInput
  }

  export type DemurrageRateScalarWhereWithAggregatesInput = {
    AND?: DemurrageRateScalarWhereWithAggregatesInput | DemurrageRateScalarWhereWithAggregatesInput[]
    OR?: DemurrageRateScalarWhereWithAggregatesInput[]
    NOT?: DemurrageRateScalarWhereWithAggregatesInput | DemurrageRateScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"DemurrageRate"> | string
    carrierId?: StringNullableWithAggregatesFilter<"DemurrageRate"> | string | null
    portId?: StringNullableWithAggregatesFilter<"DemurrageRate"> | string | null
    containerType?: StringNullableWithAggregatesFilter<"DemurrageRate"> | string | null
    freeDays?: IntNullableWithAggregatesFilter<"DemurrageRate"> | number | null
    dailyRate?: FloatNullableWithAggregatesFilter<"DemurrageRate"> | number | null
    effectiveFrom?: DateTimeNullableWithAggregatesFilter<"DemurrageRate"> | Date | string | null
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"DemurrageRate"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"DemurrageRate"> | string | null
  }

  export type CarrierFormatWhereInput = {
    AND?: CarrierFormatWhereInput | CarrierFormatWhereInput[]
    OR?: CarrierFormatWhereInput[]
    NOT?: CarrierFormatWhereInput | CarrierFormatWhereInput[]
    formatName?: StringFilter<"CarrierFormat"> | string
    carrierId?: StringNullableFilter<"CarrierFormat"> | string | null
    formatType?: StringNullableFilter<"CarrierFormat"> | string | null
    columnMapping?: StringNullableFilter<"CarrierFormat"> | string | null
    sampleHeaders?: StringNullableFilter<"CarrierFormat"> | string | null
    isActive?: BoolFilter<"CarrierFormat"> | boolean
    notes?: StringNullableFilter<"CarrierFormat"> | string | null
    carrier?: XOR<CarrierNullableRelationFilter, CarrierWhereInput> | null
    importLogs?: ImportLogListRelationFilter
  }

  export type CarrierFormatOrderByWithRelationInput = {
    formatName?: SortOrder
    carrierId?: SortOrderInput | SortOrder
    formatType?: SortOrderInput | SortOrder
    columnMapping?: SortOrderInput | SortOrder
    sampleHeaders?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    carrier?: CarrierOrderByWithRelationInput
    importLogs?: ImportLogOrderByRelationAggregateInput
  }

  export type CarrierFormatWhereUniqueInput = Prisma.AtLeast<{
    formatName?: string
    AND?: CarrierFormatWhereInput | CarrierFormatWhereInput[]
    OR?: CarrierFormatWhereInput[]
    NOT?: CarrierFormatWhereInput | CarrierFormatWhereInput[]
    carrierId?: StringNullableFilter<"CarrierFormat"> | string | null
    formatType?: StringNullableFilter<"CarrierFormat"> | string | null
    columnMapping?: StringNullableFilter<"CarrierFormat"> | string | null
    sampleHeaders?: StringNullableFilter<"CarrierFormat"> | string | null
    isActive?: BoolFilter<"CarrierFormat"> | boolean
    notes?: StringNullableFilter<"CarrierFormat"> | string | null
    carrier?: XOR<CarrierNullableRelationFilter, CarrierWhereInput> | null
    importLogs?: ImportLogListRelationFilter
  }, "formatName">

  export type CarrierFormatOrderByWithAggregationInput = {
    formatName?: SortOrder
    carrierId?: SortOrderInput | SortOrder
    formatType?: SortOrderInput | SortOrder
    columnMapping?: SortOrderInput | SortOrder
    sampleHeaders?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: CarrierFormatCountOrderByAggregateInput
    _max?: CarrierFormatMaxOrderByAggregateInput
    _min?: CarrierFormatMinOrderByAggregateInput
  }

  export type CarrierFormatScalarWhereWithAggregatesInput = {
    AND?: CarrierFormatScalarWhereWithAggregatesInput | CarrierFormatScalarWhereWithAggregatesInput[]
    OR?: CarrierFormatScalarWhereWithAggregatesInput[]
    NOT?: CarrierFormatScalarWhereWithAggregatesInput | CarrierFormatScalarWhereWithAggregatesInput[]
    formatName?: StringWithAggregatesFilter<"CarrierFormat"> | string
    carrierId?: StringNullableWithAggregatesFilter<"CarrierFormat"> | string | null
    formatType?: StringNullableWithAggregatesFilter<"CarrierFormat"> | string | null
    columnMapping?: StringNullableWithAggregatesFilter<"CarrierFormat"> | string | null
    sampleHeaders?: StringNullableWithAggregatesFilter<"CarrierFormat"> | string | null
    isActive?: BoolWithAggregatesFilter<"CarrierFormat"> | boolean
    notes?: StringNullableWithAggregatesFilter<"CarrierFormat"> | string | null
  }

  export type DCSAEventMapWhereInput = {
    AND?: DCSAEventMapWhereInput | DCSAEventMapWhereInput[]
    OR?: DCSAEventMapWhereInput[]
    NOT?: DCSAEventMapWhereInput | DCSAEventMapWhereInput[]
    name?: StringFilter<"DCSAEventMap"> | string
    carrierId?: StringNullableFilter<"DCSAEventMap"> | string | null
    sourceEventCode?: StringNullableFilter<"DCSAEventMap"> | string | null
    sourceEventName?: StringNullableFilter<"DCSAEventMap"> | string | null
    dcsaEventType?: StringNullableFilter<"DCSAEventMap"> | string | null
    transitStageName?: StringNullableFilter<"DCSAEventMap"> | string | null
    eventCategory?: StringNullableFilter<"DCSAEventMap"> | string | null
    notes?: StringNullableFilter<"DCSAEventMap"> | string | null
    isActive?: BoolFilter<"DCSAEventMap"> | boolean
    transitStage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    carrier?: XOR<CarrierNullableRelationFilter, CarrierWhereInput> | null
  }

  export type DCSAEventMapOrderByWithRelationInput = {
    name?: SortOrder
    carrierId?: SortOrderInput | SortOrder
    sourceEventCode?: SortOrderInput | SortOrder
    sourceEventName?: SortOrderInput | SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    transitStageName?: SortOrderInput | SortOrder
    eventCategory?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    transitStage?: TransitStageOrderByWithRelationInput
    carrier?: CarrierOrderByWithRelationInput
  }

  export type DCSAEventMapWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: DCSAEventMapWhereInput | DCSAEventMapWhereInput[]
    OR?: DCSAEventMapWhereInput[]
    NOT?: DCSAEventMapWhereInput | DCSAEventMapWhereInput[]
    carrierId?: StringNullableFilter<"DCSAEventMap"> | string | null
    sourceEventCode?: StringNullableFilter<"DCSAEventMap"> | string | null
    sourceEventName?: StringNullableFilter<"DCSAEventMap"> | string | null
    dcsaEventType?: StringNullableFilter<"DCSAEventMap"> | string | null
    transitStageName?: StringNullableFilter<"DCSAEventMap"> | string | null
    eventCategory?: StringNullableFilter<"DCSAEventMap"> | string | null
    notes?: StringNullableFilter<"DCSAEventMap"> | string | null
    isActive?: BoolFilter<"DCSAEventMap"> | boolean
    transitStage?: XOR<TransitStageNullableRelationFilter, TransitStageWhereInput> | null
    carrier?: XOR<CarrierNullableRelationFilter, CarrierWhereInput> | null
  }, "name">

  export type DCSAEventMapOrderByWithAggregationInput = {
    name?: SortOrder
    carrierId?: SortOrderInput | SortOrder
    sourceEventCode?: SortOrderInput | SortOrder
    sourceEventName?: SortOrderInput | SortOrder
    dcsaEventType?: SortOrderInput | SortOrder
    transitStageName?: SortOrderInput | SortOrder
    eventCategory?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: DCSAEventMapCountOrderByAggregateInput
    _max?: DCSAEventMapMaxOrderByAggregateInput
    _min?: DCSAEventMapMinOrderByAggregateInput
  }

  export type DCSAEventMapScalarWhereWithAggregatesInput = {
    AND?: DCSAEventMapScalarWhereWithAggregatesInput | DCSAEventMapScalarWhereWithAggregatesInput[]
    OR?: DCSAEventMapScalarWhereWithAggregatesInput[]
    NOT?: DCSAEventMapScalarWhereWithAggregatesInput | DCSAEventMapScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"DCSAEventMap"> | string
    carrierId?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    sourceEventCode?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    sourceEventName?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    dcsaEventType?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    transitStageName?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    eventCategory?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    notes?: StringNullableWithAggregatesFilter<"DCSAEventMap"> | string | null
    isActive?: BoolWithAggregatesFilter<"DCSAEventMap"> | boolean
  }

  export type AttentionFlagWhereInput = {
    AND?: AttentionFlagWhereInput | AttentionFlagWhereInput[]
    OR?: AttentionFlagWhereInput[]
    NOT?: AttentionFlagWhereInput | AttentionFlagWhereInput[]
    id?: StringFilter<"AttentionFlag"> | string
    containerId?: StringFilter<"AttentionFlag"> | string
    reason?: StringFilter<"AttentionFlag"> | string
    priority?: StringFilter<"AttentionFlag"> | string
    flaggedBy?: StringNullableFilter<"AttentionFlag"> | string | null
    flaggedOn?: DateTimeFilter<"AttentionFlag"> | Date | string
    owner?: StringNullableFilter<"AttentionFlag"> | string | null
    notes?: StringNullableFilter<"AttentionFlag"> | string | null
    resolved?: BoolFilter<"AttentionFlag"> | boolean
    resolvedBy?: StringNullableFilter<"AttentionFlag"> | string | null
    resolvedDate?: DateTimeNullableFilter<"AttentionFlag"> | Date | string | null
    resolutionNote?: StringNullableFilter<"AttentionFlag"> | string | null
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }

  export type AttentionFlagOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrder
    reason?: SortOrder
    priority?: SortOrder
    flaggedBy?: SortOrderInput | SortOrder
    flaggedOn?: SortOrder
    owner?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedDate?: SortOrderInput | SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    container?: ContainerOrderByWithRelationInput
  }

  export type AttentionFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttentionFlagWhereInput | AttentionFlagWhereInput[]
    OR?: AttentionFlagWhereInput[]
    NOT?: AttentionFlagWhereInput | AttentionFlagWhereInput[]
    containerId?: StringFilter<"AttentionFlag"> | string
    reason?: StringFilter<"AttentionFlag"> | string
    priority?: StringFilter<"AttentionFlag"> | string
    flaggedBy?: StringNullableFilter<"AttentionFlag"> | string | null
    flaggedOn?: DateTimeFilter<"AttentionFlag"> | Date | string
    owner?: StringNullableFilter<"AttentionFlag"> | string | null
    notes?: StringNullableFilter<"AttentionFlag"> | string | null
    resolved?: BoolFilter<"AttentionFlag"> | boolean
    resolvedBy?: StringNullableFilter<"AttentionFlag"> | string | null
    resolvedDate?: DateTimeNullableFilter<"AttentionFlag"> | Date | string | null
    resolutionNote?: StringNullableFilter<"AttentionFlag"> | string | null
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }, "id">

  export type AttentionFlagOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrder
    reason?: SortOrder
    priority?: SortOrder
    flaggedBy?: SortOrderInput | SortOrder
    flaggedOn?: SortOrder
    owner?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedDate?: SortOrderInput | SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    _count?: AttentionFlagCountOrderByAggregateInput
    _max?: AttentionFlagMaxOrderByAggregateInput
    _min?: AttentionFlagMinOrderByAggregateInput
  }

  export type AttentionFlagScalarWhereWithAggregatesInput = {
    AND?: AttentionFlagScalarWhereWithAggregatesInput | AttentionFlagScalarWhereWithAggregatesInput[]
    OR?: AttentionFlagScalarWhereWithAggregatesInput[]
    NOT?: AttentionFlagScalarWhereWithAggregatesInput | AttentionFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttentionFlag"> | string
    containerId?: StringWithAggregatesFilter<"AttentionFlag"> | string
    reason?: StringWithAggregatesFilter<"AttentionFlag"> | string
    priority?: StringWithAggregatesFilter<"AttentionFlag"> | string
    flaggedBy?: StringNullableWithAggregatesFilter<"AttentionFlag"> | string | null
    flaggedOn?: DateTimeWithAggregatesFilter<"AttentionFlag"> | Date | string
    owner?: StringNullableWithAggregatesFilter<"AttentionFlag"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AttentionFlag"> | string | null
    resolved?: BoolWithAggregatesFilter<"AttentionFlag"> | boolean
    resolvedBy?: StringNullableWithAggregatesFilter<"AttentionFlag"> | string | null
    resolvedDate?: DateTimeNullableWithAggregatesFilter<"AttentionFlag"> | Date | string | null
    resolutionNote?: StringNullableWithAggregatesFilter<"AttentionFlag"> | string | null
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    containerId?: StringNullableFilter<"ActivityLog"> | string | null
    shipmentId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    actor?: StringNullableFilter<"ActivityLog"> | string | null
    detail?: StringNullableFilter<"ActivityLog"> | string | null
    source?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    container?: XOR<ContainerNullableRelationFilter, ContainerWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    action?: SortOrder
    actor?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    container?: ContainerOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    containerId?: StringNullableFilter<"ActivityLog"> | string | null
    shipmentId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    actor?: StringNullableFilter<"ActivityLog"> | string | null
    detail?: StringNullableFilter<"ActivityLog"> | string | null
    source?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    container?: XOR<ContainerNullableRelationFilter, ContainerWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    action?: SortOrder
    actor?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    containerId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    shipmentId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    actor?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    detail?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    source?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type StatusOverrideWhereInput = {
    AND?: StatusOverrideWhereInput | StatusOverrideWhereInput[]
    OR?: StatusOverrideWhereInput[]
    NOT?: StatusOverrideWhereInput | StatusOverrideWhereInput[]
    id?: StringFilter<"StatusOverride"> | string
    containerNumber?: StringFilter<"StatusOverride"> | string
    previousStatus?: StringNullableFilter<"StatusOverride"> | string | null
    newStatus?: StringFilter<"StatusOverride"> | string
    reason?: StringFilter<"StatusOverride"> | string
    overriddenBy?: StringNullableFilter<"StatusOverride"> | string | null
    overriddenAt?: DateTimeFilter<"StatusOverride"> | Date | string
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }

  export type StatusOverrideOrderByWithRelationInput = {
    id?: SortOrder
    containerNumber?: SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    reason?: SortOrder
    overriddenBy?: SortOrderInput | SortOrder
    overriddenAt?: SortOrder
    container?: ContainerOrderByWithRelationInput
  }

  export type StatusOverrideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatusOverrideWhereInput | StatusOverrideWhereInput[]
    OR?: StatusOverrideWhereInput[]
    NOT?: StatusOverrideWhereInput | StatusOverrideWhereInput[]
    containerNumber?: StringFilter<"StatusOverride"> | string
    previousStatus?: StringNullableFilter<"StatusOverride"> | string | null
    newStatus?: StringFilter<"StatusOverride"> | string
    reason?: StringFilter<"StatusOverride"> | string
    overriddenBy?: StringNullableFilter<"StatusOverride"> | string | null
    overriddenAt?: DateTimeFilter<"StatusOverride"> | Date | string
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }, "id">

  export type StatusOverrideOrderByWithAggregationInput = {
    id?: SortOrder
    containerNumber?: SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    reason?: SortOrder
    overriddenBy?: SortOrderInput | SortOrder
    overriddenAt?: SortOrder
    _count?: StatusOverrideCountOrderByAggregateInput
    _max?: StatusOverrideMaxOrderByAggregateInput
    _min?: StatusOverrideMinOrderByAggregateInput
  }

  export type StatusOverrideScalarWhereWithAggregatesInput = {
    AND?: StatusOverrideScalarWhereWithAggregatesInput | StatusOverrideScalarWhereWithAggregatesInput[]
    OR?: StatusOverrideScalarWhereWithAggregatesInput[]
    NOT?: StatusOverrideScalarWhereWithAggregatesInput | StatusOverrideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatusOverride"> | string
    containerNumber?: StringWithAggregatesFilter<"StatusOverride"> | string
    previousStatus?: StringNullableWithAggregatesFilter<"StatusOverride"> | string | null
    newStatus?: StringWithAggregatesFilter<"StatusOverride"> | string
    reason?: StringWithAggregatesFilter<"StatusOverride"> | string
    overriddenBy?: StringNullableWithAggregatesFilter<"StatusOverride"> | string | null
    overriddenAt?: DateTimeWithAggregatesFilter<"StatusOverride"> | Date | string
  }

  export type RiskAssessmentWhereInput = {
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    id?: StringFilter<"RiskAssessment"> | string
    containerId?: StringFilter<"RiskAssessment"> | string
    riskScore?: IntFilter<"RiskAssessment"> | number
    riskFactors?: StringFilter<"RiskAssessment"> | string
    recommendations?: StringFilter<"RiskAssessment"> | string
    lastUpdated?: DateTimeFilter<"RiskAssessment"> | Date | string
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }

  export type RiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    recommendations?: SortOrder
    lastUpdated?: SortOrder
    container?: ContainerOrderByWithRelationInput
  }

  export type RiskAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    containerId?: string
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    riskScore?: IntFilter<"RiskAssessment"> | number
    riskFactors?: StringFilter<"RiskAssessment"> | string
    recommendations?: StringFilter<"RiskAssessment"> | string
    lastUpdated?: DateTimeFilter<"RiskAssessment"> | Date | string
    container?: XOR<ContainerRelationFilter, ContainerWhereInput>
  }, "id" | "containerId">

  export type RiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    recommendations?: SortOrder
    lastUpdated?: SortOrder
    _count?: RiskAssessmentCountOrderByAggregateInput
    _avg?: RiskAssessmentAvgOrderByAggregateInput
    _max?: RiskAssessmentMaxOrderByAggregateInput
    _min?: RiskAssessmentMinOrderByAggregateInput
    _sum?: RiskAssessmentSumOrderByAggregateInput
  }

  export type RiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: RiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAssessment"> | string
    containerId?: StringWithAggregatesFilter<"RiskAssessment"> | string
    riskScore?: IntWithAggregatesFilter<"RiskAssessment"> | number
    riskFactors?: StringWithAggregatesFilter<"RiskAssessment"> | string
    recommendations?: StringWithAggregatesFilter<"RiskAssessment"> | string
    lastUpdated?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
  }

  export type ImportLogCreateInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventCreateNestedManyWithoutImportLogInput
    carrierFormat?: CarrierFormatCreateNestedOneWithoutImportLogsInput
    rawRows?: RawRowCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUncheckedCreateInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    carrierFormatId?: string | null
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutImportLogInput
    rawRows?: RawRowUncheckedCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutImportLogNestedInput
    carrierFormat?: CarrierFormatUpdateOneWithoutImportLogsNestedInput
    rawRows?: RawRowUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    carrierFormatId?: NullableStringFieldUpdateOperationsInput | string | null
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutImportLogNestedInput
    rawRows?: RawRowUncheckedUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogCreateManyInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    carrierFormatId?: string | null
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
  }

  export type ImportLogUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImportLogUncheckedUpdateManyInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    carrierFormatId?: NullableStringFieldUpdateOperationsInput | string | null
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RawRowCreateInput = {
    id?: string
    rowNumber: number
    data: string
    importLog: ImportLogCreateNestedOneWithoutRawRowsInput
  }

  export type RawRowUncheckedCreateInput = {
    id?: string
    importLogId: string
    rowNumber: number
    data: string
  }

  export type RawRowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    importLog?: ImportLogUpdateOneRequiredWithoutRawRowsNestedInput
  }

  export type RawRowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    importLogId?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type RawRowCreateManyInput = {
    id?: string
    importLogId: string
    rowNumber: number
    data: string
  }

  export type RawRowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type RawRowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    importLogId?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type TransitStageCreateInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerCreateNestedManyWithoutStageInput
    previousEvents?: ContainerEventCreateNestedManyWithoutPreviousStageInput
    containerEvents?: ContainerEventCreateNestedManyWithoutStageInput
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageUncheckedCreateInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerUncheckedCreateNestedManyWithoutStageInput
    previousEvents?: ContainerEventUncheckedCreateNestedManyWithoutPreviousStageInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutStageInput
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageUpdateInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUpdateManyWithoutStageNestedInput
    previousEvents?: ContainerEventUpdateManyWithoutPreviousStageNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutStageNestedInput
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutTransitStageNestedInput
  }

  export type TransitStageUncheckedUpdateInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUncheckedUpdateManyWithoutStageNestedInput
    previousEvents?: ContainerEventUncheckedUpdateManyWithoutPreviousStageNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutStageNestedInput
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutTransitStageNestedInput
  }

  export type TransitStageCreateManyInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
  }

  export type TransitStageUpdateManyMutationInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransitStageUncheckedUpdateManyInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentCreateInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutShipmentInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutShipmentInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutShipmentInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutShipmentInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUpdateInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutShipmentNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutShipmentNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutShipmentNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutShipmentNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentCreateManyInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
  }

  export type ShipmentUpdateManyMutationInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShipmentUncheckedUpdateManyInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContainerCreateInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerUpdateInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ContainerCreateManyInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerUpdateManyMutationInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerUncheckedUpdateManyInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentContainerCreateInput = {
    id?: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
    container: ContainerCreateNestedOneWithoutShipmentContainersInput
    shipment: ShipmentCreateNestedOneWithoutShipmentContainersInput
  }

  export type ShipmentContainerUncheckedCreateInput = {
    id?: string
    shipmentId: string
    containerId: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
  }

  export type ShipmentContainerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutShipmentContainersNestedInput
    shipment?: ShipmentUpdateOneRequiredWithoutShipmentContainersNestedInput
  }

  export type ShipmentContainerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentContainerCreateManyInput = {
    id?: string
    shipmentId: string
    containerId: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
  }

  export type ShipmentContainerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentContainerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventCreateInput = {
    id?: string
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
    facility?: FacilityCreateNestedOneWithoutContainerEventsInput
    importLog?: ImportLogCreateNestedOneWithoutContainerEventsInput
    previousStage?: TransitStageCreateNestedOneWithoutPreviousEventsInput
    stage?: TransitStageCreateNestedOneWithoutContainerEventsInput
    container: ContainerCreateNestedOneWithoutEventsInput
  }

  export type ContainerEventUncheckedCreateInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutContainerEventsNestedInput
    importLog?: ImportLogUpdateOneWithoutContainerEventsNestedInput
    previousStage?: TransitStageUpdateOneWithoutPreviousEventsNestedInput
    stage?: TransitStageUpdateOneWithoutContainerEventsNestedInput
    container?: ContainerUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContainerEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventCreateManyInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentEventCreateInput = {
    id?: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
    importLog?: ImportLogCreateNestedOneWithoutShipmentEventsInput
    shipment: ShipmentCreateNestedOneWithoutShipmentEventsInput
  }

  export type ShipmentEventUncheckedCreateInput = {
    id?: string
    shipmentId: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
  }

  export type ShipmentEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    importLog?: ImportLogUpdateOneWithoutShipmentEventsNestedInput
    shipment?: ShipmentUpdateOneRequiredWithoutShipmentEventsNestedInput
  }

  export type ShipmentEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentEventCreateManyInput = {
    id?: string
    shipmentId: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
  }

  export type ShipmentEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogCreateInput = {
    id?: string
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
    importLog?: ImportLogCreateNestedOneWithoutAceStatusLogsInput
    shipment?: ShipmentCreateNestedOneWithoutAceStatusLogsInput
    container?: ContainerCreateNestedOneWithoutAceStatusLogsInput
  }

  export type ACEStatusLogUncheckedCreateInput = {
    id?: string
    containerId?: string | null
    shipmentId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    sourceFileId?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ACEStatusLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importLog?: ImportLogUpdateOneWithoutAceStatusLogsNestedInput
    shipment?: ShipmentUpdateOneWithoutAceStatusLogsNestedInput
    container?: ContainerUpdateOneWithoutAceStatusLogsNestedInput
  }

  export type ACEStatusLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogCreateManyInput = {
    id?: string
    containerId?: string | null
    shipmentId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    sourceFileId?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ACEStatusLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityCreateInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
    containerEvents?: ContainerEventCreateNestedManyWithoutFacilityInput
    port?: PortCreateNestedOneWithoutFacilitiesInput
  }

  export type FacilityUncheckedCreateInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    portId?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUpdateInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    containerEvents?: ContainerEventUpdateManyWithoutFacilityNestedInput
    port?: PortUpdateOneWithoutFacilitiesNestedInput
  }

  export type FacilityUncheckedUpdateInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateManyInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    portId?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
  }

  export type FacilityUpdateManyMutationInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FacilityUncheckedUpdateManyInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CarrierCreateInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    carrierFormats?: CarrierFormatCreateNestedManyWithoutCarrierInput
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutCarrierInput
    demurrageRates?: DemurrageRateCreateNestedManyWithoutCarrierInput
  }

  export type CarrierUncheckedCreateInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    carrierFormats?: CarrierFormatUncheckedCreateNestedManyWithoutCarrierInput
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutCarrierInput
    demurrageRates?: DemurrageRateUncheckedCreateNestedManyWithoutCarrierInput
  }

  export type CarrierUpdateInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    carrierFormats?: CarrierFormatUpdateManyWithoutCarrierNestedInput
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutCarrierNestedInput
    demurrageRates?: DemurrageRateUpdateManyWithoutCarrierNestedInput
  }

  export type CarrierUncheckedUpdateInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    carrierFormats?: CarrierFormatUncheckedUpdateManyWithoutCarrierNestedInput
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutCarrierNestedInput
    demurrageRates?: DemurrageRateUncheckedUpdateManyWithoutCarrierNestedInput
  }

  export type CarrierCreateManyInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
  }

  export type CarrierUpdateManyMutationInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarrierUncheckedUpdateManyInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortCreateInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
    demurrageRates?: DemurrageRateCreateNestedManyWithoutPortInput
    facilities?: FacilityCreateNestedManyWithoutPortInput
  }

  export type PortUncheckedCreateInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
    demurrageRates?: DemurrageRateUncheckedCreateNestedManyWithoutPortInput
    facilities?: FacilityUncheckedCreateNestedManyWithoutPortInput
  }

  export type PortUpdateInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    demurrageRates?: DemurrageRateUpdateManyWithoutPortNestedInput
    facilities?: FacilityUpdateManyWithoutPortNestedInput
  }

  export type PortUncheckedUpdateInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    demurrageRates?: DemurrageRateUncheckedUpdateManyWithoutPortNestedInput
    facilities?: FacilityUncheckedUpdateManyWithoutPortNestedInput
  }

  export type PortCreateManyInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
  }

  export type PortUpdateManyMutationInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortUncheckedUpdateManyInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ForwarderCreateInput = {
    forwarderName: string
    shortName?: string | null
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    customsBroker?: string | null
    aceFilerCode?: string | null
  }

  export type ForwarderUncheckedCreateInput = {
    forwarderName: string
    shortName?: string | null
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    customsBroker?: string | null
    aceFilerCode?: string | null
  }

  export type ForwarderUpdateInput = {
    forwarderName?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    aceFilerCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ForwarderUncheckedUpdateInput = {
    forwarderName?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    aceFilerCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ForwarderCreateManyInput = {
    forwarderName: string
    shortName?: string | null
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    notes?: string | null
    isActive?: boolean
    customsBroker?: string | null
    aceFilerCode?: string | null
  }

  export type ForwarderUpdateManyMutationInput = {
    forwarderName?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    aceFilerCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ForwarderUncheckedUpdateManyInput = {
    forwarderName?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    aceFilerCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DemurrageRateCreateInput = {
    name: string
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    port?: PortCreateNestedOneWithoutDemurrageRatesInput
    carrier?: CarrierCreateNestedOneWithoutDemurrageRatesInput
  }

  export type DemurrageRateUncheckedCreateInput = {
    name: string
    carrierId?: string | null
    portId?: string | null
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
  }

  export type DemurrageRateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    port?: PortUpdateOneWithoutDemurrageRatesNestedInput
    carrier?: CarrierUpdateOneWithoutDemurrageRatesNestedInput
  }

  export type DemurrageRateUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DemurrageRateCreateManyInput = {
    name: string
    carrierId?: string | null
    portId?: string | null
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
  }

  export type DemurrageRateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DemurrageRateUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarrierFormatCreateInput = {
    formatName: string
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
    carrier?: CarrierCreateNestedOneWithoutCarrierFormatsInput
    importLogs?: ImportLogCreateNestedManyWithoutCarrierFormatInput
  }

  export type CarrierFormatUncheckedCreateInput = {
    formatName: string
    carrierId?: string | null
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutCarrierFormatInput
  }

  export type CarrierFormatUpdateInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: CarrierUpdateOneWithoutCarrierFormatsNestedInput
    importLogs?: ImportLogUpdateManyWithoutCarrierFormatNestedInput
  }

  export type CarrierFormatUncheckedUpdateInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importLogs?: ImportLogUncheckedUpdateManyWithoutCarrierFormatNestedInput
  }

  export type CarrierFormatCreateManyInput = {
    formatName: string
    carrierId?: string | null
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
  }

  export type CarrierFormatUpdateManyMutationInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarrierFormatUncheckedUpdateManyInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DCSAEventMapCreateInput = {
    name: string
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
    transitStage?: TransitStageCreateNestedOneWithoutDcsaEventMapsInput
    carrier?: CarrierCreateNestedOneWithoutDcsaEventMapsInput
  }

  export type DCSAEventMapUncheckedCreateInput = {
    name: string
    carrierId?: string | null
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    transitStageName?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
  }

  export type DCSAEventMapUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    transitStage?: TransitStageUpdateOneWithoutDcsaEventMapsNestedInput
    carrier?: CarrierUpdateOneWithoutDcsaEventMapsNestedInput
  }

  export type DCSAEventMapUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transitStageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DCSAEventMapCreateManyInput = {
    name: string
    carrierId?: string | null
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    transitStageName?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
  }

  export type DCSAEventMapUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DCSAEventMapUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transitStageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttentionFlagCreateInput = {
    id?: string
    reason: string
    priority: string
    flaggedBy?: string | null
    flaggedOn?: Date | string
    owner?: string | null
    notes?: string | null
    resolved?: boolean
    resolvedBy?: string | null
    resolvedDate?: Date | string | null
    resolutionNote?: string | null
    container: ContainerCreateNestedOneWithoutAttentionFlagsInput
  }

  export type AttentionFlagUncheckedCreateInput = {
    id?: string
    containerId: string
    reason: string
    priority: string
    flaggedBy?: string | null
    flaggedOn?: Date | string
    owner?: string | null
    notes?: string | null
    resolved?: boolean
    resolvedBy?: string | null
    resolvedDate?: Date | string | null
    resolutionNote?: string | null
  }

  export type AttentionFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutAttentionFlagsNestedInput
  }

  export type AttentionFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttentionFlagCreateManyInput = {
    id?: string
    containerId: string
    reason: string
    priority: string
    flaggedBy?: string | null
    flaggedOn?: Date | string
    owner?: string | null
    notes?: string | null
    resolved?: boolean
    resolvedBy?: string | null
    resolvedDate?: Date | string | null
    resolutionNote?: string | null
  }

  export type AttentionFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttentionFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateInput = {
    id?: string
    shipmentId?: string | null
    action: string
    actor?: string | null
    detail?: string | null
    source?: string | null
    metadata?: string | null
    createdAt?: Date | string
    container?: ContainerCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    containerId?: string | null
    shipmentId?: string | null
    action: string
    actor?: string | null
    detail?: string | null
    source?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    containerId?: string | null
    shipmentId?: string | null
    action: string
    actor?: string | null
    detail?: string | null
    source?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusOverrideCreateInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    reason: string
    overriddenBy?: string | null
    overriddenAt?: Date | string
    container: ContainerCreateNestedOneWithoutStatusOverridesInput
  }

  export type StatusOverrideUncheckedCreateInput = {
    id?: string
    containerNumber: string
    previousStatus?: string | null
    newStatus: string
    reason: string
    overriddenBy?: string | null
    overriddenAt?: Date | string
  }

  export type StatusOverrideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutStatusOverridesNestedInput
  }

  export type StatusOverrideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerNumber?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusOverrideCreateManyInput = {
    id?: string
    containerNumber: string
    previousStatus?: string | null
    newStatus: string
    reason: string
    overriddenBy?: string | null
    overriddenAt?: Date | string
  }

  export type StatusOverrideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusOverrideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerNumber?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateInput = {
    id?: string
    riskScore: number
    riskFactors: string
    recommendations: string
    lastUpdated?: Date | string
    container: ContainerCreateNestedOneWithoutRiskAssessmentInput
  }

  export type RiskAssessmentUncheckedCreateInput = {
    id?: string
    containerId: string
    riskScore: number
    riskFactors: string
    recommendations: string
    lastUpdated?: Date | string
  }

  export type RiskAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutRiskAssessmentNestedInput
  }

  export type RiskAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateManyInput = {
    id?: string
    containerId: string
    riskScore: number
    riskFactors: string
    recommendations: string
    lastUpdated?: Date | string
  }

  export type RiskAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ACEStatusLogListRelationFilter = {
    every?: ACEStatusLogWhereInput
    some?: ACEStatusLogWhereInput
    none?: ACEStatusLogWhereInput
  }

  export type ContainerEventListRelationFilter = {
    every?: ContainerEventWhereInput
    some?: ContainerEventWhereInput
    none?: ContainerEventWhereInput
  }

  export type CarrierFormatNullableRelationFilter = {
    is?: CarrierFormatWhereInput | null
    isNot?: CarrierFormatWhereInput | null
  }

  export type RawRowListRelationFilter = {
    every?: RawRowWhereInput
    some?: RawRowWhereInput
    none?: RawRowWhereInput
  }

  export type ShipmentEventListRelationFilter = {
    every?: ShipmentEventWhereInput
    some?: ShipmentEventWhereInput
    none?: ShipmentEventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ACEStatusLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContainerEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawRowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportLogCountOrderByAggregateInput = {
    fileName?: SortOrder
    fileURL?: SortOrder
    importedBy?: SortOrder
    importedOn?: SortOrder
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
    carrierFormatId?: SortOrder
    importType?: SortOrder
    status?: SortOrder
    errorLog?: SortOrder
    aiAnalysis?: SortOrder
    aiAnalyzedAt?: SortOrder
  }

  export type ImportLogAvgOrderByAggregateInput = {
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
  }

  export type ImportLogMaxOrderByAggregateInput = {
    fileName?: SortOrder
    fileURL?: SortOrder
    importedBy?: SortOrder
    importedOn?: SortOrder
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
    carrierFormatId?: SortOrder
    importType?: SortOrder
    status?: SortOrder
    errorLog?: SortOrder
    aiAnalyzedAt?: SortOrder
  }

  export type ImportLogMinOrderByAggregateInput = {
    fileName?: SortOrder
    fileURL?: SortOrder
    importedBy?: SortOrder
    importedOn?: SortOrder
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
    carrierFormatId?: SortOrder
    importType?: SortOrder
    status?: SortOrder
    errorLog?: SortOrder
    aiAnalyzedAt?: SortOrder
  }

  export type ImportLogSumOrderByAggregateInput = {
    rowsProcessed?: SortOrder
    rowsSucceeded?: SortOrder
    rowsFailed?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ImportLogRelationFilter = {
    is?: ImportLogWhereInput
    isNot?: ImportLogWhereInput
  }

  export type RawRowCountOrderByAggregateInput = {
    id?: SortOrder
    importLogId?: SortOrder
    rowNumber?: SortOrder
    data?: SortOrder
  }

  export type RawRowAvgOrderByAggregateInput = {
    rowNumber?: SortOrder
  }

  export type RawRowMaxOrderByAggregateInput = {
    id?: SortOrder
    importLogId?: SortOrder
    rowNumber?: SortOrder
    data?: SortOrder
  }

  export type RawRowMinOrderByAggregateInput = {
    id?: SortOrder
    importLogId?: SortOrder
    rowNumber?: SortOrder
    data?: SortOrder
  }

  export type RawRowSumOrderByAggregateInput = {
    rowNumber?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContainerListRelationFilter = {
    every?: ContainerWhereInput
    some?: ContainerWhereInput
    none?: ContainerWhereInput
  }

  export type DCSAEventMapListRelationFilter = {
    every?: DCSAEventMapWhereInput
    some?: DCSAEventMapWhereInput
    none?: DCSAEventMapWhereInput
  }

  export type ContainerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DCSAEventMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransitStageCountOrderByAggregateInput = {
    stageName?: SortOrder
    stageCode?: SortOrder
    sequence?: SortOrder
    category?: SortOrder
    expectedDays?: SortOrder
    alertAfterDays?: SortOrder
    responsibleTeam?: SortOrder
    isActive?: SortOrder
    dcsaEventType?: SortOrder
    dcsaEventCategory?: SortOrder
    dcsaFacilityType?: SortOrder
  }

  export type TransitStageAvgOrderByAggregateInput = {
    sequence?: SortOrder
    expectedDays?: SortOrder
    alertAfterDays?: SortOrder
  }

  export type TransitStageMaxOrderByAggregateInput = {
    stageName?: SortOrder
    stageCode?: SortOrder
    sequence?: SortOrder
    category?: SortOrder
    expectedDays?: SortOrder
    alertAfterDays?: SortOrder
    responsibleTeam?: SortOrder
    isActive?: SortOrder
    dcsaEventType?: SortOrder
    dcsaEventCategory?: SortOrder
    dcsaFacilityType?: SortOrder
  }

  export type TransitStageMinOrderByAggregateInput = {
    stageName?: SortOrder
    stageCode?: SortOrder
    sequence?: SortOrder
    category?: SortOrder
    expectedDays?: SortOrder
    alertAfterDays?: SortOrder
    responsibleTeam?: SortOrder
    isActive?: SortOrder
    dcsaEventType?: SortOrder
    dcsaEventCategory?: SortOrder
    dcsaFacilityType?: SortOrder
  }

  export type TransitStageSumOrderByAggregateInput = {
    sequence?: SortOrder
    expectedDays?: SortOrder
    alertAfterDays?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ShipmentContainerListRelationFilter = {
    every?: ShipmentContainerWhereInput
    some?: ShipmentContainerWhereInput
    none?: ShipmentContainerWhereInput
  }

  export type ShipmentContainerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentCountOrderByAggregateInput = {
    shipmentReference?: SortOrder
    hbl?: SortOrder
    mbl?: SortOrder
    bookingReference?: SortOrder
    shipmentType?: SortOrder
    carrier?: SortOrder
    forwarder?: SortOrder
    shipper?: SortOrder
    consignee?: SortOrder
    pol?: SortOrder
    pod?: SortOrder
    finalDestination?: SortOrder
    contents?: SortOrder
    supplier?: SortOrder
    totalWeight?: SortOrder
    totalPieces?: SortOrder
    customerReference?: SortOrder
    poNumber?: SortOrder
    incoTerms?: SortOrder
    expectedContainers?: SortOrder
    blType?: SortOrder
    blStatus?: SortOrder
    paymentStatus?: SortOrder
    paymentDueDate?: SortOrder
    amountDue?: SortOrder
    releaseStatus?: SortOrder
    releaseDate?: SortOrder
    holdReason?: SortOrder
    notes?: SortOrder
    aceEntryNumber?: SortOrder
    aceEntryType?: SortOrder
    dutyAmount?: SortOrder
    liquidationStatus?: SortOrder
    liquidationDate?: SortOrder
  }

  export type ShipmentAvgOrderByAggregateInput = {
    totalWeight?: SortOrder
    totalPieces?: SortOrder
    expectedContainers?: SortOrder
    amountDue?: SortOrder
    dutyAmount?: SortOrder
  }

  export type ShipmentMaxOrderByAggregateInput = {
    shipmentReference?: SortOrder
    hbl?: SortOrder
    mbl?: SortOrder
    bookingReference?: SortOrder
    shipmentType?: SortOrder
    carrier?: SortOrder
    forwarder?: SortOrder
    shipper?: SortOrder
    consignee?: SortOrder
    pol?: SortOrder
    pod?: SortOrder
    finalDestination?: SortOrder
    contents?: SortOrder
    supplier?: SortOrder
    totalWeight?: SortOrder
    totalPieces?: SortOrder
    customerReference?: SortOrder
    poNumber?: SortOrder
    incoTerms?: SortOrder
    expectedContainers?: SortOrder
    blType?: SortOrder
    blStatus?: SortOrder
    paymentStatus?: SortOrder
    paymentDueDate?: SortOrder
    amountDue?: SortOrder
    releaseStatus?: SortOrder
    releaseDate?: SortOrder
    holdReason?: SortOrder
    notes?: SortOrder
    aceEntryNumber?: SortOrder
    aceEntryType?: SortOrder
    dutyAmount?: SortOrder
    liquidationStatus?: SortOrder
    liquidationDate?: SortOrder
  }

  export type ShipmentMinOrderByAggregateInput = {
    shipmentReference?: SortOrder
    hbl?: SortOrder
    mbl?: SortOrder
    bookingReference?: SortOrder
    shipmentType?: SortOrder
    carrier?: SortOrder
    forwarder?: SortOrder
    shipper?: SortOrder
    consignee?: SortOrder
    pol?: SortOrder
    pod?: SortOrder
    finalDestination?: SortOrder
    contents?: SortOrder
    supplier?: SortOrder
    totalWeight?: SortOrder
    totalPieces?: SortOrder
    customerReference?: SortOrder
    poNumber?: SortOrder
    incoTerms?: SortOrder
    expectedContainers?: SortOrder
    blType?: SortOrder
    blStatus?: SortOrder
    paymentStatus?: SortOrder
    paymentDueDate?: SortOrder
    amountDue?: SortOrder
    releaseStatus?: SortOrder
    releaseDate?: SortOrder
    holdReason?: SortOrder
    notes?: SortOrder
    aceEntryNumber?: SortOrder
    aceEntryType?: SortOrder
    dutyAmount?: SortOrder
    liquidationStatus?: SortOrder
    liquidationDate?: SortOrder
  }

  export type ShipmentSumOrderByAggregateInput = {
    totalWeight?: SortOrder
    totalPieces?: SortOrder
    expectedContainers?: SortOrder
    amountDue?: SortOrder
    dutyAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TransitStageNullableRelationFilter = {
    is?: TransitStageWhereInput | null
    isNot?: TransitStageWhereInput | null
  }

  export type AttentionFlagListRelationFilter = {
    every?: AttentionFlagWhereInput
    some?: AttentionFlagWhereInput
    none?: AttentionFlagWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type StatusOverrideListRelationFilter = {
    every?: StatusOverrideWhereInput
    some?: StatusOverrideWhereInput
    none?: StatusOverrideWhereInput
  }

  export type RiskAssessmentNullableRelationFilter = {
    is?: RiskAssessmentWhereInput | null
    isNot?: RiskAssessmentWhereInput | null
  }

  export type AttentionFlagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatusOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContainerCountOrderByAggregateInput = {
    containerNumber?: SortOrder
    containerType?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrder
    currentVessel?: SortOrder
    currentVoyage?: SortOrder
    mbl?: SortOrder
    carrier?: SortOrder
    pol?: SortOrder
    pod?: SortOrder
    etd?: SortOrder
    atd?: SortOrder
    eta?: SortOrder
    ata?: SortOrder
    lastFreeDay?: SortOrder
    detentionFreeDay?: SortOrder
    statusLastUpdated?: SortOrder
    hasException?: SortOrder
    exceptionType?: SortOrder
    exceptionOwner?: SortOrder
    exceptionNotes?: SortOrder
    exceptionDate?: SortOrder
    manualPriority?: SortOrder
    priorityReason?: SortOrder
    prioritySetBy?: SortOrder
    prioritySetDate?: SortOrder
    notes?: SortOrder
    emptyIndicator?: SortOrder
    sealNumber?: SortOrder
    grossWeight?: SortOrder
    carrierEventId?: SortOrder
    aceEntryNumber?: SortOrder
    aceDisposition?: SortOrder
    aceStatus?: SortOrder
    aceLastUpdated?: SortOrder
    pgaHold?: SortOrder
    pgaAgency?: SortOrder
    pgaHoldReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerAvgOrderByAggregateInput = {
    grossWeight?: SortOrder
  }

  export type ContainerMaxOrderByAggregateInput = {
    containerNumber?: SortOrder
    containerType?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrder
    currentVessel?: SortOrder
    currentVoyage?: SortOrder
    mbl?: SortOrder
    carrier?: SortOrder
    pol?: SortOrder
    pod?: SortOrder
    etd?: SortOrder
    atd?: SortOrder
    eta?: SortOrder
    ata?: SortOrder
    lastFreeDay?: SortOrder
    detentionFreeDay?: SortOrder
    statusLastUpdated?: SortOrder
    hasException?: SortOrder
    exceptionType?: SortOrder
    exceptionOwner?: SortOrder
    exceptionNotes?: SortOrder
    exceptionDate?: SortOrder
    manualPriority?: SortOrder
    priorityReason?: SortOrder
    prioritySetBy?: SortOrder
    prioritySetDate?: SortOrder
    notes?: SortOrder
    emptyIndicator?: SortOrder
    sealNumber?: SortOrder
    grossWeight?: SortOrder
    carrierEventId?: SortOrder
    aceEntryNumber?: SortOrder
    aceDisposition?: SortOrder
    aceStatus?: SortOrder
    aceLastUpdated?: SortOrder
    pgaHold?: SortOrder
    pgaAgency?: SortOrder
    pgaHoldReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerMinOrderByAggregateInput = {
    containerNumber?: SortOrder
    containerType?: SortOrder
    currentStatus?: SortOrder
    currentLocation?: SortOrder
    currentVessel?: SortOrder
    currentVoyage?: SortOrder
    mbl?: SortOrder
    carrier?: SortOrder
    pol?: SortOrder
    pod?: SortOrder
    etd?: SortOrder
    atd?: SortOrder
    eta?: SortOrder
    ata?: SortOrder
    lastFreeDay?: SortOrder
    detentionFreeDay?: SortOrder
    statusLastUpdated?: SortOrder
    hasException?: SortOrder
    exceptionType?: SortOrder
    exceptionOwner?: SortOrder
    exceptionNotes?: SortOrder
    exceptionDate?: SortOrder
    manualPriority?: SortOrder
    priorityReason?: SortOrder
    prioritySetBy?: SortOrder
    prioritySetDate?: SortOrder
    notes?: SortOrder
    emptyIndicator?: SortOrder
    sealNumber?: SortOrder
    grossWeight?: SortOrder
    carrierEventId?: SortOrder
    aceEntryNumber?: SortOrder
    aceDisposition?: SortOrder
    aceStatus?: SortOrder
    aceLastUpdated?: SortOrder
    pgaHold?: SortOrder
    pgaAgency?: SortOrder
    pgaHoldReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerSumOrderByAggregateInput = {
    grossWeight?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ContainerRelationFilter = {
    is?: ContainerWhereInput
    isNot?: ContainerWhereInput
  }

  export type ShipmentRelationFilter = {
    is?: ShipmentWhereInput
    isNot?: ShipmentWhereInput
  }

  export type ShipmentContainerCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    containerId?: SortOrder
    piecesInContainer?: SortOrder
    weightInContainer?: SortOrder
    notes?: SortOrder
  }

  export type ShipmentContainerAvgOrderByAggregateInput = {
    piecesInContainer?: SortOrder
    weightInContainer?: SortOrder
  }

  export type ShipmentContainerMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    containerId?: SortOrder
    piecesInContainer?: SortOrder
    weightInContainer?: SortOrder
    notes?: SortOrder
  }

  export type ShipmentContainerMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    containerId?: SortOrder
    piecesInContainer?: SortOrder
    weightInContainer?: SortOrder
    notes?: SortOrder
  }

  export type ShipmentContainerSumOrderByAggregateInput = {
    piecesInContainer?: SortOrder
    weightInContainer?: SortOrder
  }

  export type FacilityNullableRelationFilter = {
    is?: FacilityWhereInput | null
    isNot?: FacilityWhereInput | null
  }

  export type ImportLogNullableRelationFilter = {
    is?: ImportLogWhereInput | null
    isNot?: ImportLogWhereInput | null
  }

  export type ContainerEventCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    stageName?: SortOrder
    eventDateTime?: SortOrder
    location?: SortOrder
    facilityId?: SortOrder
    vessel?: SortOrder
    voyage?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedBy?: SortOrder
    updatedOn?: SortOrder
    previousStatus?: SortOrder
    exceptionCleared?: SortOrder
    notes?: SortOrder
    eventCategory?: SortOrder
    eventClassifier?: SortOrder
    dcsaEventType?: SortOrder
    transportMode?: SortOrder
    facilityType?: SortOrder
    emptyIndicator?: SortOrder
    carrierEventId?: SortOrder
  }

  export type ContainerEventMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    stageName?: SortOrder
    eventDateTime?: SortOrder
    location?: SortOrder
    facilityId?: SortOrder
    vessel?: SortOrder
    voyage?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedBy?: SortOrder
    updatedOn?: SortOrder
    previousStatus?: SortOrder
    exceptionCleared?: SortOrder
    notes?: SortOrder
    eventCategory?: SortOrder
    eventClassifier?: SortOrder
    dcsaEventType?: SortOrder
    transportMode?: SortOrder
    facilityType?: SortOrder
    emptyIndicator?: SortOrder
    carrierEventId?: SortOrder
  }

  export type ContainerEventMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    stageName?: SortOrder
    eventDateTime?: SortOrder
    location?: SortOrder
    facilityId?: SortOrder
    vessel?: SortOrder
    voyage?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedBy?: SortOrder
    updatedOn?: SortOrder
    previousStatus?: SortOrder
    exceptionCleared?: SortOrder
    notes?: SortOrder
    eventCategory?: SortOrder
    eventClassifier?: SortOrder
    dcsaEventType?: SortOrder
    transportMode?: SortOrder
    facilityType?: SortOrder
    emptyIndicator?: SortOrder
    carrierEventId?: SortOrder
  }

  export type ShipmentEventCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    eventType?: SortOrder
    eventDateTime?: SortOrder
    documentType?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedBy?: SortOrder
    updatedOn?: SortOrder
    previousBLStatus?: SortOrder
    newBLStatus?: SortOrder
    notes?: SortOrder
    dcsaEventType?: SortOrder
    carrierEventId?: SortOrder
  }

  export type ShipmentEventMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    eventType?: SortOrder
    eventDateTime?: SortOrder
    documentType?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedBy?: SortOrder
    updatedOn?: SortOrder
    previousBLStatus?: SortOrder
    newBLStatus?: SortOrder
    notes?: SortOrder
    dcsaEventType?: SortOrder
    carrierEventId?: SortOrder
  }

  export type ShipmentEventMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    eventType?: SortOrder
    eventDateTime?: SortOrder
    documentType?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedBy?: SortOrder
    updatedOn?: SortOrder
    previousBLStatus?: SortOrder
    newBLStatus?: SortOrder
    notes?: SortOrder
    dcsaEventType?: SortOrder
    carrierEventId?: SortOrder
  }

  export type ShipmentNullableRelationFilter = {
    is?: ShipmentWhereInput | null
    isNot?: ShipmentWhereInput | null
  }

  export type ContainerNullableRelationFilter = {
    is?: ContainerWhereInput | null
    isNot?: ContainerWhereInput | null
  }

  export type ACEStatusLogCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    shipmentId?: SortOrder
    aceDisposition?: SortOrder
    aceStatus?: SortOrder
    previousACEStatus?: SortOrder
    holdType?: SortOrder
    pgaAgency?: SortOrder
    holdReason?: SortOrder
    eventDateTime?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedOn?: SortOrder
    notes?: SortOrder
  }

  export type ACEStatusLogMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    shipmentId?: SortOrder
    aceDisposition?: SortOrder
    aceStatus?: SortOrder
    previousACEStatus?: SortOrder
    holdType?: SortOrder
    pgaAgency?: SortOrder
    holdReason?: SortOrder
    eventDateTime?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedOn?: SortOrder
    notes?: SortOrder
  }

  export type ACEStatusLogMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    shipmentId?: SortOrder
    aceDisposition?: SortOrder
    aceStatus?: SortOrder
    previousACEStatus?: SortOrder
    holdType?: SortOrder
    pgaAgency?: SortOrder
    holdReason?: SortOrder
    eventDateTime?: SortOrder
    source?: SortOrder
    sourceFileId?: SortOrder
    updatedOn?: SortOrder
    notes?: SortOrder
  }

  export type PortNullableRelationFilter = {
    is?: PortWhereInput | null
    isNot?: PortWhereInput | null
  }

  export type FacilityCountOrderByAggregateInput = {
    facilityName?: SortOrder
    facilityCode?: SortOrder
    facilityType?: SortOrder
    portId?: SortOrder
    address?: SortOrder
    unLocationCode?: SortOrder
    isActive?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    facilityName?: SortOrder
    facilityCode?: SortOrder
    facilityType?: SortOrder
    portId?: SortOrder
    address?: SortOrder
    unLocationCode?: SortOrder
    isActive?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    facilityName?: SortOrder
    facilityCode?: SortOrder
    facilityType?: SortOrder
    portId?: SortOrder
    address?: SortOrder
    unLocationCode?: SortOrder
    isActive?: SortOrder
  }

  export type CarrierFormatListRelationFilter = {
    every?: CarrierFormatWhereInput
    some?: CarrierFormatWhereInput
    none?: CarrierFormatWhereInput
  }

  export type DemurrageRateListRelationFilter = {
    every?: DemurrageRateWhereInput
    some?: DemurrageRateWhereInput
    none?: DemurrageRateWhereInput
  }

  export type CarrierFormatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DemurrageRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarrierCountOrderByAggregateInput = {
    carrierName?: SortOrder
    scac?: SortOrder
    shortName?: SortOrder
    trackingURL?: SortOrder
    isActive?: SortOrder
    dcsaCompliant?: SortOrder
    apiEndpoint?: SortOrder
    apiCredentialRef?: SortOrder
  }

  export type CarrierMaxOrderByAggregateInput = {
    carrierName?: SortOrder
    scac?: SortOrder
    shortName?: SortOrder
    trackingURL?: SortOrder
    isActive?: SortOrder
    dcsaCompliant?: SortOrder
    apiEndpoint?: SortOrder
    apiCredentialRef?: SortOrder
  }

  export type CarrierMinOrderByAggregateInput = {
    carrierName?: SortOrder
    scac?: SortOrder
    shortName?: SortOrder
    trackingURL?: SortOrder
    isActive?: SortOrder
    dcsaCompliant?: SortOrder
    apiEndpoint?: SortOrder
    apiCredentialRef?: SortOrder
  }

  export type FacilityListRelationFilter = {
    every?: FacilityWhereInput
    some?: FacilityWhereInput
    none?: FacilityWhereInput
  }

  export type FacilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortCountOrderByAggregateInput = {
    portName?: SortOrder
    portCode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
    defaultFreeDays?: SortOrder
    isActive?: SortOrder
    acePortCode?: SortOrder
    cbpDistrict?: SortOrder
  }

  export type PortAvgOrderByAggregateInput = {
    defaultFreeDays?: SortOrder
  }

  export type PortMaxOrderByAggregateInput = {
    portName?: SortOrder
    portCode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
    defaultFreeDays?: SortOrder
    isActive?: SortOrder
    acePortCode?: SortOrder
    cbpDistrict?: SortOrder
  }

  export type PortMinOrderByAggregateInput = {
    portName?: SortOrder
    portCode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
    defaultFreeDays?: SortOrder
    isActive?: SortOrder
    acePortCode?: SortOrder
    cbpDistrict?: SortOrder
  }

  export type PortSumOrderByAggregateInput = {
    defaultFreeDays?: SortOrder
  }

  export type ForwarderCountOrderByAggregateInput = {
    forwarderName?: SortOrder
    shortName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    customsBroker?: SortOrder
    aceFilerCode?: SortOrder
  }

  export type ForwarderMaxOrderByAggregateInput = {
    forwarderName?: SortOrder
    shortName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    customsBroker?: SortOrder
    aceFilerCode?: SortOrder
  }

  export type ForwarderMinOrderByAggregateInput = {
    forwarderName?: SortOrder
    shortName?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    customsBroker?: SortOrder
    aceFilerCode?: SortOrder
  }

  export type CarrierNullableRelationFilter = {
    is?: CarrierWhereInput | null
    isNot?: CarrierWhereInput | null
  }

  export type DemurrageRateCountOrderByAggregateInput = {
    name?: SortOrder
    carrierId?: SortOrder
    portId?: SortOrder
    containerType?: SortOrder
    freeDays?: SortOrder
    dailyRate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    notes?: SortOrder
  }

  export type DemurrageRateAvgOrderByAggregateInput = {
    freeDays?: SortOrder
    dailyRate?: SortOrder
  }

  export type DemurrageRateMaxOrderByAggregateInput = {
    name?: SortOrder
    carrierId?: SortOrder
    portId?: SortOrder
    containerType?: SortOrder
    freeDays?: SortOrder
    dailyRate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    notes?: SortOrder
  }

  export type DemurrageRateMinOrderByAggregateInput = {
    name?: SortOrder
    carrierId?: SortOrder
    portId?: SortOrder
    containerType?: SortOrder
    freeDays?: SortOrder
    dailyRate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    notes?: SortOrder
  }

  export type DemurrageRateSumOrderByAggregateInput = {
    freeDays?: SortOrder
    dailyRate?: SortOrder
  }

  export type ImportLogListRelationFilter = {
    every?: ImportLogWhereInput
    some?: ImportLogWhereInput
    none?: ImportLogWhereInput
  }

  export type ImportLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarrierFormatCountOrderByAggregateInput = {
    formatName?: SortOrder
    carrierId?: SortOrder
    formatType?: SortOrder
    columnMapping?: SortOrder
    sampleHeaders?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
  }

  export type CarrierFormatMaxOrderByAggregateInput = {
    formatName?: SortOrder
    carrierId?: SortOrder
    formatType?: SortOrder
    columnMapping?: SortOrder
    sampleHeaders?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
  }

  export type CarrierFormatMinOrderByAggregateInput = {
    formatName?: SortOrder
    carrierId?: SortOrder
    formatType?: SortOrder
    columnMapping?: SortOrder
    sampleHeaders?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
  }

  export type DCSAEventMapCountOrderByAggregateInput = {
    name?: SortOrder
    carrierId?: SortOrder
    sourceEventCode?: SortOrder
    sourceEventName?: SortOrder
    dcsaEventType?: SortOrder
    transitStageName?: SortOrder
    eventCategory?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
  }

  export type DCSAEventMapMaxOrderByAggregateInput = {
    name?: SortOrder
    carrierId?: SortOrder
    sourceEventCode?: SortOrder
    sourceEventName?: SortOrder
    dcsaEventType?: SortOrder
    transitStageName?: SortOrder
    eventCategory?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
  }

  export type DCSAEventMapMinOrderByAggregateInput = {
    name?: SortOrder
    carrierId?: SortOrder
    sourceEventCode?: SortOrder
    sourceEventName?: SortOrder
    dcsaEventType?: SortOrder
    transitStageName?: SortOrder
    eventCategory?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
  }

  export type AttentionFlagCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    reason?: SortOrder
    priority?: SortOrder
    flaggedBy?: SortOrder
    flaggedOn?: SortOrder
    owner?: SortOrder
    notes?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedDate?: SortOrder
    resolutionNote?: SortOrder
  }

  export type AttentionFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    reason?: SortOrder
    priority?: SortOrder
    flaggedBy?: SortOrder
    flaggedOn?: SortOrder
    owner?: SortOrder
    notes?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedDate?: SortOrder
    resolutionNote?: SortOrder
  }

  export type AttentionFlagMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    reason?: SortOrder
    priority?: SortOrder
    flaggedBy?: SortOrder
    flaggedOn?: SortOrder
    owner?: SortOrder
    notes?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedDate?: SortOrder
    resolutionNote?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    detail?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    detail?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    shipmentId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    detail?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type StatusOverrideCountOrderByAggregateInput = {
    id?: SortOrder
    containerNumber?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    reason?: SortOrder
    overriddenBy?: SortOrder
    overriddenAt?: SortOrder
  }

  export type StatusOverrideMaxOrderByAggregateInput = {
    id?: SortOrder
    containerNumber?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    reason?: SortOrder
    overriddenBy?: SortOrder
    overriddenAt?: SortOrder
  }

  export type StatusOverrideMinOrderByAggregateInput = {
    id?: SortOrder
    containerNumber?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    reason?: SortOrder
    overriddenBy?: SortOrder
    overriddenAt?: SortOrder
  }

  export type RiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    recommendations?: SortOrder
    lastUpdated?: SortOrder
  }

  export type RiskAssessmentAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type RiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    recommendations?: SortOrder
    lastUpdated?: SortOrder
  }

  export type RiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    riskScore?: SortOrder
    riskFactors?: SortOrder
    recommendations?: SortOrder
    lastUpdated?: SortOrder
  }

  export type RiskAssessmentSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type ACEStatusLogCreateNestedManyWithoutImportLogInput = {
    create?: XOR<ACEStatusLogCreateWithoutImportLogInput, ACEStatusLogUncheckedCreateWithoutImportLogInput> | ACEStatusLogCreateWithoutImportLogInput[] | ACEStatusLogUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutImportLogInput | ACEStatusLogCreateOrConnectWithoutImportLogInput[]
    createMany?: ACEStatusLogCreateManyImportLogInputEnvelope
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
  }

  export type ContainerEventCreateNestedManyWithoutImportLogInput = {
    create?: XOR<ContainerEventCreateWithoutImportLogInput, ContainerEventUncheckedCreateWithoutImportLogInput> | ContainerEventCreateWithoutImportLogInput[] | ContainerEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutImportLogInput | ContainerEventCreateOrConnectWithoutImportLogInput[]
    createMany?: ContainerEventCreateManyImportLogInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type CarrierFormatCreateNestedOneWithoutImportLogsInput = {
    create?: XOR<CarrierFormatCreateWithoutImportLogsInput, CarrierFormatUncheckedCreateWithoutImportLogsInput>
    connectOrCreate?: CarrierFormatCreateOrConnectWithoutImportLogsInput
    connect?: CarrierFormatWhereUniqueInput
  }

  export type RawRowCreateNestedManyWithoutImportLogInput = {
    create?: XOR<RawRowCreateWithoutImportLogInput, RawRowUncheckedCreateWithoutImportLogInput> | RawRowCreateWithoutImportLogInput[] | RawRowUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: RawRowCreateOrConnectWithoutImportLogInput | RawRowCreateOrConnectWithoutImportLogInput[]
    createMany?: RawRowCreateManyImportLogInputEnvelope
    connect?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
  }

  export type ShipmentEventCreateNestedManyWithoutImportLogInput = {
    create?: XOR<ShipmentEventCreateWithoutImportLogInput, ShipmentEventUncheckedCreateWithoutImportLogInput> | ShipmentEventCreateWithoutImportLogInput[] | ShipmentEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutImportLogInput | ShipmentEventCreateOrConnectWithoutImportLogInput[]
    createMany?: ShipmentEventCreateManyImportLogInputEnvelope
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
  }

  export type ACEStatusLogUncheckedCreateNestedManyWithoutImportLogInput = {
    create?: XOR<ACEStatusLogCreateWithoutImportLogInput, ACEStatusLogUncheckedCreateWithoutImportLogInput> | ACEStatusLogCreateWithoutImportLogInput[] | ACEStatusLogUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutImportLogInput | ACEStatusLogCreateOrConnectWithoutImportLogInput[]
    createMany?: ACEStatusLogCreateManyImportLogInputEnvelope
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
  }

  export type ContainerEventUncheckedCreateNestedManyWithoutImportLogInput = {
    create?: XOR<ContainerEventCreateWithoutImportLogInput, ContainerEventUncheckedCreateWithoutImportLogInput> | ContainerEventCreateWithoutImportLogInput[] | ContainerEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutImportLogInput | ContainerEventCreateOrConnectWithoutImportLogInput[]
    createMany?: ContainerEventCreateManyImportLogInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type RawRowUncheckedCreateNestedManyWithoutImportLogInput = {
    create?: XOR<RawRowCreateWithoutImportLogInput, RawRowUncheckedCreateWithoutImportLogInput> | RawRowCreateWithoutImportLogInput[] | RawRowUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: RawRowCreateOrConnectWithoutImportLogInput | RawRowCreateOrConnectWithoutImportLogInput[]
    createMany?: RawRowCreateManyImportLogInputEnvelope
    connect?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
  }

  export type ShipmentEventUncheckedCreateNestedManyWithoutImportLogInput = {
    create?: XOR<ShipmentEventCreateWithoutImportLogInput, ShipmentEventUncheckedCreateWithoutImportLogInput> | ShipmentEventCreateWithoutImportLogInput[] | ShipmentEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutImportLogInput | ShipmentEventCreateOrConnectWithoutImportLogInput[]
    createMany?: ShipmentEventCreateManyImportLogInputEnvelope
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ACEStatusLogUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<ACEStatusLogCreateWithoutImportLogInput, ACEStatusLogUncheckedCreateWithoutImportLogInput> | ACEStatusLogCreateWithoutImportLogInput[] | ACEStatusLogUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutImportLogInput | ACEStatusLogCreateOrConnectWithoutImportLogInput[]
    upsert?: ACEStatusLogUpsertWithWhereUniqueWithoutImportLogInput | ACEStatusLogUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: ACEStatusLogCreateManyImportLogInputEnvelope
    set?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    disconnect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    delete?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    update?: ACEStatusLogUpdateWithWhereUniqueWithoutImportLogInput | ACEStatusLogUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: ACEStatusLogUpdateManyWithWhereWithoutImportLogInput | ACEStatusLogUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
  }

  export type ContainerEventUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<ContainerEventCreateWithoutImportLogInput, ContainerEventUncheckedCreateWithoutImportLogInput> | ContainerEventCreateWithoutImportLogInput[] | ContainerEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutImportLogInput | ContainerEventCreateOrConnectWithoutImportLogInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutImportLogInput | ContainerEventUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: ContainerEventCreateManyImportLogInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutImportLogInput | ContainerEventUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutImportLogInput | ContainerEventUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type CarrierFormatUpdateOneWithoutImportLogsNestedInput = {
    create?: XOR<CarrierFormatCreateWithoutImportLogsInput, CarrierFormatUncheckedCreateWithoutImportLogsInput>
    connectOrCreate?: CarrierFormatCreateOrConnectWithoutImportLogsInput
    upsert?: CarrierFormatUpsertWithoutImportLogsInput
    disconnect?: CarrierFormatWhereInput | boolean
    delete?: CarrierFormatWhereInput | boolean
    connect?: CarrierFormatWhereUniqueInput
    update?: XOR<XOR<CarrierFormatUpdateToOneWithWhereWithoutImportLogsInput, CarrierFormatUpdateWithoutImportLogsInput>, CarrierFormatUncheckedUpdateWithoutImportLogsInput>
  }

  export type RawRowUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<RawRowCreateWithoutImportLogInput, RawRowUncheckedCreateWithoutImportLogInput> | RawRowCreateWithoutImportLogInput[] | RawRowUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: RawRowCreateOrConnectWithoutImportLogInput | RawRowCreateOrConnectWithoutImportLogInput[]
    upsert?: RawRowUpsertWithWhereUniqueWithoutImportLogInput | RawRowUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: RawRowCreateManyImportLogInputEnvelope
    set?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    disconnect?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    delete?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    connect?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    update?: RawRowUpdateWithWhereUniqueWithoutImportLogInput | RawRowUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: RawRowUpdateManyWithWhereWithoutImportLogInput | RawRowUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: RawRowScalarWhereInput | RawRowScalarWhereInput[]
  }

  export type ShipmentEventUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<ShipmentEventCreateWithoutImportLogInput, ShipmentEventUncheckedCreateWithoutImportLogInput> | ShipmentEventCreateWithoutImportLogInput[] | ShipmentEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutImportLogInput | ShipmentEventCreateOrConnectWithoutImportLogInput[]
    upsert?: ShipmentEventUpsertWithWhereUniqueWithoutImportLogInput | ShipmentEventUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: ShipmentEventCreateManyImportLogInputEnvelope
    set?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    disconnect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    delete?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    update?: ShipmentEventUpdateWithWhereUniqueWithoutImportLogInput | ShipmentEventUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: ShipmentEventUpdateManyWithWhereWithoutImportLogInput | ShipmentEventUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: ShipmentEventScalarWhereInput | ShipmentEventScalarWhereInput[]
  }

  export type ACEStatusLogUncheckedUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<ACEStatusLogCreateWithoutImportLogInput, ACEStatusLogUncheckedCreateWithoutImportLogInput> | ACEStatusLogCreateWithoutImportLogInput[] | ACEStatusLogUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutImportLogInput | ACEStatusLogCreateOrConnectWithoutImportLogInput[]
    upsert?: ACEStatusLogUpsertWithWhereUniqueWithoutImportLogInput | ACEStatusLogUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: ACEStatusLogCreateManyImportLogInputEnvelope
    set?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    disconnect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    delete?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    update?: ACEStatusLogUpdateWithWhereUniqueWithoutImportLogInput | ACEStatusLogUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: ACEStatusLogUpdateManyWithWhereWithoutImportLogInput | ACEStatusLogUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
  }

  export type ContainerEventUncheckedUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<ContainerEventCreateWithoutImportLogInput, ContainerEventUncheckedCreateWithoutImportLogInput> | ContainerEventCreateWithoutImportLogInput[] | ContainerEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutImportLogInput | ContainerEventCreateOrConnectWithoutImportLogInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutImportLogInput | ContainerEventUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: ContainerEventCreateManyImportLogInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutImportLogInput | ContainerEventUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutImportLogInput | ContainerEventUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type RawRowUncheckedUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<RawRowCreateWithoutImportLogInput, RawRowUncheckedCreateWithoutImportLogInput> | RawRowCreateWithoutImportLogInput[] | RawRowUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: RawRowCreateOrConnectWithoutImportLogInput | RawRowCreateOrConnectWithoutImportLogInput[]
    upsert?: RawRowUpsertWithWhereUniqueWithoutImportLogInput | RawRowUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: RawRowCreateManyImportLogInputEnvelope
    set?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    disconnect?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    delete?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    connect?: RawRowWhereUniqueInput | RawRowWhereUniqueInput[]
    update?: RawRowUpdateWithWhereUniqueWithoutImportLogInput | RawRowUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: RawRowUpdateManyWithWhereWithoutImportLogInput | RawRowUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: RawRowScalarWhereInput | RawRowScalarWhereInput[]
  }

  export type ShipmentEventUncheckedUpdateManyWithoutImportLogNestedInput = {
    create?: XOR<ShipmentEventCreateWithoutImportLogInput, ShipmentEventUncheckedCreateWithoutImportLogInput> | ShipmentEventCreateWithoutImportLogInput[] | ShipmentEventUncheckedCreateWithoutImportLogInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutImportLogInput | ShipmentEventCreateOrConnectWithoutImportLogInput[]
    upsert?: ShipmentEventUpsertWithWhereUniqueWithoutImportLogInput | ShipmentEventUpsertWithWhereUniqueWithoutImportLogInput[]
    createMany?: ShipmentEventCreateManyImportLogInputEnvelope
    set?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    disconnect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    delete?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    update?: ShipmentEventUpdateWithWhereUniqueWithoutImportLogInput | ShipmentEventUpdateWithWhereUniqueWithoutImportLogInput[]
    updateMany?: ShipmentEventUpdateManyWithWhereWithoutImportLogInput | ShipmentEventUpdateManyWithWhereWithoutImportLogInput[]
    deleteMany?: ShipmentEventScalarWhereInput | ShipmentEventScalarWhereInput[]
  }

  export type ImportLogCreateNestedOneWithoutRawRowsInput = {
    create?: XOR<ImportLogCreateWithoutRawRowsInput, ImportLogUncheckedCreateWithoutRawRowsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutRawRowsInput
    connect?: ImportLogWhereUniqueInput
  }

  export type ImportLogUpdateOneRequiredWithoutRawRowsNestedInput = {
    create?: XOR<ImportLogCreateWithoutRawRowsInput, ImportLogUncheckedCreateWithoutRawRowsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutRawRowsInput
    upsert?: ImportLogUpsertWithoutRawRowsInput
    connect?: ImportLogWhereUniqueInput
    update?: XOR<XOR<ImportLogUpdateToOneWithWhereWithoutRawRowsInput, ImportLogUpdateWithoutRawRowsInput>, ImportLogUncheckedUpdateWithoutRawRowsInput>
  }

  export type ContainerCreateNestedManyWithoutStageInput = {
    create?: XOR<ContainerCreateWithoutStageInput, ContainerUncheckedCreateWithoutStageInput> | ContainerCreateWithoutStageInput[] | ContainerUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutStageInput | ContainerCreateOrConnectWithoutStageInput[]
    createMany?: ContainerCreateManyStageInputEnvelope
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
  }

  export type ContainerEventCreateNestedManyWithoutPreviousStageInput = {
    create?: XOR<ContainerEventCreateWithoutPreviousStageInput, ContainerEventUncheckedCreateWithoutPreviousStageInput> | ContainerEventCreateWithoutPreviousStageInput[] | ContainerEventUncheckedCreateWithoutPreviousStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutPreviousStageInput | ContainerEventCreateOrConnectWithoutPreviousStageInput[]
    createMany?: ContainerEventCreateManyPreviousStageInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type ContainerEventCreateNestedManyWithoutStageInput = {
    create?: XOR<ContainerEventCreateWithoutStageInput, ContainerEventUncheckedCreateWithoutStageInput> | ContainerEventCreateWithoutStageInput[] | ContainerEventUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutStageInput | ContainerEventCreateOrConnectWithoutStageInput[]
    createMany?: ContainerEventCreateManyStageInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type DCSAEventMapCreateNestedManyWithoutTransitStageInput = {
    create?: XOR<DCSAEventMapCreateWithoutTransitStageInput, DCSAEventMapUncheckedCreateWithoutTransitStageInput> | DCSAEventMapCreateWithoutTransitStageInput[] | DCSAEventMapUncheckedCreateWithoutTransitStageInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutTransitStageInput | DCSAEventMapCreateOrConnectWithoutTransitStageInput[]
    createMany?: DCSAEventMapCreateManyTransitStageInputEnvelope
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
  }

  export type ContainerUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<ContainerCreateWithoutStageInput, ContainerUncheckedCreateWithoutStageInput> | ContainerCreateWithoutStageInput[] | ContainerUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutStageInput | ContainerCreateOrConnectWithoutStageInput[]
    createMany?: ContainerCreateManyStageInputEnvelope
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
  }

  export type ContainerEventUncheckedCreateNestedManyWithoutPreviousStageInput = {
    create?: XOR<ContainerEventCreateWithoutPreviousStageInput, ContainerEventUncheckedCreateWithoutPreviousStageInput> | ContainerEventCreateWithoutPreviousStageInput[] | ContainerEventUncheckedCreateWithoutPreviousStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutPreviousStageInput | ContainerEventCreateOrConnectWithoutPreviousStageInput[]
    createMany?: ContainerEventCreateManyPreviousStageInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type ContainerEventUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<ContainerEventCreateWithoutStageInput, ContainerEventUncheckedCreateWithoutStageInput> | ContainerEventCreateWithoutStageInput[] | ContainerEventUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutStageInput | ContainerEventCreateOrConnectWithoutStageInput[]
    createMany?: ContainerEventCreateManyStageInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type DCSAEventMapUncheckedCreateNestedManyWithoutTransitStageInput = {
    create?: XOR<DCSAEventMapCreateWithoutTransitStageInput, DCSAEventMapUncheckedCreateWithoutTransitStageInput> | DCSAEventMapCreateWithoutTransitStageInput[] | DCSAEventMapUncheckedCreateWithoutTransitStageInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutTransitStageInput | DCSAEventMapCreateOrConnectWithoutTransitStageInput[]
    createMany?: DCSAEventMapCreateManyTransitStageInputEnvelope
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ContainerUpdateManyWithoutStageNestedInput = {
    create?: XOR<ContainerCreateWithoutStageInput, ContainerUncheckedCreateWithoutStageInput> | ContainerCreateWithoutStageInput[] | ContainerUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutStageInput | ContainerCreateOrConnectWithoutStageInput[]
    upsert?: ContainerUpsertWithWhereUniqueWithoutStageInput | ContainerUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: ContainerCreateManyStageInputEnvelope
    set?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    disconnect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    delete?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    update?: ContainerUpdateWithWhereUniqueWithoutStageInput | ContainerUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: ContainerUpdateManyWithWhereWithoutStageInput | ContainerUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
  }

  export type ContainerEventUpdateManyWithoutPreviousStageNestedInput = {
    create?: XOR<ContainerEventCreateWithoutPreviousStageInput, ContainerEventUncheckedCreateWithoutPreviousStageInput> | ContainerEventCreateWithoutPreviousStageInput[] | ContainerEventUncheckedCreateWithoutPreviousStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutPreviousStageInput | ContainerEventCreateOrConnectWithoutPreviousStageInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutPreviousStageInput | ContainerEventUpsertWithWhereUniqueWithoutPreviousStageInput[]
    createMany?: ContainerEventCreateManyPreviousStageInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutPreviousStageInput | ContainerEventUpdateWithWhereUniqueWithoutPreviousStageInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutPreviousStageInput | ContainerEventUpdateManyWithWhereWithoutPreviousStageInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type ContainerEventUpdateManyWithoutStageNestedInput = {
    create?: XOR<ContainerEventCreateWithoutStageInput, ContainerEventUncheckedCreateWithoutStageInput> | ContainerEventCreateWithoutStageInput[] | ContainerEventUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutStageInput | ContainerEventCreateOrConnectWithoutStageInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutStageInput | ContainerEventUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: ContainerEventCreateManyStageInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutStageInput | ContainerEventUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutStageInput | ContainerEventUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type DCSAEventMapUpdateManyWithoutTransitStageNestedInput = {
    create?: XOR<DCSAEventMapCreateWithoutTransitStageInput, DCSAEventMapUncheckedCreateWithoutTransitStageInput> | DCSAEventMapCreateWithoutTransitStageInput[] | DCSAEventMapUncheckedCreateWithoutTransitStageInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutTransitStageInput | DCSAEventMapCreateOrConnectWithoutTransitStageInput[]
    upsert?: DCSAEventMapUpsertWithWhereUniqueWithoutTransitStageInput | DCSAEventMapUpsertWithWhereUniqueWithoutTransitStageInput[]
    createMany?: DCSAEventMapCreateManyTransitStageInputEnvelope
    set?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    disconnect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    delete?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    update?: DCSAEventMapUpdateWithWhereUniqueWithoutTransitStageInput | DCSAEventMapUpdateWithWhereUniqueWithoutTransitStageInput[]
    updateMany?: DCSAEventMapUpdateManyWithWhereWithoutTransitStageInput | DCSAEventMapUpdateManyWithWhereWithoutTransitStageInput[]
    deleteMany?: DCSAEventMapScalarWhereInput | DCSAEventMapScalarWhereInput[]
  }

  export type ContainerUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<ContainerCreateWithoutStageInput, ContainerUncheckedCreateWithoutStageInput> | ContainerCreateWithoutStageInput[] | ContainerUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutStageInput | ContainerCreateOrConnectWithoutStageInput[]
    upsert?: ContainerUpsertWithWhereUniqueWithoutStageInput | ContainerUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: ContainerCreateManyStageInputEnvelope
    set?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    disconnect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    delete?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    update?: ContainerUpdateWithWhereUniqueWithoutStageInput | ContainerUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: ContainerUpdateManyWithWhereWithoutStageInput | ContainerUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
  }

  export type ContainerEventUncheckedUpdateManyWithoutPreviousStageNestedInput = {
    create?: XOR<ContainerEventCreateWithoutPreviousStageInput, ContainerEventUncheckedCreateWithoutPreviousStageInput> | ContainerEventCreateWithoutPreviousStageInput[] | ContainerEventUncheckedCreateWithoutPreviousStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutPreviousStageInput | ContainerEventCreateOrConnectWithoutPreviousStageInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutPreviousStageInput | ContainerEventUpsertWithWhereUniqueWithoutPreviousStageInput[]
    createMany?: ContainerEventCreateManyPreviousStageInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutPreviousStageInput | ContainerEventUpdateWithWhereUniqueWithoutPreviousStageInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutPreviousStageInput | ContainerEventUpdateManyWithWhereWithoutPreviousStageInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type ContainerEventUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<ContainerEventCreateWithoutStageInput, ContainerEventUncheckedCreateWithoutStageInput> | ContainerEventCreateWithoutStageInput[] | ContainerEventUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutStageInput | ContainerEventCreateOrConnectWithoutStageInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutStageInput | ContainerEventUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: ContainerEventCreateManyStageInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutStageInput | ContainerEventUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutStageInput | ContainerEventUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type DCSAEventMapUncheckedUpdateManyWithoutTransitStageNestedInput = {
    create?: XOR<DCSAEventMapCreateWithoutTransitStageInput, DCSAEventMapUncheckedCreateWithoutTransitStageInput> | DCSAEventMapCreateWithoutTransitStageInput[] | DCSAEventMapUncheckedCreateWithoutTransitStageInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutTransitStageInput | DCSAEventMapCreateOrConnectWithoutTransitStageInput[]
    upsert?: DCSAEventMapUpsertWithWhereUniqueWithoutTransitStageInput | DCSAEventMapUpsertWithWhereUniqueWithoutTransitStageInput[]
    createMany?: DCSAEventMapCreateManyTransitStageInputEnvelope
    set?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    disconnect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    delete?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    update?: DCSAEventMapUpdateWithWhereUniqueWithoutTransitStageInput | DCSAEventMapUpdateWithWhereUniqueWithoutTransitStageInput[]
    updateMany?: DCSAEventMapUpdateManyWithWhereWithoutTransitStageInput | DCSAEventMapUpdateManyWithWhereWithoutTransitStageInput[]
    deleteMany?: DCSAEventMapScalarWhereInput | DCSAEventMapScalarWhereInput[]
  }

  export type ACEStatusLogCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ACEStatusLogCreateWithoutShipmentInput, ACEStatusLogUncheckedCreateWithoutShipmentInput> | ACEStatusLogCreateWithoutShipmentInput[] | ACEStatusLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutShipmentInput | ACEStatusLogCreateOrConnectWithoutShipmentInput[]
    createMany?: ACEStatusLogCreateManyShipmentInputEnvelope
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
  }

  export type ShipmentContainerCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentContainerCreateWithoutShipmentInput, ShipmentContainerUncheckedCreateWithoutShipmentInput> | ShipmentContainerCreateWithoutShipmentInput[] | ShipmentContainerUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutShipmentInput | ShipmentContainerCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentContainerCreateManyShipmentInputEnvelope
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
  }

  export type ShipmentEventCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentEventCreateWithoutShipmentInput, ShipmentEventUncheckedCreateWithoutShipmentInput> | ShipmentEventCreateWithoutShipmentInput[] | ShipmentEventUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutShipmentInput | ShipmentEventCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentEventCreateManyShipmentInputEnvelope
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
  }

  export type ACEStatusLogUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ACEStatusLogCreateWithoutShipmentInput, ACEStatusLogUncheckedCreateWithoutShipmentInput> | ACEStatusLogCreateWithoutShipmentInput[] | ACEStatusLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutShipmentInput | ACEStatusLogCreateOrConnectWithoutShipmentInput[]
    createMany?: ACEStatusLogCreateManyShipmentInputEnvelope
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
  }

  export type ShipmentContainerUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentContainerCreateWithoutShipmentInput, ShipmentContainerUncheckedCreateWithoutShipmentInput> | ShipmentContainerCreateWithoutShipmentInput[] | ShipmentContainerUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutShipmentInput | ShipmentContainerCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentContainerCreateManyShipmentInputEnvelope
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
  }

  export type ShipmentEventUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ShipmentEventCreateWithoutShipmentInput, ShipmentEventUncheckedCreateWithoutShipmentInput> | ShipmentEventCreateWithoutShipmentInput[] | ShipmentEventUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutShipmentInput | ShipmentEventCreateOrConnectWithoutShipmentInput[]
    createMany?: ShipmentEventCreateManyShipmentInputEnvelope
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ACEStatusLogUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ACEStatusLogCreateWithoutShipmentInput, ACEStatusLogUncheckedCreateWithoutShipmentInput> | ACEStatusLogCreateWithoutShipmentInput[] | ACEStatusLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutShipmentInput | ACEStatusLogCreateOrConnectWithoutShipmentInput[]
    upsert?: ACEStatusLogUpsertWithWhereUniqueWithoutShipmentInput | ACEStatusLogUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ACEStatusLogCreateManyShipmentInputEnvelope
    set?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    disconnect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    delete?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    update?: ACEStatusLogUpdateWithWhereUniqueWithoutShipmentInput | ACEStatusLogUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ACEStatusLogUpdateManyWithWhereWithoutShipmentInput | ACEStatusLogUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
  }

  export type ShipmentContainerUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentContainerCreateWithoutShipmentInput, ShipmentContainerUncheckedCreateWithoutShipmentInput> | ShipmentContainerCreateWithoutShipmentInput[] | ShipmentContainerUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutShipmentInput | ShipmentContainerCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentContainerUpsertWithWhereUniqueWithoutShipmentInput | ShipmentContainerUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentContainerCreateManyShipmentInputEnvelope
    set?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    disconnect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    delete?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    update?: ShipmentContainerUpdateWithWhereUniqueWithoutShipmentInput | ShipmentContainerUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentContainerUpdateManyWithWhereWithoutShipmentInput | ShipmentContainerUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentContainerScalarWhereInput | ShipmentContainerScalarWhereInput[]
  }

  export type ShipmentEventUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentEventCreateWithoutShipmentInput, ShipmentEventUncheckedCreateWithoutShipmentInput> | ShipmentEventCreateWithoutShipmentInput[] | ShipmentEventUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutShipmentInput | ShipmentEventCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentEventUpsertWithWhereUniqueWithoutShipmentInput | ShipmentEventUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentEventCreateManyShipmentInputEnvelope
    set?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    disconnect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    delete?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    update?: ShipmentEventUpdateWithWhereUniqueWithoutShipmentInput | ShipmentEventUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentEventUpdateManyWithWhereWithoutShipmentInput | ShipmentEventUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentEventScalarWhereInput | ShipmentEventScalarWhereInput[]
  }

  export type ACEStatusLogUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ACEStatusLogCreateWithoutShipmentInput, ACEStatusLogUncheckedCreateWithoutShipmentInput> | ACEStatusLogCreateWithoutShipmentInput[] | ACEStatusLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutShipmentInput | ACEStatusLogCreateOrConnectWithoutShipmentInput[]
    upsert?: ACEStatusLogUpsertWithWhereUniqueWithoutShipmentInput | ACEStatusLogUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ACEStatusLogCreateManyShipmentInputEnvelope
    set?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    disconnect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    delete?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    update?: ACEStatusLogUpdateWithWhereUniqueWithoutShipmentInput | ACEStatusLogUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ACEStatusLogUpdateManyWithWhereWithoutShipmentInput | ACEStatusLogUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
  }

  export type ShipmentContainerUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentContainerCreateWithoutShipmentInput, ShipmentContainerUncheckedCreateWithoutShipmentInput> | ShipmentContainerCreateWithoutShipmentInput[] | ShipmentContainerUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutShipmentInput | ShipmentContainerCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentContainerUpsertWithWhereUniqueWithoutShipmentInput | ShipmentContainerUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentContainerCreateManyShipmentInputEnvelope
    set?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    disconnect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    delete?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    update?: ShipmentContainerUpdateWithWhereUniqueWithoutShipmentInput | ShipmentContainerUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentContainerUpdateManyWithWhereWithoutShipmentInput | ShipmentContainerUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentContainerScalarWhereInput | ShipmentContainerScalarWhereInput[]
  }

  export type ShipmentEventUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ShipmentEventCreateWithoutShipmentInput, ShipmentEventUncheckedCreateWithoutShipmentInput> | ShipmentEventCreateWithoutShipmentInput[] | ShipmentEventUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ShipmentEventCreateOrConnectWithoutShipmentInput | ShipmentEventCreateOrConnectWithoutShipmentInput[]
    upsert?: ShipmentEventUpsertWithWhereUniqueWithoutShipmentInput | ShipmentEventUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ShipmentEventCreateManyShipmentInputEnvelope
    set?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    disconnect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    delete?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    connect?: ShipmentEventWhereUniqueInput | ShipmentEventWhereUniqueInput[]
    update?: ShipmentEventUpdateWithWhereUniqueWithoutShipmentInput | ShipmentEventUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ShipmentEventUpdateManyWithWhereWithoutShipmentInput | ShipmentEventUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ShipmentEventScalarWhereInput | ShipmentEventScalarWhereInput[]
  }

  export type ACEStatusLogCreateNestedManyWithoutContainerInput = {
    create?: XOR<ACEStatusLogCreateWithoutContainerInput, ACEStatusLogUncheckedCreateWithoutContainerInput> | ACEStatusLogCreateWithoutContainerInput[] | ACEStatusLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutContainerInput | ACEStatusLogCreateOrConnectWithoutContainerInput[]
    createMany?: ACEStatusLogCreateManyContainerInputEnvelope
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
  }

  export type TransitStageCreateNestedOneWithoutContainersInput = {
    create?: XOR<TransitStageCreateWithoutContainersInput, TransitStageUncheckedCreateWithoutContainersInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutContainersInput
    connect?: TransitStageWhereUniqueInput
  }

  export type ContainerEventCreateNestedManyWithoutContainerInput = {
    create?: XOR<ContainerEventCreateWithoutContainerInput, ContainerEventUncheckedCreateWithoutContainerInput> | ContainerEventCreateWithoutContainerInput[] | ContainerEventUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutContainerInput | ContainerEventCreateOrConnectWithoutContainerInput[]
    createMany?: ContainerEventCreateManyContainerInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type ShipmentContainerCreateNestedManyWithoutContainerInput = {
    create?: XOR<ShipmentContainerCreateWithoutContainerInput, ShipmentContainerUncheckedCreateWithoutContainerInput> | ShipmentContainerCreateWithoutContainerInput[] | ShipmentContainerUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutContainerInput | ShipmentContainerCreateOrConnectWithoutContainerInput[]
    createMany?: ShipmentContainerCreateManyContainerInputEnvelope
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
  }

  export type AttentionFlagCreateNestedManyWithoutContainerInput = {
    create?: XOR<AttentionFlagCreateWithoutContainerInput, AttentionFlagUncheckedCreateWithoutContainerInput> | AttentionFlagCreateWithoutContainerInput[] | AttentionFlagUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: AttentionFlagCreateOrConnectWithoutContainerInput | AttentionFlagCreateOrConnectWithoutContainerInput[]
    createMany?: AttentionFlagCreateManyContainerInputEnvelope
    connect?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutContainerInput = {
    create?: XOR<ActivityLogCreateWithoutContainerInput, ActivityLogUncheckedCreateWithoutContainerInput> | ActivityLogCreateWithoutContainerInput[] | ActivityLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutContainerInput | ActivityLogCreateOrConnectWithoutContainerInput[]
    createMany?: ActivityLogCreateManyContainerInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type StatusOverrideCreateNestedManyWithoutContainerInput = {
    create?: XOR<StatusOverrideCreateWithoutContainerInput, StatusOverrideUncheckedCreateWithoutContainerInput> | StatusOverrideCreateWithoutContainerInput[] | StatusOverrideUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: StatusOverrideCreateOrConnectWithoutContainerInput | StatusOverrideCreateOrConnectWithoutContainerInput[]
    createMany?: StatusOverrideCreateManyContainerInputEnvelope
    connect?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
  }

  export type RiskAssessmentCreateNestedOneWithoutContainerInput = {
    create?: XOR<RiskAssessmentCreateWithoutContainerInput, RiskAssessmentUncheckedCreateWithoutContainerInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutContainerInput
    connect?: RiskAssessmentWhereUniqueInput
  }

  export type ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<ACEStatusLogCreateWithoutContainerInput, ACEStatusLogUncheckedCreateWithoutContainerInput> | ACEStatusLogCreateWithoutContainerInput[] | ACEStatusLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutContainerInput | ACEStatusLogCreateOrConnectWithoutContainerInput[]
    createMany?: ACEStatusLogCreateManyContainerInputEnvelope
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
  }

  export type ContainerEventUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<ContainerEventCreateWithoutContainerInput, ContainerEventUncheckedCreateWithoutContainerInput> | ContainerEventCreateWithoutContainerInput[] | ContainerEventUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutContainerInput | ContainerEventCreateOrConnectWithoutContainerInput[]
    createMany?: ContainerEventCreateManyContainerInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<ShipmentContainerCreateWithoutContainerInput, ShipmentContainerUncheckedCreateWithoutContainerInput> | ShipmentContainerCreateWithoutContainerInput[] | ShipmentContainerUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutContainerInput | ShipmentContainerCreateOrConnectWithoutContainerInput[]
    createMany?: ShipmentContainerCreateManyContainerInputEnvelope
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
  }

  export type AttentionFlagUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<AttentionFlagCreateWithoutContainerInput, AttentionFlagUncheckedCreateWithoutContainerInput> | AttentionFlagCreateWithoutContainerInput[] | AttentionFlagUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: AttentionFlagCreateOrConnectWithoutContainerInput | AttentionFlagCreateOrConnectWithoutContainerInput[]
    createMany?: AttentionFlagCreateManyContainerInputEnvelope
    connect?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<ActivityLogCreateWithoutContainerInput, ActivityLogUncheckedCreateWithoutContainerInput> | ActivityLogCreateWithoutContainerInput[] | ActivityLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutContainerInput | ActivityLogCreateOrConnectWithoutContainerInput[]
    createMany?: ActivityLogCreateManyContainerInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type StatusOverrideUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<StatusOverrideCreateWithoutContainerInput, StatusOverrideUncheckedCreateWithoutContainerInput> | StatusOverrideCreateWithoutContainerInput[] | StatusOverrideUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: StatusOverrideCreateOrConnectWithoutContainerInput | StatusOverrideCreateOrConnectWithoutContainerInput[]
    createMany?: StatusOverrideCreateManyContainerInputEnvelope
    connect?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
  }

  export type RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput = {
    create?: XOR<RiskAssessmentCreateWithoutContainerInput, RiskAssessmentUncheckedCreateWithoutContainerInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutContainerInput
    connect?: RiskAssessmentWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ACEStatusLogUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ACEStatusLogCreateWithoutContainerInput, ACEStatusLogUncheckedCreateWithoutContainerInput> | ACEStatusLogCreateWithoutContainerInput[] | ACEStatusLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutContainerInput | ACEStatusLogCreateOrConnectWithoutContainerInput[]
    upsert?: ACEStatusLogUpsertWithWhereUniqueWithoutContainerInput | ACEStatusLogUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ACEStatusLogCreateManyContainerInputEnvelope
    set?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    disconnect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    delete?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    update?: ACEStatusLogUpdateWithWhereUniqueWithoutContainerInput | ACEStatusLogUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ACEStatusLogUpdateManyWithWhereWithoutContainerInput | ACEStatusLogUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
  }

  export type TransitStageUpdateOneWithoutContainersNestedInput = {
    create?: XOR<TransitStageCreateWithoutContainersInput, TransitStageUncheckedCreateWithoutContainersInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutContainersInput
    upsert?: TransitStageUpsertWithoutContainersInput
    disconnect?: TransitStageWhereInput | boolean
    delete?: TransitStageWhereInput | boolean
    connect?: TransitStageWhereUniqueInput
    update?: XOR<XOR<TransitStageUpdateToOneWithWhereWithoutContainersInput, TransitStageUpdateWithoutContainersInput>, TransitStageUncheckedUpdateWithoutContainersInput>
  }

  export type ContainerEventUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ContainerEventCreateWithoutContainerInput, ContainerEventUncheckedCreateWithoutContainerInput> | ContainerEventCreateWithoutContainerInput[] | ContainerEventUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutContainerInput | ContainerEventCreateOrConnectWithoutContainerInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutContainerInput | ContainerEventUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ContainerEventCreateManyContainerInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutContainerInput | ContainerEventUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutContainerInput | ContainerEventUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type ShipmentContainerUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ShipmentContainerCreateWithoutContainerInput, ShipmentContainerUncheckedCreateWithoutContainerInput> | ShipmentContainerCreateWithoutContainerInput[] | ShipmentContainerUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutContainerInput | ShipmentContainerCreateOrConnectWithoutContainerInput[]
    upsert?: ShipmentContainerUpsertWithWhereUniqueWithoutContainerInput | ShipmentContainerUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ShipmentContainerCreateManyContainerInputEnvelope
    set?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    disconnect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    delete?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    update?: ShipmentContainerUpdateWithWhereUniqueWithoutContainerInput | ShipmentContainerUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ShipmentContainerUpdateManyWithWhereWithoutContainerInput | ShipmentContainerUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ShipmentContainerScalarWhereInput | ShipmentContainerScalarWhereInput[]
  }

  export type AttentionFlagUpdateManyWithoutContainerNestedInput = {
    create?: XOR<AttentionFlagCreateWithoutContainerInput, AttentionFlagUncheckedCreateWithoutContainerInput> | AttentionFlagCreateWithoutContainerInput[] | AttentionFlagUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: AttentionFlagCreateOrConnectWithoutContainerInput | AttentionFlagCreateOrConnectWithoutContainerInput[]
    upsert?: AttentionFlagUpsertWithWhereUniqueWithoutContainerInput | AttentionFlagUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: AttentionFlagCreateManyContainerInputEnvelope
    set?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    disconnect?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    delete?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    connect?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    update?: AttentionFlagUpdateWithWhereUniqueWithoutContainerInput | AttentionFlagUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: AttentionFlagUpdateManyWithWhereWithoutContainerInput | AttentionFlagUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: AttentionFlagScalarWhereInput | AttentionFlagScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ActivityLogCreateWithoutContainerInput, ActivityLogUncheckedCreateWithoutContainerInput> | ActivityLogCreateWithoutContainerInput[] | ActivityLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutContainerInput | ActivityLogCreateOrConnectWithoutContainerInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutContainerInput | ActivityLogUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ActivityLogCreateManyContainerInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutContainerInput | ActivityLogUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutContainerInput | ActivityLogUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type StatusOverrideUpdateManyWithoutContainerNestedInput = {
    create?: XOR<StatusOverrideCreateWithoutContainerInput, StatusOverrideUncheckedCreateWithoutContainerInput> | StatusOverrideCreateWithoutContainerInput[] | StatusOverrideUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: StatusOverrideCreateOrConnectWithoutContainerInput | StatusOverrideCreateOrConnectWithoutContainerInput[]
    upsert?: StatusOverrideUpsertWithWhereUniqueWithoutContainerInput | StatusOverrideUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: StatusOverrideCreateManyContainerInputEnvelope
    set?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    disconnect?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    delete?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    connect?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    update?: StatusOverrideUpdateWithWhereUniqueWithoutContainerInput | StatusOverrideUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: StatusOverrideUpdateManyWithWhereWithoutContainerInput | StatusOverrideUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: StatusOverrideScalarWhereInput | StatusOverrideScalarWhereInput[]
  }

  export type RiskAssessmentUpdateOneWithoutContainerNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutContainerInput, RiskAssessmentUncheckedCreateWithoutContainerInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutContainerInput
    upsert?: RiskAssessmentUpsertWithoutContainerInput
    disconnect?: RiskAssessmentWhereInput | boolean
    delete?: RiskAssessmentWhereInput | boolean
    connect?: RiskAssessmentWhereUniqueInput
    update?: XOR<XOR<RiskAssessmentUpdateToOneWithWhereWithoutContainerInput, RiskAssessmentUpdateWithoutContainerInput>, RiskAssessmentUncheckedUpdateWithoutContainerInput>
  }

  export type ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ACEStatusLogCreateWithoutContainerInput, ACEStatusLogUncheckedCreateWithoutContainerInput> | ACEStatusLogCreateWithoutContainerInput[] | ACEStatusLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ACEStatusLogCreateOrConnectWithoutContainerInput | ACEStatusLogCreateOrConnectWithoutContainerInput[]
    upsert?: ACEStatusLogUpsertWithWhereUniqueWithoutContainerInput | ACEStatusLogUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ACEStatusLogCreateManyContainerInputEnvelope
    set?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    disconnect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    delete?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    connect?: ACEStatusLogWhereUniqueInput | ACEStatusLogWhereUniqueInput[]
    update?: ACEStatusLogUpdateWithWhereUniqueWithoutContainerInput | ACEStatusLogUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ACEStatusLogUpdateManyWithWhereWithoutContainerInput | ACEStatusLogUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
  }

  export type ContainerEventUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ContainerEventCreateWithoutContainerInput, ContainerEventUncheckedCreateWithoutContainerInput> | ContainerEventCreateWithoutContainerInput[] | ContainerEventUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutContainerInput | ContainerEventCreateOrConnectWithoutContainerInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutContainerInput | ContainerEventUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ContainerEventCreateManyContainerInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutContainerInput | ContainerEventUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutContainerInput | ContainerEventUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ShipmentContainerCreateWithoutContainerInput, ShipmentContainerUncheckedCreateWithoutContainerInput> | ShipmentContainerCreateWithoutContainerInput[] | ShipmentContainerUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ShipmentContainerCreateOrConnectWithoutContainerInput | ShipmentContainerCreateOrConnectWithoutContainerInput[]
    upsert?: ShipmentContainerUpsertWithWhereUniqueWithoutContainerInput | ShipmentContainerUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ShipmentContainerCreateManyContainerInputEnvelope
    set?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    disconnect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    delete?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    connect?: ShipmentContainerWhereUniqueInput | ShipmentContainerWhereUniqueInput[]
    update?: ShipmentContainerUpdateWithWhereUniqueWithoutContainerInput | ShipmentContainerUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ShipmentContainerUpdateManyWithWhereWithoutContainerInput | ShipmentContainerUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ShipmentContainerScalarWhereInput | ShipmentContainerScalarWhereInput[]
  }

  export type AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<AttentionFlagCreateWithoutContainerInput, AttentionFlagUncheckedCreateWithoutContainerInput> | AttentionFlagCreateWithoutContainerInput[] | AttentionFlagUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: AttentionFlagCreateOrConnectWithoutContainerInput | AttentionFlagCreateOrConnectWithoutContainerInput[]
    upsert?: AttentionFlagUpsertWithWhereUniqueWithoutContainerInput | AttentionFlagUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: AttentionFlagCreateManyContainerInputEnvelope
    set?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    disconnect?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    delete?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    connect?: AttentionFlagWhereUniqueInput | AttentionFlagWhereUniqueInput[]
    update?: AttentionFlagUpdateWithWhereUniqueWithoutContainerInput | AttentionFlagUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: AttentionFlagUpdateManyWithWhereWithoutContainerInput | AttentionFlagUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: AttentionFlagScalarWhereInput | AttentionFlagScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ActivityLogCreateWithoutContainerInput, ActivityLogUncheckedCreateWithoutContainerInput> | ActivityLogCreateWithoutContainerInput[] | ActivityLogUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutContainerInput | ActivityLogCreateOrConnectWithoutContainerInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutContainerInput | ActivityLogUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ActivityLogCreateManyContainerInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutContainerInput | ActivityLogUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutContainerInput | ActivityLogUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<StatusOverrideCreateWithoutContainerInput, StatusOverrideUncheckedCreateWithoutContainerInput> | StatusOverrideCreateWithoutContainerInput[] | StatusOverrideUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: StatusOverrideCreateOrConnectWithoutContainerInput | StatusOverrideCreateOrConnectWithoutContainerInput[]
    upsert?: StatusOverrideUpsertWithWhereUniqueWithoutContainerInput | StatusOverrideUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: StatusOverrideCreateManyContainerInputEnvelope
    set?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    disconnect?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    delete?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    connect?: StatusOverrideWhereUniqueInput | StatusOverrideWhereUniqueInput[]
    update?: StatusOverrideUpdateWithWhereUniqueWithoutContainerInput | StatusOverrideUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: StatusOverrideUpdateManyWithWhereWithoutContainerInput | StatusOverrideUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: StatusOverrideScalarWhereInput | StatusOverrideScalarWhereInput[]
  }

  export type RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutContainerInput, RiskAssessmentUncheckedCreateWithoutContainerInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutContainerInput
    upsert?: RiskAssessmentUpsertWithoutContainerInput
    disconnect?: RiskAssessmentWhereInput | boolean
    delete?: RiskAssessmentWhereInput | boolean
    connect?: RiskAssessmentWhereUniqueInput
    update?: XOR<XOR<RiskAssessmentUpdateToOneWithWhereWithoutContainerInput, RiskAssessmentUpdateWithoutContainerInput>, RiskAssessmentUncheckedUpdateWithoutContainerInput>
  }

  export type ContainerCreateNestedOneWithoutShipmentContainersInput = {
    create?: XOR<ContainerCreateWithoutShipmentContainersInput, ContainerUncheckedCreateWithoutShipmentContainersInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutShipmentContainersInput
    connect?: ContainerWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutShipmentContainersInput = {
    create?: XOR<ShipmentCreateWithoutShipmentContainersInput, ShipmentUncheckedCreateWithoutShipmentContainersInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutShipmentContainersInput
    connect?: ShipmentWhereUniqueInput
  }

  export type ContainerUpdateOneRequiredWithoutShipmentContainersNestedInput = {
    create?: XOR<ContainerCreateWithoutShipmentContainersInput, ContainerUncheckedCreateWithoutShipmentContainersInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutShipmentContainersInput
    upsert?: ContainerUpsertWithoutShipmentContainersInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutShipmentContainersInput, ContainerUpdateWithoutShipmentContainersInput>, ContainerUncheckedUpdateWithoutShipmentContainersInput>
  }

  export type ShipmentUpdateOneRequiredWithoutShipmentContainersNestedInput = {
    create?: XOR<ShipmentCreateWithoutShipmentContainersInput, ShipmentUncheckedCreateWithoutShipmentContainersInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutShipmentContainersInput
    upsert?: ShipmentUpsertWithoutShipmentContainersInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutShipmentContainersInput, ShipmentUpdateWithoutShipmentContainersInput>, ShipmentUncheckedUpdateWithoutShipmentContainersInput>
  }

  export type FacilityCreateNestedOneWithoutContainerEventsInput = {
    create?: XOR<FacilityCreateWithoutContainerEventsInput, FacilityUncheckedCreateWithoutContainerEventsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutContainerEventsInput
    connect?: FacilityWhereUniqueInput
  }

  export type ImportLogCreateNestedOneWithoutContainerEventsInput = {
    create?: XOR<ImportLogCreateWithoutContainerEventsInput, ImportLogUncheckedCreateWithoutContainerEventsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutContainerEventsInput
    connect?: ImportLogWhereUniqueInput
  }

  export type TransitStageCreateNestedOneWithoutPreviousEventsInput = {
    create?: XOR<TransitStageCreateWithoutPreviousEventsInput, TransitStageUncheckedCreateWithoutPreviousEventsInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutPreviousEventsInput
    connect?: TransitStageWhereUniqueInput
  }

  export type TransitStageCreateNestedOneWithoutContainerEventsInput = {
    create?: XOR<TransitStageCreateWithoutContainerEventsInput, TransitStageUncheckedCreateWithoutContainerEventsInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutContainerEventsInput
    connect?: TransitStageWhereUniqueInput
  }

  export type ContainerCreateNestedOneWithoutEventsInput = {
    create?: XOR<ContainerCreateWithoutEventsInput, ContainerUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutEventsInput
    connect?: ContainerWhereUniqueInput
  }

  export type FacilityUpdateOneWithoutContainerEventsNestedInput = {
    create?: XOR<FacilityCreateWithoutContainerEventsInput, FacilityUncheckedCreateWithoutContainerEventsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutContainerEventsInput
    upsert?: FacilityUpsertWithoutContainerEventsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutContainerEventsInput, FacilityUpdateWithoutContainerEventsInput>, FacilityUncheckedUpdateWithoutContainerEventsInput>
  }

  export type ImportLogUpdateOneWithoutContainerEventsNestedInput = {
    create?: XOR<ImportLogCreateWithoutContainerEventsInput, ImportLogUncheckedCreateWithoutContainerEventsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutContainerEventsInput
    upsert?: ImportLogUpsertWithoutContainerEventsInput
    disconnect?: ImportLogWhereInput | boolean
    delete?: ImportLogWhereInput | boolean
    connect?: ImportLogWhereUniqueInput
    update?: XOR<XOR<ImportLogUpdateToOneWithWhereWithoutContainerEventsInput, ImportLogUpdateWithoutContainerEventsInput>, ImportLogUncheckedUpdateWithoutContainerEventsInput>
  }

  export type TransitStageUpdateOneWithoutPreviousEventsNestedInput = {
    create?: XOR<TransitStageCreateWithoutPreviousEventsInput, TransitStageUncheckedCreateWithoutPreviousEventsInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutPreviousEventsInput
    upsert?: TransitStageUpsertWithoutPreviousEventsInput
    disconnect?: TransitStageWhereInput | boolean
    delete?: TransitStageWhereInput | boolean
    connect?: TransitStageWhereUniqueInput
    update?: XOR<XOR<TransitStageUpdateToOneWithWhereWithoutPreviousEventsInput, TransitStageUpdateWithoutPreviousEventsInput>, TransitStageUncheckedUpdateWithoutPreviousEventsInput>
  }

  export type TransitStageUpdateOneWithoutContainerEventsNestedInput = {
    create?: XOR<TransitStageCreateWithoutContainerEventsInput, TransitStageUncheckedCreateWithoutContainerEventsInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutContainerEventsInput
    upsert?: TransitStageUpsertWithoutContainerEventsInput
    disconnect?: TransitStageWhereInput | boolean
    delete?: TransitStageWhereInput | boolean
    connect?: TransitStageWhereUniqueInput
    update?: XOR<XOR<TransitStageUpdateToOneWithWhereWithoutContainerEventsInput, TransitStageUpdateWithoutContainerEventsInput>, TransitStageUncheckedUpdateWithoutContainerEventsInput>
  }

  export type ContainerUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ContainerCreateWithoutEventsInput, ContainerUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutEventsInput
    upsert?: ContainerUpsertWithoutEventsInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutEventsInput, ContainerUpdateWithoutEventsInput>, ContainerUncheckedUpdateWithoutEventsInput>
  }

  export type ImportLogCreateNestedOneWithoutShipmentEventsInput = {
    create?: XOR<ImportLogCreateWithoutShipmentEventsInput, ImportLogUncheckedCreateWithoutShipmentEventsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutShipmentEventsInput
    connect?: ImportLogWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutShipmentEventsInput = {
    create?: XOR<ShipmentCreateWithoutShipmentEventsInput, ShipmentUncheckedCreateWithoutShipmentEventsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutShipmentEventsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type ImportLogUpdateOneWithoutShipmentEventsNestedInput = {
    create?: XOR<ImportLogCreateWithoutShipmentEventsInput, ImportLogUncheckedCreateWithoutShipmentEventsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutShipmentEventsInput
    upsert?: ImportLogUpsertWithoutShipmentEventsInput
    disconnect?: ImportLogWhereInput | boolean
    delete?: ImportLogWhereInput | boolean
    connect?: ImportLogWhereUniqueInput
    update?: XOR<XOR<ImportLogUpdateToOneWithWhereWithoutShipmentEventsInput, ImportLogUpdateWithoutShipmentEventsInput>, ImportLogUncheckedUpdateWithoutShipmentEventsInput>
  }

  export type ShipmentUpdateOneRequiredWithoutShipmentEventsNestedInput = {
    create?: XOR<ShipmentCreateWithoutShipmentEventsInput, ShipmentUncheckedCreateWithoutShipmentEventsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutShipmentEventsInput
    upsert?: ShipmentUpsertWithoutShipmentEventsInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutShipmentEventsInput, ShipmentUpdateWithoutShipmentEventsInput>, ShipmentUncheckedUpdateWithoutShipmentEventsInput>
  }

  export type ImportLogCreateNestedOneWithoutAceStatusLogsInput = {
    create?: XOR<ImportLogCreateWithoutAceStatusLogsInput, ImportLogUncheckedCreateWithoutAceStatusLogsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutAceStatusLogsInput
    connect?: ImportLogWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutAceStatusLogsInput = {
    create?: XOR<ShipmentCreateWithoutAceStatusLogsInput, ShipmentUncheckedCreateWithoutAceStatusLogsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutAceStatusLogsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type ContainerCreateNestedOneWithoutAceStatusLogsInput = {
    create?: XOR<ContainerCreateWithoutAceStatusLogsInput, ContainerUncheckedCreateWithoutAceStatusLogsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutAceStatusLogsInput
    connect?: ContainerWhereUniqueInput
  }

  export type ImportLogUpdateOneWithoutAceStatusLogsNestedInput = {
    create?: XOR<ImportLogCreateWithoutAceStatusLogsInput, ImportLogUncheckedCreateWithoutAceStatusLogsInput>
    connectOrCreate?: ImportLogCreateOrConnectWithoutAceStatusLogsInput
    upsert?: ImportLogUpsertWithoutAceStatusLogsInput
    disconnect?: ImportLogWhereInput | boolean
    delete?: ImportLogWhereInput | boolean
    connect?: ImportLogWhereUniqueInput
    update?: XOR<XOR<ImportLogUpdateToOneWithWhereWithoutAceStatusLogsInput, ImportLogUpdateWithoutAceStatusLogsInput>, ImportLogUncheckedUpdateWithoutAceStatusLogsInput>
  }

  export type ShipmentUpdateOneWithoutAceStatusLogsNestedInput = {
    create?: XOR<ShipmentCreateWithoutAceStatusLogsInput, ShipmentUncheckedCreateWithoutAceStatusLogsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutAceStatusLogsInput
    upsert?: ShipmentUpsertWithoutAceStatusLogsInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutAceStatusLogsInput, ShipmentUpdateWithoutAceStatusLogsInput>, ShipmentUncheckedUpdateWithoutAceStatusLogsInput>
  }

  export type ContainerUpdateOneWithoutAceStatusLogsNestedInput = {
    create?: XOR<ContainerCreateWithoutAceStatusLogsInput, ContainerUncheckedCreateWithoutAceStatusLogsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutAceStatusLogsInput
    upsert?: ContainerUpsertWithoutAceStatusLogsInput
    disconnect?: ContainerWhereInput | boolean
    delete?: ContainerWhereInput | boolean
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutAceStatusLogsInput, ContainerUpdateWithoutAceStatusLogsInput>, ContainerUncheckedUpdateWithoutAceStatusLogsInput>
  }

  export type ContainerEventCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ContainerEventCreateWithoutFacilityInput, ContainerEventUncheckedCreateWithoutFacilityInput> | ContainerEventCreateWithoutFacilityInput[] | ContainerEventUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutFacilityInput | ContainerEventCreateOrConnectWithoutFacilityInput[]
    createMany?: ContainerEventCreateManyFacilityInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type PortCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<PortCreateWithoutFacilitiesInput, PortUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: PortCreateOrConnectWithoutFacilitiesInput
    connect?: PortWhereUniqueInput
  }

  export type ContainerEventUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ContainerEventCreateWithoutFacilityInput, ContainerEventUncheckedCreateWithoutFacilityInput> | ContainerEventCreateWithoutFacilityInput[] | ContainerEventUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutFacilityInput | ContainerEventCreateOrConnectWithoutFacilityInput[]
    createMany?: ContainerEventCreateManyFacilityInputEnvelope
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
  }

  export type ContainerEventUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ContainerEventCreateWithoutFacilityInput, ContainerEventUncheckedCreateWithoutFacilityInput> | ContainerEventCreateWithoutFacilityInput[] | ContainerEventUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutFacilityInput | ContainerEventCreateOrConnectWithoutFacilityInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutFacilityInput | ContainerEventUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ContainerEventCreateManyFacilityInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutFacilityInput | ContainerEventUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutFacilityInput | ContainerEventUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type PortUpdateOneWithoutFacilitiesNestedInput = {
    create?: XOR<PortCreateWithoutFacilitiesInput, PortUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: PortCreateOrConnectWithoutFacilitiesInput
    upsert?: PortUpsertWithoutFacilitiesInput
    disconnect?: PortWhereInput | boolean
    delete?: PortWhereInput | boolean
    connect?: PortWhereUniqueInput
    update?: XOR<XOR<PortUpdateToOneWithWhereWithoutFacilitiesInput, PortUpdateWithoutFacilitiesInput>, PortUncheckedUpdateWithoutFacilitiesInput>
  }

  export type ContainerEventUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ContainerEventCreateWithoutFacilityInput, ContainerEventUncheckedCreateWithoutFacilityInput> | ContainerEventCreateWithoutFacilityInput[] | ContainerEventUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContainerEventCreateOrConnectWithoutFacilityInput | ContainerEventCreateOrConnectWithoutFacilityInput[]
    upsert?: ContainerEventUpsertWithWhereUniqueWithoutFacilityInput | ContainerEventUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ContainerEventCreateManyFacilityInputEnvelope
    set?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    disconnect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    delete?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    connect?: ContainerEventWhereUniqueInput | ContainerEventWhereUniqueInput[]
    update?: ContainerEventUpdateWithWhereUniqueWithoutFacilityInput | ContainerEventUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ContainerEventUpdateManyWithWhereWithoutFacilityInput | ContainerEventUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
  }

  export type CarrierFormatCreateNestedManyWithoutCarrierInput = {
    create?: XOR<CarrierFormatCreateWithoutCarrierInput, CarrierFormatUncheckedCreateWithoutCarrierInput> | CarrierFormatCreateWithoutCarrierInput[] | CarrierFormatUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: CarrierFormatCreateOrConnectWithoutCarrierInput | CarrierFormatCreateOrConnectWithoutCarrierInput[]
    createMany?: CarrierFormatCreateManyCarrierInputEnvelope
    connect?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
  }

  export type DCSAEventMapCreateNestedManyWithoutCarrierInput = {
    create?: XOR<DCSAEventMapCreateWithoutCarrierInput, DCSAEventMapUncheckedCreateWithoutCarrierInput> | DCSAEventMapCreateWithoutCarrierInput[] | DCSAEventMapUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutCarrierInput | DCSAEventMapCreateOrConnectWithoutCarrierInput[]
    createMany?: DCSAEventMapCreateManyCarrierInputEnvelope
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
  }

  export type DemurrageRateCreateNestedManyWithoutCarrierInput = {
    create?: XOR<DemurrageRateCreateWithoutCarrierInput, DemurrageRateUncheckedCreateWithoutCarrierInput> | DemurrageRateCreateWithoutCarrierInput[] | DemurrageRateUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutCarrierInput | DemurrageRateCreateOrConnectWithoutCarrierInput[]
    createMany?: DemurrageRateCreateManyCarrierInputEnvelope
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
  }

  export type CarrierFormatUncheckedCreateNestedManyWithoutCarrierInput = {
    create?: XOR<CarrierFormatCreateWithoutCarrierInput, CarrierFormatUncheckedCreateWithoutCarrierInput> | CarrierFormatCreateWithoutCarrierInput[] | CarrierFormatUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: CarrierFormatCreateOrConnectWithoutCarrierInput | CarrierFormatCreateOrConnectWithoutCarrierInput[]
    createMany?: CarrierFormatCreateManyCarrierInputEnvelope
    connect?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
  }

  export type DCSAEventMapUncheckedCreateNestedManyWithoutCarrierInput = {
    create?: XOR<DCSAEventMapCreateWithoutCarrierInput, DCSAEventMapUncheckedCreateWithoutCarrierInput> | DCSAEventMapCreateWithoutCarrierInput[] | DCSAEventMapUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutCarrierInput | DCSAEventMapCreateOrConnectWithoutCarrierInput[]
    createMany?: DCSAEventMapCreateManyCarrierInputEnvelope
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
  }

  export type DemurrageRateUncheckedCreateNestedManyWithoutCarrierInput = {
    create?: XOR<DemurrageRateCreateWithoutCarrierInput, DemurrageRateUncheckedCreateWithoutCarrierInput> | DemurrageRateCreateWithoutCarrierInput[] | DemurrageRateUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutCarrierInput | DemurrageRateCreateOrConnectWithoutCarrierInput[]
    createMany?: DemurrageRateCreateManyCarrierInputEnvelope
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
  }

  export type CarrierFormatUpdateManyWithoutCarrierNestedInput = {
    create?: XOR<CarrierFormatCreateWithoutCarrierInput, CarrierFormatUncheckedCreateWithoutCarrierInput> | CarrierFormatCreateWithoutCarrierInput[] | CarrierFormatUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: CarrierFormatCreateOrConnectWithoutCarrierInput | CarrierFormatCreateOrConnectWithoutCarrierInput[]
    upsert?: CarrierFormatUpsertWithWhereUniqueWithoutCarrierInput | CarrierFormatUpsertWithWhereUniqueWithoutCarrierInput[]
    createMany?: CarrierFormatCreateManyCarrierInputEnvelope
    set?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    disconnect?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    delete?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    connect?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    update?: CarrierFormatUpdateWithWhereUniqueWithoutCarrierInput | CarrierFormatUpdateWithWhereUniqueWithoutCarrierInput[]
    updateMany?: CarrierFormatUpdateManyWithWhereWithoutCarrierInput | CarrierFormatUpdateManyWithWhereWithoutCarrierInput[]
    deleteMany?: CarrierFormatScalarWhereInput | CarrierFormatScalarWhereInput[]
  }

  export type DCSAEventMapUpdateManyWithoutCarrierNestedInput = {
    create?: XOR<DCSAEventMapCreateWithoutCarrierInput, DCSAEventMapUncheckedCreateWithoutCarrierInput> | DCSAEventMapCreateWithoutCarrierInput[] | DCSAEventMapUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutCarrierInput | DCSAEventMapCreateOrConnectWithoutCarrierInput[]
    upsert?: DCSAEventMapUpsertWithWhereUniqueWithoutCarrierInput | DCSAEventMapUpsertWithWhereUniqueWithoutCarrierInput[]
    createMany?: DCSAEventMapCreateManyCarrierInputEnvelope
    set?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    disconnect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    delete?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    update?: DCSAEventMapUpdateWithWhereUniqueWithoutCarrierInput | DCSAEventMapUpdateWithWhereUniqueWithoutCarrierInput[]
    updateMany?: DCSAEventMapUpdateManyWithWhereWithoutCarrierInput | DCSAEventMapUpdateManyWithWhereWithoutCarrierInput[]
    deleteMany?: DCSAEventMapScalarWhereInput | DCSAEventMapScalarWhereInput[]
  }

  export type DemurrageRateUpdateManyWithoutCarrierNestedInput = {
    create?: XOR<DemurrageRateCreateWithoutCarrierInput, DemurrageRateUncheckedCreateWithoutCarrierInput> | DemurrageRateCreateWithoutCarrierInput[] | DemurrageRateUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutCarrierInput | DemurrageRateCreateOrConnectWithoutCarrierInput[]
    upsert?: DemurrageRateUpsertWithWhereUniqueWithoutCarrierInput | DemurrageRateUpsertWithWhereUniqueWithoutCarrierInput[]
    createMany?: DemurrageRateCreateManyCarrierInputEnvelope
    set?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    disconnect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    delete?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    update?: DemurrageRateUpdateWithWhereUniqueWithoutCarrierInput | DemurrageRateUpdateWithWhereUniqueWithoutCarrierInput[]
    updateMany?: DemurrageRateUpdateManyWithWhereWithoutCarrierInput | DemurrageRateUpdateManyWithWhereWithoutCarrierInput[]
    deleteMany?: DemurrageRateScalarWhereInput | DemurrageRateScalarWhereInput[]
  }

  export type CarrierFormatUncheckedUpdateManyWithoutCarrierNestedInput = {
    create?: XOR<CarrierFormatCreateWithoutCarrierInput, CarrierFormatUncheckedCreateWithoutCarrierInput> | CarrierFormatCreateWithoutCarrierInput[] | CarrierFormatUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: CarrierFormatCreateOrConnectWithoutCarrierInput | CarrierFormatCreateOrConnectWithoutCarrierInput[]
    upsert?: CarrierFormatUpsertWithWhereUniqueWithoutCarrierInput | CarrierFormatUpsertWithWhereUniqueWithoutCarrierInput[]
    createMany?: CarrierFormatCreateManyCarrierInputEnvelope
    set?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    disconnect?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    delete?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    connect?: CarrierFormatWhereUniqueInput | CarrierFormatWhereUniqueInput[]
    update?: CarrierFormatUpdateWithWhereUniqueWithoutCarrierInput | CarrierFormatUpdateWithWhereUniqueWithoutCarrierInput[]
    updateMany?: CarrierFormatUpdateManyWithWhereWithoutCarrierInput | CarrierFormatUpdateManyWithWhereWithoutCarrierInput[]
    deleteMany?: CarrierFormatScalarWhereInput | CarrierFormatScalarWhereInput[]
  }

  export type DCSAEventMapUncheckedUpdateManyWithoutCarrierNestedInput = {
    create?: XOR<DCSAEventMapCreateWithoutCarrierInput, DCSAEventMapUncheckedCreateWithoutCarrierInput> | DCSAEventMapCreateWithoutCarrierInput[] | DCSAEventMapUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DCSAEventMapCreateOrConnectWithoutCarrierInput | DCSAEventMapCreateOrConnectWithoutCarrierInput[]
    upsert?: DCSAEventMapUpsertWithWhereUniqueWithoutCarrierInput | DCSAEventMapUpsertWithWhereUniqueWithoutCarrierInput[]
    createMany?: DCSAEventMapCreateManyCarrierInputEnvelope
    set?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    disconnect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    delete?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    connect?: DCSAEventMapWhereUniqueInput | DCSAEventMapWhereUniqueInput[]
    update?: DCSAEventMapUpdateWithWhereUniqueWithoutCarrierInput | DCSAEventMapUpdateWithWhereUniqueWithoutCarrierInput[]
    updateMany?: DCSAEventMapUpdateManyWithWhereWithoutCarrierInput | DCSAEventMapUpdateManyWithWhereWithoutCarrierInput[]
    deleteMany?: DCSAEventMapScalarWhereInput | DCSAEventMapScalarWhereInput[]
  }

  export type DemurrageRateUncheckedUpdateManyWithoutCarrierNestedInput = {
    create?: XOR<DemurrageRateCreateWithoutCarrierInput, DemurrageRateUncheckedCreateWithoutCarrierInput> | DemurrageRateCreateWithoutCarrierInput[] | DemurrageRateUncheckedCreateWithoutCarrierInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutCarrierInput | DemurrageRateCreateOrConnectWithoutCarrierInput[]
    upsert?: DemurrageRateUpsertWithWhereUniqueWithoutCarrierInput | DemurrageRateUpsertWithWhereUniqueWithoutCarrierInput[]
    createMany?: DemurrageRateCreateManyCarrierInputEnvelope
    set?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    disconnect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    delete?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    update?: DemurrageRateUpdateWithWhereUniqueWithoutCarrierInput | DemurrageRateUpdateWithWhereUniqueWithoutCarrierInput[]
    updateMany?: DemurrageRateUpdateManyWithWhereWithoutCarrierInput | DemurrageRateUpdateManyWithWhereWithoutCarrierInput[]
    deleteMany?: DemurrageRateScalarWhereInput | DemurrageRateScalarWhereInput[]
  }

  export type DemurrageRateCreateNestedManyWithoutPortInput = {
    create?: XOR<DemurrageRateCreateWithoutPortInput, DemurrageRateUncheckedCreateWithoutPortInput> | DemurrageRateCreateWithoutPortInput[] | DemurrageRateUncheckedCreateWithoutPortInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutPortInput | DemurrageRateCreateOrConnectWithoutPortInput[]
    createMany?: DemurrageRateCreateManyPortInputEnvelope
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
  }

  export type FacilityCreateNestedManyWithoutPortInput = {
    create?: XOR<FacilityCreateWithoutPortInput, FacilityUncheckedCreateWithoutPortInput> | FacilityCreateWithoutPortInput[] | FacilityUncheckedCreateWithoutPortInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutPortInput | FacilityCreateOrConnectWithoutPortInput[]
    createMany?: FacilityCreateManyPortInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type DemurrageRateUncheckedCreateNestedManyWithoutPortInput = {
    create?: XOR<DemurrageRateCreateWithoutPortInput, DemurrageRateUncheckedCreateWithoutPortInput> | DemurrageRateCreateWithoutPortInput[] | DemurrageRateUncheckedCreateWithoutPortInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutPortInput | DemurrageRateCreateOrConnectWithoutPortInput[]
    createMany?: DemurrageRateCreateManyPortInputEnvelope
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutPortInput = {
    create?: XOR<FacilityCreateWithoutPortInput, FacilityUncheckedCreateWithoutPortInput> | FacilityCreateWithoutPortInput[] | FacilityUncheckedCreateWithoutPortInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutPortInput | FacilityCreateOrConnectWithoutPortInput[]
    createMany?: FacilityCreateManyPortInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type DemurrageRateUpdateManyWithoutPortNestedInput = {
    create?: XOR<DemurrageRateCreateWithoutPortInput, DemurrageRateUncheckedCreateWithoutPortInput> | DemurrageRateCreateWithoutPortInput[] | DemurrageRateUncheckedCreateWithoutPortInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutPortInput | DemurrageRateCreateOrConnectWithoutPortInput[]
    upsert?: DemurrageRateUpsertWithWhereUniqueWithoutPortInput | DemurrageRateUpsertWithWhereUniqueWithoutPortInput[]
    createMany?: DemurrageRateCreateManyPortInputEnvelope
    set?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    disconnect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    delete?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    update?: DemurrageRateUpdateWithWhereUniqueWithoutPortInput | DemurrageRateUpdateWithWhereUniqueWithoutPortInput[]
    updateMany?: DemurrageRateUpdateManyWithWhereWithoutPortInput | DemurrageRateUpdateManyWithWhereWithoutPortInput[]
    deleteMany?: DemurrageRateScalarWhereInput | DemurrageRateScalarWhereInput[]
  }

  export type FacilityUpdateManyWithoutPortNestedInput = {
    create?: XOR<FacilityCreateWithoutPortInput, FacilityUncheckedCreateWithoutPortInput> | FacilityCreateWithoutPortInput[] | FacilityUncheckedCreateWithoutPortInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutPortInput | FacilityCreateOrConnectWithoutPortInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutPortInput | FacilityUpsertWithWhereUniqueWithoutPortInput[]
    createMany?: FacilityCreateManyPortInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutPortInput | FacilityUpdateWithWhereUniqueWithoutPortInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutPortInput | FacilityUpdateManyWithWhereWithoutPortInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type DemurrageRateUncheckedUpdateManyWithoutPortNestedInput = {
    create?: XOR<DemurrageRateCreateWithoutPortInput, DemurrageRateUncheckedCreateWithoutPortInput> | DemurrageRateCreateWithoutPortInput[] | DemurrageRateUncheckedCreateWithoutPortInput[]
    connectOrCreate?: DemurrageRateCreateOrConnectWithoutPortInput | DemurrageRateCreateOrConnectWithoutPortInput[]
    upsert?: DemurrageRateUpsertWithWhereUniqueWithoutPortInput | DemurrageRateUpsertWithWhereUniqueWithoutPortInput[]
    createMany?: DemurrageRateCreateManyPortInputEnvelope
    set?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    disconnect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    delete?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    connect?: DemurrageRateWhereUniqueInput | DemurrageRateWhereUniqueInput[]
    update?: DemurrageRateUpdateWithWhereUniqueWithoutPortInput | DemurrageRateUpdateWithWhereUniqueWithoutPortInput[]
    updateMany?: DemurrageRateUpdateManyWithWhereWithoutPortInput | DemurrageRateUpdateManyWithWhereWithoutPortInput[]
    deleteMany?: DemurrageRateScalarWhereInput | DemurrageRateScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutPortNestedInput = {
    create?: XOR<FacilityCreateWithoutPortInput, FacilityUncheckedCreateWithoutPortInput> | FacilityCreateWithoutPortInput[] | FacilityUncheckedCreateWithoutPortInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutPortInput | FacilityCreateOrConnectWithoutPortInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutPortInput | FacilityUpsertWithWhereUniqueWithoutPortInput[]
    createMany?: FacilityCreateManyPortInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutPortInput | FacilityUpdateWithWhereUniqueWithoutPortInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutPortInput | FacilityUpdateManyWithWhereWithoutPortInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type PortCreateNestedOneWithoutDemurrageRatesInput = {
    create?: XOR<PortCreateWithoutDemurrageRatesInput, PortUncheckedCreateWithoutDemurrageRatesInput>
    connectOrCreate?: PortCreateOrConnectWithoutDemurrageRatesInput
    connect?: PortWhereUniqueInput
  }

  export type CarrierCreateNestedOneWithoutDemurrageRatesInput = {
    create?: XOR<CarrierCreateWithoutDemurrageRatesInput, CarrierUncheckedCreateWithoutDemurrageRatesInput>
    connectOrCreate?: CarrierCreateOrConnectWithoutDemurrageRatesInput
    connect?: CarrierWhereUniqueInput
  }

  export type PortUpdateOneWithoutDemurrageRatesNestedInput = {
    create?: XOR<PortCreateWithoutDemurrageRatesInput, PortUncheckedCreateWithoutDemurrageRatesInput>
    connectOrCreate?: PortCreateOrConnectWithoutDemurrageRatesInput
    upsert?: PortUpsertWithoutDemurrageRatesInput
    disconnect?: PortWhereInput | boolean
    delete?: PortWhereInput | boolean
    connect?: PortWhereUniqueInput
    update?: XOR<XOR<PortUpdateToOneWithWhereWithoutDemurrageRatesInput, PortUpdateWithoutDemurrageRatesInput>, PortUncheckedUpdateWithoutDemurrageRatesInput>
  }

  export type CarrierUpdateOneWithoutDemurrageRatesNestedInput = {
    create?: XOR<CarrierCreateWithoutDemurrageRatesInput, CarrierUncheckedCreateWithoutDemurrageRatesInput>
    connectOrCreate?: CarrierCreateOrConnectWithoutDemurrageRatesInput
    upsert?: CarrierUpsertWithoutDemurrageRatesInput
    disconnect?: CarrierWhereInput | boolean
    delete?: CarrierWhereInput | boolean
    connect?: CarrierWhereUniqueInput
    update?: XOR<XOR<CarrierUpdateToOneWithWhereWithoutDemurrageRatesInput, CarrierUpdateWithoutDemurrageRatesInput>, CarrierUncheckedUpdateWithoutDemurrageRatesInput>
  }

  export type CarrierCreateNestedOneWithoutCarrierFormatsInput = {
    create?: XOR<CarrierCreateWithoutCarrierFormatsInput, CarrierUncheckedCreateWithoutCarrierFormatsInput>
    connectOrCreate?: CarrierCreateOrConnectWithoutCarrierFormatsInput
    connect?: CarrierWhereUniqueInput
  }

  export type ImportLogCreateNestedManyWithoutCarrierFormatInput = {
    create?: XOR<ImportLogCreateWithoutCarrierFormatInput, ImportLogUncheckedCreateWithoutCarrierFormatInput> | ImportLogCreateWithoutCarrierFormatInput[] | ImportLogUncheckedCreateWithoutCarrierFormatInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutCarrierFormatInput | ImportLogCreateOrConnectWithoutCarrierFormatInput[]
    createMany?: ImportLogCreateManyCarrierFormatInputEnvelope
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
  }

  export type ImportLogUncheckedCreateNestedManyWithoutCarrierFormatInput = {
    create?: XOR<ImportLogCreateWithoutCarrierFormatInput, ImportLogUncheckedCreateWithoutCarrierFormatInput> | ImportLogCreateWithoutCarrierFormatInput[] | ImportLogUncheckedCreateWithoutCarrierFormatInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutCarrierFormatInput | ImportLogCreateOrConnectWithoutCarrierFormatInput[]
    createMany?: ImportLogCreateManyCarrierFormatInputEnvelope
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
  }

  export type CarrierUpdateOneWithoutCarrierFormatsNestedInput = {
    create?: XOR<CarrierCreateWithoutCarrierFormatsInput, CarrierUncheckedCreateWithoutCarrierFormatsInput>
    connectOrCreate?: CarrierCreateOrConnectWithoutCarrierFormatsInput
    upsert?: CarrierUpsertWithoutCarrierFormatsInput
    disconnect?: CarrierWhereInput | boolean
    delete?: CarrierWhereInput | boolean
    connect?: CarrierWhereUniqueInput
    update?: XOR<XOR<CarrierUpdateToOneWithWhereWithoutCarrierFormatsInput, CarrierUpdateWithoutCarrierFormatsInput>, CarrierUncheckedUpdateWithoutCarrierFormatsInput>
  }

  export type ImportLogUpdateManyWithoutCarrierFormatNestedInput = {
    create?: XOR<ImportLogCreateWithoutCarrierFormatInput, ImportLogUncheckedCreateWithoutCarrierFormatInput> | ImportLogCreateWithoutCarrierFormatInput[] | ImportLogUncheckedCreateWithoutCarrierFormatInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutCarrierFormatInput | ImportLogCreateOrConnectWithoutCarrierFormatInput[]
    upsert?: ImportLogUpsertWithWhereUniqueWithoutCarrierFormatInput | ImportLogUpsertWithWhereUniqueWithoutCarrierFormatInput[]
    createMany?: ImportLogCreateManyCarrierFormatInputEnvelope
    set?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    disconnect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    delete?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    update?: ImportLogUpdateWithWhereUniqueWithoutCarrierFormatInput | ImportLogUpdateWithWhereUniqueWithoutCarrierFormatInput[]
    updateMany?: ImportLogUpdateManyWithWhereWithoutCarrierFormatInput | ImportLogUpdateManyWithWhereWithoutCarrierFormatInput[]
    deleteMany?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
  }

  export type ImportLogUncheckedUpdateManyWithoutCarrierFormatNestedInput = {
    create?: XOR<ImportLogCreateWithoutCarrierFormatInput, ImportLogUncheckedCreateWithoutCarrierFormatInput> | ImportLogCreateWithoutCarrierFormatInput[] | ImportLogUncheckedCreateWithoutCarrierFormatInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutCarrierFormatInput | ImportLogCreateOrConnectWithoutCarrierFormatInput[]
    upsert?: ImportLogUpsertWithWhereUniqueWithoutCarrierFormatInput | ImportLogUpsertWithWhereUniqueWithoutCarrierFormatInput[]
    createMany?: ImportLogCreateManyCarrierFormatInputEnvelope
    set?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    disconnect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    delete?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    update?: ImportLogUpdateWithWhereUniqueWithoutCarrierFormatInput | ImportLogUpdateWithWhereUniqueWithoutCarrierFormatInput[]
    updateMany?: ImportLogUpdateManyWithWhereWithoutCarrierFormatInput | ImportLogUpdateManyWithWhereWithoutCarrierFormatInput[]
    deleteMany?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
  }

  export type TransitStageCreateNestedOneWithoutDcsaEventMapsInput = {
    create?: XOR<TransitStageCreateWithoutDcsaEventMapsInput, TransitStageUncheckedCreateWithoutDcsaEventMapsInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutDcsaEventMapsInput
    connect?: TransitStageWhereUniqueInput
  }

  export type CarrierCreateNestedOneWithoutDcsaEventMapsInput = {
    create?: XOR<CarrierCreateWithoutDcsaEventMapsInput, CarrierUncheckedCreateWithoutDcsaEventMapsInput>
    connectOrCreate?: CarrierCreateOrConnectWithoutDcsaEventMapsInput
    connect?: CarrierWhereUniqueInput
  }

  export type TransitStageUpdateOneWithoutDcsaEventMapsNestedInput = {
    create?: XOR<TransitStageCreateWithoutDcsaEventMapsInput, TransitStageUncheckedCreateWithoutDcsaEventMapsInput>
    connectOrCreate?: TransitStageCreateOrConnectWithoutDcsaEventMapsInput
    upsert?: TransitStageUpsertWithoutDcsaEventMapsInput
    disconnect?: TransitStageWhereInput | boolean
    delete?: TransitStageWhereInput | boolean
    connect?: TransitStageWhereUniqueInput
    update?: XOR<XOR<TransitStageUpdateToOneWithWhereWithoutDcsaEventMapsInput, TransitStageUpdateWithoutDcsaEventMapsInput>, TransitStageUncheckedUpdateWithoutDcsaEventMapsInput>
  }

  export type CarrierUpdateOneWithoutDcsaEventMapsNestedInput = {
    create?: XOR<CarrierCreateWithoutDcsaEventMapsInput, CarrierUncheckedCreateWithoutDcsaEventMapsInput>
    connectOrCreate?: CarrierCreateOrConnectWithoutDcsaEventMapsInput
    upsert?: CarrierUpsertWithoutDcsaEventMapsInput
    disconnect?: CarrierWhereInput | boolean
    delete?: CarrierWhereInput | boolean
    connect?: CarrierWhereUniqueInput
    update?: XOR<XOR<CarrierUpdateToOneWithWhereWithoutDcsaEventMapsInput, CarrierUpdateWithoutDcsaEventMapsInput>, CarrierUncheckedUpdateWithoutDcsaEventMapsInput>
  }

  export type ContainerCreateNestedOneWithoutAttentionFlagsInput = {
    create?: XOR<ContainerCreateWithoutAttentionFlagsInput, ContainerUncheckedCreateWithoutAttentionFlagsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutAttentionFlagsInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerUpdateOneRequiredWithoutAttentionFlagsNestedInput = {
    create?: XOR<ContainerCreateWithoutAttentionFlagsInput, ContainerUncheckedCreateWithoutAttentionFlagsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutAttentionFlagsInput
    upsert?: ContainerUpsertWithoutAttentionFlagsInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutAttentionFlagsInput, ContainerUpdateWithoutAttentionFlagsInput>, ContainerUncheckedUpdateWithoutAttentionFlagsInput>
  }

  export type ContainerCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<ContainerCreateWithoutActivityLogsInput, ContainerUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutActivityLogsInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<ContainerCreateWithoutActivityLogsInput, ContainerUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutActivityLogsInput
    upsert?: ContainerUpsertWithoutActivityLogsInput
    disconnect?: ContainerWhereInput | boolean
    delete?: ContainerWhereInput | boolean
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutActivityLogsInput, ContainerUpdateWithoutActivityLogsInput>, ContainerUncheckedUpdateWithoutActivityLogsInput>
  }

  export type ContainerCreateNestedOneWithoutStatusOverridesInput = {
    create?: XOR<ContainerCreateWithoutStatusOverridesInput, ContainerUncheckedCreateWithoutStatusOverridesInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutStatusOverridesInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerUpdateOneRequiredWithoutStatusOverridesNestedInput = {
    create?: XOR<ContainerCreateWithoutStatusOverridesInput, ContainerUncheckedCreateWithoutStatusOverridesInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutStatusOverridesInput
    upsert?: ContainerUpsertWithoutStatusOverridesInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutStatusOverridesInput, ContainerUpdateWithoutStatusOverridesInput>, ContainerUncheckedUpdateWithoutStatusOverridesInput>
  }

  export type ContainerCreateNestedOneWithoutRiskAssessmentInput = {
    create?: XOR<ContainerCreateWithoutRiskAssessmentInput, ContainerUncheckedCreateWithoutRiskAssessmentInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutRiskAssessmentInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerUpdateOneRequiredWithoutRiskAssessmentNestedInput = {
    create?: XOR<ContainerCreateWithoutRiskAssessmentInput, ContainerUncheckedCreateWithoutRiskAssessmentInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutRiskAssessmentInput
    upsert?: ContainerUpsertWithoutRiskAssessmentInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutRiskAssessmentInput, ContainerUpdateWithoutRiskAssessmentInput>, ContainerUncheckedUpdateWithoutRiskAssessmentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ACEStatusLogCreateWithoutImportLogInput = {
    id?: string
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
    shipment?: ShipmentCreateNestedOneWithoutAceStatusLogsInput
    container?: ContainerCreateNestedOneWithoutAceStatusLogsInput
  }

  export type ACEStatusLogUncheckedCreateWithoutImportLogInput = {
    id?: string
    containerId?: string | null
    shipmentId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ACEStatusLogCreateOrConnectWithoutImportLogInput = {
    where: ACEStatusLogWhereUniqueInput
    create: XOR<ACEStatusLogCreateWithoutImportLogInput, ACEStatusLogUncheckedCreateWithoutImportLogInput>
  }

  export type ACEStatusLogCreateManyImportLogInputEnvelope = {
    data: ACEStatusLogCreateManyImportLogInput | ACEStatusLogCreateManyImportLogInput[]
    skipDuplicates?: boolean
  }

  export type ContainerEventCreateWithoutImportLogInput = {
    id?: string
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
    facility?: FacilityCreateNestedOneWithoutContainerEventsInput
    previousStage?: TransitStageCreateNestedOneWithoutPreviousEventsInput
    stage?: TransitStageCreateNestedOneWithoutContainerEventsInput
    container: ContainerCreateNestedOneWithoutEventsInput
  }

  export type ContainerEventUncheckedCreateWithoutImportLogInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventCreateOrConnectWithoutImportLogInput = {
    where: ContainerEventWhereUniqueInput
    create: XOR<ContainerEventCreateWithoutImportLogInput, ContainerEventUncheckedCreateWithoutImportLogInput>
  }

  export type ContainerEventCreateManyImportLogInputEnvelope = {
    data: ContainerEventCreateManyImportLogInput | ContainerEventCreateManyImportLogInput[]
    skipDuplicates?: boolean
  }

  export type CarrierFormatCreateWithoutImportLogsInput = {
    formatName: string
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
    carrier?: CarrierCreateNestedOneWithoutCarrierFormatsInput
  }

  export type CarrierFormatUncheckedCreateWithoutImportLogsInput = {
    formatName: string
    carrierId?: string | null
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
  }

  export type CarrierFormatCreateOrConnectWithoutImportLogsInput = {
    where: CarrierFormatWhereUniqueInput
    create: XOR<CarrierFormatCreateWithoutImportLogsInput, CarrierFormatUncheckedCreateWithoutImportLogsInput>
  }

  export type RawRowCreateWithoutImportLogInput = {
    id?: string
    rowNumber: number
    data: string
  }

  export type RawRowUncheckedCreateWithoutImportLogInput = {
    id?: string
    rowNumber: number
    data: string
  }

  export type RawRowCreateOrConnectWithoutImportLogInput = {
    where: RawRowWhereUniqueInput
    create: XOR<RawRowCreateWithoutImportLogInput, RawRowUncheckedCreateWithoutImportLogInput>
  }

  export type RawRowCreateManyImportLogInputEnvelope = {
    data: RawRowCreateManyImportLogInput | RawRowCreateManyImportLogInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentEventCreateWithoutImportLogInput = {
    id?: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
    shipment: ShipmentCreateNestedOneWithoutShipmentEventsInput
  }

  export type ShipmentEventUncheckedCreateWithoutImportLogInput = {
    id?: string
    shipmentId: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
  }

  export type ShipmentEventCreateOrConnectWithoutImportLogInput = {
    where: ShipmentEventWhereUniqueInput
    create: XOR<ShipmentEventCreateWithoutImportLogInput, ShipmentEventUncheckedCreateWithoutImportLogInput>
  }

  export type ShipmentEventCreateManyImportLogInputEnvelope = {
    data: ShipmentEventCreateManyImportLogInput | ShipmentEventCreateManyImportLogInput[]
    skipDuplicates?: boolean
  }

  export type ACEStatusLogUpsertWithWhereUniqueWithoutImportLogInput = {
    where: ACEStatusLogWhereUniqueInput
    update: XOR<ACEStatusLogUpdateWithoutImportLogInput, ACEStatusLogUncheckedUpdateWithoutImportLogInput>
    create: XOR<ACEStatusLogCreateWithoutImportLogInput, ACEStatusLogUncheckedCreateWithoutImportLogInput>
  }

  export type ACEStatusLogUpdateWithWhereUniqueWithoutImportLogInput = {
    where: ACEStatusLogWhereUniqueInput
    data: XOR<ACEStatusLogUpdateWithoutImportLogInput, ACEStatusLogUncheckedUpdateWithoutImportLogInput>
  }

  export type ACEStatusLogUpdateManyWithWhereWithoutImportLogInput = {
    where: ACEStatusLogScalarWhereInput
    data: XOR<ACEStatusLogUpdateManyMutationInput, ACEStatusLogUncheckedUpdateManyWithoutImportLogInput>
  }

  export type ACEStatusLogScalarWhereInput = {
    AND?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
    OR?: ACEStatusLogScalarWhereInput[]
    NOT?: ACEStatusLogScalarWhereInput | ACEStatusLogScalarWhereInput[]
    id?: StringFilter<"ACEStatusLog"> | string
    containerId?: StringNullableFilter<"ACEStatusLog"> | string | null
    shipmentId?: StringNullableFilter<"ACEStatusLog"> | string | null
    aceDisposition?: StringNullableFilter<"ACEStatusLog"> | string | null
    aceStatus?: StringNullableFilter<"ACEStatusLog"> | string | null
    previousACEStatus?: StringNullableFilter<"ACEStatusLog"> | string | null
    holdType?: StringNullableFilter<"ACEStatusLog"> | string | null
    pgaAgency?: StringNullableFilter<"ACEStatusLog"> | string | null
    holdReason?: StringNullableFilter<"ACEStatusLog"> | string | null
    eventDateTime?: DateTimeNullableFilter<"ACEStatusLog"> | Date | string | null
    source?: StringNullableFilter<"ACEStatusLog"> | string | null
    sourceFileId?: StringNullableFilter<"ACEStatusLog"> | string | null
    updatedOn?: DateTimeNullableFilter<"ACEStatusLog"> | Date | string | null
    notes?: StringNullableFilter<"ACEStatusLog"> | string | null
  }

  export type ContainerEventUpsertWithWhereUniqueWithoutImportLogInput = {
    where: ContainerEventWhereUniqueInput
    update: XOR<ContainerEventUpdateWithoutImportLogInput, ContainerEventUncheckedUpdateWithoutImportLogInput>
    create: XOR<ContainerEventCreateWithoutImportLogInput, ContainerEventUncheckedCreateWithoutImportLogInput>
  }

  export type ContainerEventUpdateWithWhereUniqueWithoutImportLogInput = {
    where: ContainerEventWhereUniqueInput
    data: XOR<ContainerEventUpdateWithoutImportLogInput, ContainerEventUncheckedUpdateWithoutImportLogInput>
  }

  export type ContainerEventUpdateManyWithWhereWithoutImportLogInput = {
    where: ContainerEventScalarWhereInput
    data: XOR<ContainerEventUpdateManyMutationInput, ContainerEventUncheckedUpdateManyWithoutImportLogInput>
  }

  export type ContainerEventScalarWhereInput = {
    AND?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
    OR?: ContainerEventScalarWhereInput[]
    NOT?: ContainerEventScalarWhereInput | ContainerEventScalarWhereInput[]
    id?: StringFilter<"ContainerEvent"> | string
    containerId?: StringFilter<"ContainerEvent"> | string
    stageName?: StringNullableFilter<"ContainerEvent"> | string | null
    eventDateTime?: DateTimeFilter<"ContainerEvent"> | Date | string
    location?: StringNullableFilter<"ContainerEvent"> | string | null
    facilityId?: StringNullableFilter<"ContainerEvent"> | string | null
    vessel?: StringNullableFilter<"ContainerEvent"> | string | null
    voyage?: StringNullableFilter<"ContainerEvent"> | string | null
    source?: StringNullableFilter<"ContainerEvent"> | string | null
    sourceFileId?: StringNullableFilter<"ContainerEvent"> | string | null
    updatedBy?: StringNullableFilter<"ContainerEvent"> | string | null
    updatedOn?: DateTimeNullableFilter<"ContainerEvent"> | Date | string | null
    previousStatus?: StringNullableFilter<"ContainerEvent"> | string | null
    exceptionCleared?: BoolNullableFilter<"ContainerEvent"> | boolean | null
    notes?: StringNullableFilter<"ContainerEvent"> | string | null
    eventCategory?: StringNullableFilter<"ContainerEvent"> | string | null
    eventClassifier?: StringNullableFilter<"ContainerEvent"> | string | null
    dcsaEventType?: StringNullableFilter<"ContainerEvent"> | string | null
    transportMode?: StringNullableFilter<"ContainerEvent"> | string | null
    facilityType?: StringNullableFilter<"ContainerEvent"> | string | null
    emptyIndicator?: BoolNullableFilter<"ContainerEvent"> | boolean | null
    carrierEventId?: StringNullableFilter<"ContainerEvent"> | string | null
  }

  export type CarrierFormatUpsertWithoutImportLogsInput = {
    update: XOR<CarrierFormatUpdateWithoutImportLogsInput, CarrierFormatUncheckedUpdateWithoutImportLogsInput>
    create: XOR<CarrierFormatCreateWithoutImportLogsInput, CarrierFormatUncheckedCreateWithoutImportLogsInput>
    where?: CarrierFormatWhereInput
  }

  export type CarrierFormatUpdateToOneWithWhereWithoutImportLogsInput = {
    where?: CarrierFormatWhereInput
    data: XOR<CarrierFormatUpdateWithoutImportLogsInput, CarrierFormatUncheckedUpdateWithoutImportLogsInput>
  }

  export type CarrierFormatUpdateWithoutImportLogsInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: CarrierUpdateOneWithoutCarrierFormatsNestedInput
  }

  export type CarrierFormatUncheckedUpdateWithoutImportLogsInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RawRowUpsertWithWhereUniqueWithoutImportLogInput = {
    where: RawRowWhereUniqueInput
    update: XOR<RawRowUpdateWithoutImportLogInput, RawRowUncheckedUpdateWithoutImportLogInput>
    create: XOR<RawRowCreateWithoutImportLogInput, RawRowUncheckedCreateWithoutImportLogInput>
  }

  export type RawRowUpdateWithWhereUniqueWithoutImportLogInput = {
    where: RawRowWhereUniqueInput
    data: XOR<RawRowUpdateWithoutImportLogInput, RawRowUncheckedUpdateWithoutImportLogInput>
  }

  export type RawRowUpdateManyWithWhereWithoutImportLogInput = {
    where: RawRowScalarWhereInput
    data: XOR<RawRowUpdateManyMutationInput, RawRowUncheckedUpdateManyWithoutImportLogInput>
  }

  export type RawRowScalarWhereInput = {
    AND?: RawRowScalarWhereInput | RawRowScalarWhereInput[]
    OR?: RawRowScalarWhereInput[]
    NOT?: RawRowScalarWhereInput | RawRowScalarWhereInput[]
    id?: StringFilter<"RawRow"> | string
    importLogId?: StringFilter<"RawRow"> | string
    rowNumber?: IntFilter<"RawRow"> | number
    data?: StringFilter<"RawRow"> | string
  }

  export type ShipmentEventUpsertWithWhereUniqueWithoutImportLogInput = {
    where: ShipmentEventWhereUniqueInput
    update: XOR<ShipmentEventUpdateWithoutImportLogInput, ShipmentEventUncheckedUpdateWithoutImportLogInput>
    create: XOR<ShipmentEventCreateWithoutImportLogInput, ShipmentEventUncheckedCreateWithoutImportLogInput>
  }

  export type ShipmentEventUpdateWithWhereUniqueWithoutImportLogInput = {
    where: ShipmentEventWhereUniqueInput
    data: XOR<ShipmentEventUpdateWithoutImportLogInput, ShipmentEventUncheckedUpdateWithoutImportLogInput>
  }

  export type ShipmentEventUpdateManyWithWhereWithoutImportLogInput = {
    where: ShipmentEventScalarWhereInput
    data: XOR<ShipmentEventUpdateManyMutationInput, ShipmentEventUncheckedUpdateManyWithoutImportLogInput>
  }

  export type ShipmentEventScalarWhereInput = {
    AND?: ShipmentEventScalarWhereInput | ShipmentEventScalarWhereInput[]
    OR?: ShipmentEventScalarWhereInput[]
    NOT?: ShipmentEventScalarWhereInput | ShipmentEventScalarWhereInput[]
    id?: StringFilter<"ShipmentEvent"> | string
    shipmentId?: StringFilter<"ShipmentEvent"> | string
    eventType?: StringFilter<"ShipmentEvent"> | string
    eventDateTime?: DateTimeFilter<"ShipmentEvent"> | Date | string
    documentType?: StringNullableFilter<"ShipmentEvent"> | string | null
    source?: StringNullableFilter<"ShipmentEvent"> | string | null
    sourceFileId?: StringNullableFilter<"ShipmentEvent"> | string | null
    updatedBy?: StringNullableFilter<"ShipmentEvent"> | string | null
    updatedOn?: DateTimeNullableFilter<"ShipmentEvent"> | Date | string | null
    previousBLStatus?: StringNullableFilter<"ShipmentEvent"> | string | null
    newBLStatus?: StringNullableFilter<"ShipmentEvent"> | string | null
    notes?: StringNullableFilter<"ShipmentEvent"> | string | null
    dcsaEventType?: StringNullableFilter<"ShipmentEvent"> | string | null
    carrierEventId?: StringNullableFilter<"ShipmentEvent"> | string | null
  }

  export type ImportLogCreateWithoutRawRowsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventCreateNestedManyWithoutImportLogInput
    carrierFormat?: CarrierFormatCreateNestedOneWithoutImportLogsInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUncheckedCreateWithoutRawRowsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    carrierFormatId?: string | null
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogCreateOrConnectWithoutRawRowsInput = {
    where: ImportLogWhereUniqueInput
    create: XOR<ImportLogCreateWithoutRawRowsInput, ImportLogUncheckedCreateWithoutRawRowsInput>
  }

  export type ImportLogUpsertWithoutRawRowsInput = {
    update: XOR<ImportLogUpdateWithoutRawRowsInput, ImportLogUncheckedUpdateWithoutRawRowsInput>
    create: XOR<ImportLogCreateWithoutRawRowsInput, ImportLogUncheckedCreateWithoutRawRowsInput>
    where?: ImportLogWhereInput
  }

  export type ImportLogUpdateToOneWithWhereWithoutRawRowsInput = {
    where?: ImportLogWhereInput
    data: XOR<ImportLogUpdateWithoutRawRowsInput, ImportLogUncheckedUpdateWithoutRawRowsInput>
  }

  export type ImportLogUpdateWithoutRawRowsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutImportLogNestedInput
    carrierFormat?: CarrierFormatUpdateOneWithoutImportLogsNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateWithoutRawRowsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    carrierFormatId?: NullableStringFieldUpdateOperationsInput | string | null
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutImportLogNestedInput
  }

  export type ContainerCreateWithoutStageInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutStageInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutStageInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutStageInput, ContainerUncheckedCreateWithoutStageInput>
  }

  export type ContainerCreateManyStageInputEnvelope = {
    data: ContainerCreateManyStageInput | ContainerCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type ContainerEventCreateWithoutPreviousStageInput = {
    id?: string
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
    facility?: FacilityCreateNestedOneWithoutContainerEventsInput
    importLog?: ImportLogCreateNestedOneWithoutContainerEventsInput
    stage?: TransitStageCreateNestedOneWithoutContainerEventsInput
    container: ContainerCreateNestedOneWithoutEventsInput
  }

  export type ContainerEventUncheckedCreateWithoutPreviousStageInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventCreateOrConnectWithoutPreviousStageInput = {
    where: ContainerEventWhereUniqueInput
    create: XOR<ContainerEventCreateWithoutPreviousStageInput, ContainerEventUncheckedCreateWithoutPreviousStageInput>
  }

  export type ContainerEventCreateManyPreviousStageInputEnvelope = {
    data: ContainerEventCreateManyPreviousStageInput | ContainerEventCreateManyPreviousStageInput[]
    skipDuplicates?: boolean
  }

  export type ContainerEventCreateWithoutStageInput = {
    id?: string
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
    facility?: FacilityCreateNestedOneWithoutContainerEventsInput
    importLog?: ImportLogCreateNestedOneWithoutContainerEventsInput
    previousStage?: TransitStageCreateNestedOneWithoutPreviousEventsInput
    container: ContainerCreateNestedOneWithoutEventsInput
  }

  export type ContainerEventUncheckedCreateWithoutStageInput = {
    id?: string
    containerId: string
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventCreateOrConnectWithoutStageInput = {
    where: ContainerEventWhereUniqueInput
    create: XOR<ContainerEventCreateWithoutStageInput, ContainerEventUncheckedCreateWithoutStageInput>
  }

  export type ContainerEventCreateManyStageInputEnvelope = {
    data: ContainerEventCreateManyStageInput | ContainerEventCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type DCSAEventMapCreateWithoutTransitStageInput = {
    name: string
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
    carrier?: CarrierCreateNestedOneWithoutDcsaEventMapsInput
  }

  export type DCSAEventMapUncheckedCreateWithoutTransitStageInput = {
    name: string
    carrierId?: string | null
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
  }

  export type DCSAEventMapCreateOrConnectWithoutTransitStageInput = {
    where: DCSAEventMapWhereUniqueInput
    create: XOR<DCSAEventMapCreateWithoutTransitStageInput, DCSAEventMapUncheckedCreateWithoutTransitStageInput>
  }

  export type DCSAEventMapCreateManyTransitStageInputEnvelope = {
    data: DCSAEventMapCreateManyTransitStageInput | DCSAEventMapCreateManyTransitStageInput[]
    skipDuplicates?: boolean
  }

  export type ContainerUpsertWithWhereUniqueWithoutStageInput = {
    where: ContainerWhereUniqueInput
    update: XOR<ContainerUpdateWithoutStageInput, ContainerUncheckedUpdateWithoutStageInput>
    create: XOR<ContainerCreateWithoutStageInput, ContainerUncheckedCreateWithoutStageInput>
  }

  export type ContainerUpdateWithWhereUniqueWithoutStageInput = {
    where: ContainerWhereUniqueInput
    data: XOR<ContainerUpdateWithoutStageInput, ContainerUncheckedUpdateWithoutStageInput>
  }

  export type ContainerUpdateManyWithWhereWithoutStageInput = {
    where: ContainerScalarWhereInput
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyWithoutStageInput>
  }

  export type ContainerScalarWhereInput = {
    AND?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
    OR?: ContainerScalarWhereInput[]
    NOT?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
    containerNumber?: StringFilter<"Container"> | string
    containerType?: StringNullableFilter<"Container"> | string | null
    currentStatus?: StringNullableFilter<"Container"> | string | null
    currentLocation?: StringNullableFilter<"Container"> | string | null
    currentVessel?: StringNullableFilter<"Container"> | string | null
    currentVoyage?: StringNullableFilter<"Container"> | string | null
    mbl?: StringNullableFilter<"Container"> | string | null
    carrier?: StringNullableFilter<"Container"> | string | null
    pol?: StringNullableFilter<"Container"> | string | null
    pod?: StringNullableFilter<"Container"> | string | null
    etd?: DateTimeNullableFilter<"Container"> | Date | string | null
    atd?: DateTimeNullableFilter<"Container"> | Date | string | null
    eta?: DateTimeNullableFilter<"Container"> | Date | string | null
    ata?: DateTimeNullableFilter<"Container"> | Date | string | null
    lastFreeDay?: DateTimeNullableFilter<"Container"> | Date | string | null
    detentionFreeDay?: DateTimeNullableFilter<"Container"> | Date | string | null
    statusLastUpdated?: DateTimeNullableFilter<"Container"> | Date | string | null
    hasException?: BoolFilter<"Container"> | boolean
    exceptionType?: StringNullableFilter<"Container"> | string | null
    exceptionOwner?: StringNullableFilter<"Container"> | string | null
    exceptionNotes?: StringNullableFilter<"Container"> | string | null
    exceptionDate?: DateTimeNullableFilter<"Container"> | Date | string | null
    manualPriority?: StringNullableFilter<"Container"> | string | null
    priorityReason?: StringNullableFilter<"Container"> | string | null
    prioritySetBy?: StringNullableFilter<"Container"> | string | null
    prioritySetDate?: DateTimeNullableFilter<"Container"> | Date | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    emptyIndicator?: BoolNullableFilter<"Container"> | boolean | null
    sealNumber?: StringNullableFilter<"Container"> | string | null
    grossWeight?: FloatNullableFilter<"Container"> | number | null
    carrierEventId?: StringNullableFilter<"Container"> | string | null
    aceEntryNumber?: StringNullableFilter<"Container"> | string | null
    aceDisposition?: StringNullableFilter<"Container"> | string | null
    aceStatus?: StringNullableFilter<"Container"> | string | null
    aceLastUpdated?: DateTimeNullableFilter<"Container"> | Date | string | null
    pgaHold?: BoolNullableFilter<"Container"> | boolean | null
    pgaAgency?: StringNullableFilter<"Container"> | string | null
    pgaHoldReason?: StringNullableFilter<"Container"> | string | null
    createdAt?: DateTimeFilter<"Container"> | Date | string
    updatedAt?: DateTimeFilter<"Container"> | Date | string
  }

  export type ContainerEventUpsertWithWhereUniqueWithoutPreviousStageInput = {
    where: ContainerEventWhereUniqueInput
    update: XOR<ContainerEventUpdateWithoutPreviousStageInput, ContainerEventUncheckedUpdateWithoutPreviousStageInput>
    create: XOR<ContainerEventCreateWithoutPreviousStageInput, ContainerEventUncheckedCreateWithoutPreviousStageInput>
  }

  export type ContainerEventUpdateWithWhereUniqueWithoutPreviousStageInput = {
    where: ContainerEventWhereUniqueInput
    data: XOR<ContainerEventUpdateWithoutPreviousStageInput, ContainerEventUncheckedUpdateWithoutPreviousStageInput>
  }

  export type ContainerEventUpdateManyWithWhereWithoutPreviousStageInput = {
    where: ContainerEventScalarWhereInput
    data: XOR<ContainerEventUpdateManyMutationInput, ContainerEventUncheckedUpdateManyWithoutPreviousStageInput>
  }

  export type ContainerEventUpsertWithWhereUniqueWithoutStageInput = {
    where: ContainerEventWhereUniqueInput
    update: XOR<ContainerEventUpdateWithoutStageInput, ContainerEventUncheckedUpdateWithoutStageInput>
    create: XOR<ContainerEventCreateWithoutStageInput, ContainerEventUncheckedCreateWithoutStageInput>
  }

  export type ContainerEventUpdateWithWhereUniqueWithoutStageInput = {
    where: ContainerEventWhereUniqueInput
    data: XOR<ContainerEventUpdateWithoutStageInput, ContainerEventUncheckedUpdateWithoutStageInput>
  }

  export type ContainerEventUpdateManyWithWhereWithoutStageInput = {
    where: ContainerEventScalarWhereInput
    data: XOR<ContainerEventUpdateManyMutationInput, ContainerEventUncheckedUpdateManyWithoutStageInput>
  }

  export type DCSAEventMapUpsertWithWhereUniqueWithoutTransitStageInput = {
    where: DCSAEventMapWhereUniqueInput
    update: XOR<DCSAEventMapUpdateWithoutTransitStageInput, DCSAEventMapUncheckedUpdateWithoutTransitStageInput>
    create: XOR<DCSAEventMapCreateWithoutTransitStageInput, DCSAEventMapUncheckedCreateWithoutTransitStageInput>
  }

  export type DCSAEventMapUpdateWithWhereUniqueWithoutTransitStageInput = {
    where: DCSAEventMapWhereUniqueInput
    data: XOR<DCSAEventMapUpdateWithoutTransitStageInput, DCSAEventMapUncheckedUpdateWithoutTransitStageInput>
  }

  export type DCSAEventMapUpdateManyWithWhereWithoutTransitStageInput = {
    where: DCSAEventMapScalarWhereInput
    data: XOR<DCSAEventMapUpdateManyMutationInput, DCSAEventMapUncheckedUpdateManyWithoutTransitStageInput>
  }

  export type DCSAEventMapScalarWhereInput = {
    AND?: DCSAEventMapScalarWhereInput | DCSAEventMapScalarWhereInput[]
    OR?: DCSAEventMapScalarWhereInput[]
    NOT?: DCSAEventMapScalarWhereInput | DCSAEventMapScalarWhereInput[]
    name?: StringFilter<"DCSAEventMap"> | string
    carrierId?: StringNullableFilter<"DCSAEventMap"> | string | null
    sourceEventCode?: StringNullableFilter<"DCSAEventMap"> | string | null
    sourceEventName?: StringNullableFilter<"DCSAEventMap"> | string | null
    dcsaEventType?: StringNullableFilter<"DCSAEventMap"> | string | null
    transitStageName?: StringNullableFilter<"DCSAEventMap"> | string | null
    eventCategory?: StringNullableFilter<"DCSAEventMap"> | string | null
    notes?: StringNullableFilter<"DCSAEventMap"> | string | null
    isActive?: BoolFilter<"DCSAEventMap"> | boolean
  }

  export type ACEStatusLogCreateWithoutShipmentInput = {
    id?: string
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
    importLog?: ImportLogCreateNestedOneWithoutAceStatusLogsInput
    container?: ContainerCreateNestedOneWithoutAceStatusLogsInput
  }

  export type ACEStatusLogUncheckedCreateWithoutShipmentInput = {
    id?: string
    containerId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    sourceFileId?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ACEStatusLogCreateOrConnectWithoutShipmentInput = {
    where: ACEStatusLogWhereUniqueInput
    create: XOR<ACEStatusLogCreateWithoutShipmentInput, ACEStatusLogUncheckedCreateWithoutShipmentInput>
  }

  export type ACEStatusLogCreateManyShipmentInputEnvelope = {
    data: ACEStatusLogCreateManyShipmentInput | ACEStatusLogCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentContainerCreateWithoutShipmentInput = {
    id?: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
    container: ContainerCreateNestedOneWithoutShipmentContainersInput
  }

  export type ShipmentContainerUncheckedCreateWithoutShipmentInput = {
    id?: string
    containerId: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
  }

  export type ShipmentContainerCreateOrConnectWithoutShipmentInput = {
    where: ShipmentContainerWhereUniqueInput
    create: XOR<ShipmentContainerCreateWithoutShipmentInput, ShipmentContainerUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentContainerCreateManyShipmentInputEnvelope = {
    data: ShipmentContainerCreateManyShipmentInput | ShipmentContainerCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentEventCreateWithoutShipmentInput = {
    id?: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
    importLog?: ImportLogCreateNestedOneWithoutShipmentEventsInput
  }

  export type ShipmentEventUncheckedCreateWithoutShipmentInput = {
    id?: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
  }

  export type ShipmentEventCreateOrConnectWithoutShipmentInput = {
    where: ShipmentEventWhereUniqueInput
    create: XOR<ShipmentEventCreateWithoutShipmentInput, ShipmentEventUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentEventCreateManyShipmentInputEnvelope = {
    data: ShipmentEventCreateManyShipmentInput | ShipmentEventCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type ACEStatusLogUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ACEStatusLogWhereUniqueInput
    update: XOR<ACEStatusLogUpdateWithoutShipmentInput, ACEStatusLogUncheckedUpdateWithoutShipmentInput>
    create: XOR<ACEStatusLogCreateWithoutShipmentInput, ACEStatusLogUncheckedCreateWithoutShipmentInput>
  }

  export type ACEStatusLogUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ACEStatusLogWhereUniqueInput
    data: XOR<ACEStatusLogUpdateWithoutShipmentInput, ACEStatusLogUncheckedUpdateWithoutShipmentInput>
  }

  export type ACEStatusLogUpdateManyWithWhereWithoutShipmentInput = {
    where: ACEStatusLogScalarWhereInput
    data: XOR<ACEStatusLogUpdateManyMutationInput, ACEStatusLogUncheckedUpdateManyWithoutShipmentInput>
  }

  export type ShipmentContainerUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentContainerWhereUniqueInput
    update: XOR<ShipmentContainerUpdateWithoutShipmentInput, ShipmentContainerUncheckedUpdateWithoutShipmentInput>
    create: XOR<ShipmentContainerCreateWithoutShipmentInput, ShipmentContainerUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentContainerUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentContainerWhereUniqueInput
    data: XOR<ShipmentContainerUpdateWithoutShipmentInput, ShipmentContainerUncheckedUpdateWithoutShipmentInput>
  }

  export type ShipmentContainerUpdateManyWithWhereWithoutShipmentInput = {
    where: ShipmentContainerScalarWhereInput
    data: XOR<ShipmentContainerUpdateManyMutationInput, ShipmentContainerUncheckedUpdateManyWithoutShipmentInput>
  }

  export type ShipmentContainerScalarWhereInput = {
    AND?: ShipmentContainerScalarWhereInput | ShipmentContainerScalarWhereInput[]
    OR?: ShipmentContainerScalarWhereInput[]
    NOT?: ShipmentContainerScalarWhereInput | ShipmentContainerScalarWhereInput[]
    id?: StringFilter<"ShipmentContainer"> | string
    shipmentId?: StringFilter<"ShipmentContainer"> | string
    containerId?: StringFilter<"ShipmentContainer"> | string
    piecesInContainer?: IntNullableFilter<"ShipmentContainer"> | number | null
    weightInContainer?: FloatNullableFilter<"ShipmentContainer"> | number | null
    notes?: StringNullableFilter<"ShipmentContainer"> | string | null
  }

  export type ShipmentEventUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentEventWhereUniqueInput
    update: XOR<ShipmentEventUpdateWithoutShipmentInput, ShipmentEventUncheckedUpdateWithoutShipmentInput>
    create: XOR<ShipmentEventCreateWithoutShipmentInput, ShipmentEventUncheckedCreateWithoutShipmentInput>
  }

  export type ShipmentEventUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ShipmentEventWhereUniqueInput
    data: XOR<ShipmentEventUpdateWithoutShipmentInput, ShipmentEventUncheckedUpdateWithoutShipmentInput>
  }

  export type ShipmentEventUpdateManyWithWhereWithoutShipmentInput = {
    where: ShipmentEventScalarWhereInput
    data: XOR<ShipmentEventUpdateManyMutationInput, ShipmentEventUncheckedUpdateManyWithoutShipmentInput>
  }

  export type ACEStatusLogCreateWithoutContainerInput = {
    id?: string
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
    importLog?: ImportLogCreateNestedOneWithoutAceStatusLogsInput
    shipment?: ShipmentCreateNestedOneWithoutAceStatusLogsInput
  }

  export type ACEStatusLogUncheckedCreateWithoutContainerInput = {
    id?: string
    shipmentId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    sourceFileId?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ACEStatusLogCreateOrConnectWithoutContainerInput = {
    where: ACEStatusLogWhereUniqueInput
    create: XOR<ACEStatusLogCreateWithoutContainerInput, ACEStatusLogUncheckedCreateWithoutContainerInput>
  }

  export type ACEStatusLogCreateManyContainerInputEnvelope = {
    data: ACEStatusLogCreateManyContainerInput | ACEStatusLogCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type TransitStageCreateWithoutContainersInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    previousEvents?: ContainerEventCreateNestedManyWithoutPreviousStageInput
    containerEvents?: ContainerEventCreateNestedManyWithoutStageInput
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageUncheckedCreateWithoutContainersInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    previousEvents?: ContainerEventUncheckedCreateNestedManyWithoutPreviousStageInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutStageInput
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageCreateOrConnectWithoutContainersInput = {
    where: TransitStageWhereUniqueInput
    create: XOR<TransitStageCreateWithoutContainersInput, TransitStageUncheckedCreateWithoutContainersInput>
  }

  export type ContainerEventCreateWithoutContainerInput = {
    id?: string
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
    facility?: FacilityCreateNestedOneWithoutContainerEventsInput
    importLog?: ImportLogCreateNestedOneWithoutContainerEventsInput
    previousStage?: TransitStageCreateNestedOneWithoutPreviousEventsInput
    stage?: TransitStageCreateNestedOneWithoutContainerEventsInput
  }

  export type ContainerEventUncheckedCreateWithoutContainerInput = {
    id?: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventCreateOrConnectWithoutContainerInput = {
    where: ContainerEventWhereUniqueInput
    create: XOR<ContainerEventCreateWithoutContainerInput, ContainerEventUncheckedCreateWithoutContainerInput>
  }

  export type ContainerEventCreateManyContainerInputEnvelope = {
    data: ContainerEventCreateManyContainerInput | ContainerEventCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentContainerCreateWithoutContainerInput = {
    id?: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
    shipment: ShipmentCreateNestedOneWithoutShipmentContainersInput
  }

  export type ShipmentContainerUncheckedCreateWithoutContainerInput = {
    id?: string
    shipmentId: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
  }

  export type ShipmentContainerCreateOrConnectWithoutContainerInput = {
    where: ShipmentContainerWhereUniqueInput
    create: XOR<ShipmentContainerCreateWithoutContainerInput, ShipmentContainerUncheckedCreateWithoutContainerInput>
  }

  export type ShipmentContainerCreateManyContainerInputEnvelope = {
    data: ShipmentContainerCreateManyContainerInput | ShipmentContainerCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type AttentionFlagCreateWithoutContainerInput = {
    id?: string
    reason: string
    priority: string
    flaggedBy?: string | null
    flaggedOn?: Date | string
    owner?: string | null
    notes?: string | null
    resolved?: boolean
    resolvedBy?: string | null
    resolvedDate?: Date | string | null
    resolutionNote?: string | null
  }

  export type AttentionFlagUncheckedCreateWithoutContainerInput = {
    id?: string
    reason: string
    priority: string
    flaggedBy?: string | null
    flaggedOn?: Date | string
    owner?: string | null
    notes?: string | null
    resolved?: boolean
    resolvedBy?: string | null
    resolvedDate?: Date | string | null
    resolutionNote?: string | null
  }

  export type AttentionFlagCreateOrConnectWithoutContainerInput = {
    where: AttentionFlagWhereUniqueInput
    create: XOR<AttentionFlagCreateWithoutContainerInput, AttentionFlagUncheckedCreateWithoutContainerInput>
  }

  export type AttentionFlagCreateManyContainerInputEnvelope = {
    data: AttentionFlagCreateManyContainerInput | AttentionFlagCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutContainerInput = {
    id?: string
    shipmentId?: string | null
    action: string
    actor?: string | null
    detail?: string | null
    source?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutContainerInput = {
    id?: string
    shipmentId?: string | null
    action: string
    actor?: string | null
    detail?: string | null
    source?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutContainerInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutContainerInput, ActivityLogUncheckedCreateWithoutContainerInput>
  }

  export type ActivityLogCreateManyContainerInputEnvelope = {
    data: ActivityLogCreateManyContainerInput | ActivityLogCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type StatusOverrideCreateWithoutContainerInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    reason: string
    overriddenBy?: string | null
    overriddenAt?: Date | string
  }

  export type StatusOverrideUncheckedCreateWithoutContainerInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    reason: string
    overriddenBy?: string | null
    overriddenAt?: Date | string
  }

  export type StatusOverrideCreateOrConnectWithoutContainerInput = {
    where: StatusOverrideWhereUniqueInput
    create: XOR<StatusOverrideCreateWithoutContainerInput, StatusOverrideUncheckedCreateWithoutContainerInput>
  }

  export type StatusOverrideCreateManyContainerInputEnvelope = {
    data: StatusOverrideCreateManyContainerInput | StatusOverrideCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type RiskAssessmentCreateWithoutContainerInput = {
    id?: string
    riskScore: number
    riskFactors: string
    recommendations: string
    lastUpdated?: Date | string
  }

  export type RiskAssessmentUncheckedCreateWithoutContainerInput = {
    id?: string
    riskScore: number
    riskFactors: string
    recommendations: string
    lastUpdated?: Date | string
  }

  export type RiskAssessmentCreateOrConnectWithoutContainerInput = {
    where: RiskAssessmentWhereUniqueInput
    create: XOR<RiskAssessmentCreateWithoutContainerInput, RiskAssessmentUncheckedCreateWithoutContainerInput>
  }

  export type ACEStatusLogUpsertWithWhereUniqueWithoutContainerInput = {
    where: ACEStatusLogWhereUniqueInput
    update: XOR<ACEStatusLogUpdateWithoutContainerInput, ACEStatusLogUncheckedUpdateWithoutContainerInput>
    create: XOR<ACEStatusLogCreateWithoutContainerInput, ACEStatusLogUncheckedCreateWithoutContainerInput>
  }

  export type ACEStatusLogUpdateWithWhereUniqueWithoutContainerInput = {
    where: ACEStatusLogWhereUniqueInput
    data: XOR<ACEStatusLogUpdateWithoutContainerInput, ACEStatusLogUncheckedUpdateWithoutContainerInput>
  }

  export type ACEStatusLogUpdateManyWithWhereWithoutContainerInput = {
    where: ACEStatusLogScalarWhereInput
    data: XOR<ACEStatusLogUpdateManyMutationInput, ACEStatusLogUncheckedUpdateManyWithoutContainerInput>
  }

  export type TransitStageUpsertWithoutContainersInput = {
    update: XOR<TransitStageUpdateWithoutContainersInput, TransitStageUncheckedUpdateWithoutContainersInput>
    create: XOR<TransitStageCreateWithoutContainersInput, TransitStageUncheckedCreateWithoutContainersInput>
    where?: TransitStageWhereInput
  }

  export type TransitStageUpdateToOneWithWhereWithoutContainersInput = {
    where?: TransitStageWhereInput
    data: XOR<TransitStageUpdateWithoutContainersInput, TransitStageUncheckedUpdateWithoutContainersInput>
  }

  export type TransitStageUpdateWithoutContainersInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    previousEvents?: ContainerEventUpdateManyWithoutPreviousStageNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutStageNestedInput
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutTransitStageNestedInput
  }

  export type TransitStageUncheckedUpdateWithoutContainersInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    previousEvents?: ContainerEventUncheckedUpdateManyWithoutPreviousStageNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutStageNestedInput
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutTransitStageNestedInput
  }

  export type ContainerEventUpsertWithWhereUniqueWithoutContainerInput = {
    where: ContainerEventWhereUniqueInput
    update: XOR<ContainerEventUpdateWithoutContainerInput, ContainerEventUncheckedUpdateWithoutContainerInput>
    create: XOR<ContainerEventCreateWithoutContainerInput, ContainerEventUncheckedCreateWithoutContainerInput>
  }

  export type ContainerEventUpdateWithWhereUniqueWithoutContainerInput = {
    where: ContainerEventWhereUniqueInput
    data: XOR<ContainerEventUpdateWithoutContainerInput, ContainerEventUncheckedUpdateWithoutContainerInput>
  }

  export type ContainerEventUpdateManyWithWhereWithoutContainerInput = {
    where: ContainerEventScalarWhereInput
    data: XOR<ContainerEventUpdateManyMutationInput, ContainerEventUncheckedUpdateManyWithoutContainerInput>
  }

  export type ShipmentContainerUpsertWithWhereUniqueWithoutContainerInput = {
    where: ShipmentContainerWhereUniqueInput
    update: XOR<ShipmentContainerUpdateWithoutContainerInput, ShipmentContainerUncheckedUpdateWithoutContainerInput>
    create: XOR<ShipmentContainerCreateWithoutContainerInput, ShipmentContainerUncheckedCreateWithoutContainerInput>
  }

  export type ShipmentContainerUpdateWithWhereUniqueWithoutContainerInput = {
    where: ShipmentContainerWhereUniqueInput
    data: XOR<ShipmentContainerUpdateWithoutContainerInput, ShipmentContainerUncheckedUpdateWithoutContainerInput>
  }

  export type ShipmentContainerUpdateManyWithWhereWithoutContainerInput = {
    where: ShipmentContainerScalarWhereInput
    data: XOR<ShipmentContainerUpdateManyMutationInput, ShipmentContainerUncheckedUpdateManyWithoutContainerInput>
  }

  export type AttentionFlagUpsertWithWhereUniqueWithoutContainerInput = {
    where: AttentionFlagWhereUniqueInput
    update: XOR<AttentionFlagUpdateWithoutContainerInput, AttentionFlagUncheckedUpdateWithoutContainerInput>
    create: XOR<AttentionFlagCreateWithoutContainerInput, AttentionFlagUncheckedCreateWithoutContainerInput>
  }

  export type AttentionFlagUpdateWithWhereUniqueWithoutContainerInput = {
    where: AttentionFlagWhereUniqueInput
    data: XOR<AttentionFlagUpdateWithoutContainerInput, AttentionFlagUncheckedUpdateWithoutContainerInput>
  }

  export type AttentionFlagUpdateManyWithWhereWithoutContainerInput = {
    where: AttentionFlagScalarWhereInput
    data: XOR<AttentionFlagUpdateManyMutationInput, AttentionFlagUncheckedUpdateManyWithoutContainerInput>
  }

  export type AttentionFlagScalarWhereInput = {
    AND?: AttentionFlagScalarWhereInput | AttentionFlagScalarWhereInput[]
    OR?: AttentionFlagScalarWhereInput[]
    NOT?: AttentionFlagScalarWhereInput | AttentionFlagScalarWhereInput[]
    id?: StringFilter<"AttentionFlag"> | string
    containerId?: StringFilter<"AttentionFlag"> | string
    reason?: StringFilter<"AttentionFlag"> | string
    priority?: StringFilter<"AttentionFlag"> | string
    flaggedBy?: StringNullableFilter<"AttentionFlag"> | string | null
    flaggedOn?: DateTimeFilter<"AttentionFlag"> | Date | string
    owner?: StringNullableFilter<"AttentionFlag"> | string | null
    notes?: StringNullableFilter<"AttentionFlag"> | string | null
    resolved?: BoolFilter<"AttentionFlag"> | boolean
    resolvedBy?: StringNullableFilter<"AttentionFlag"> | string | null
    resolvedDate?: DateTimeNullableFilter<"AttentionFlag"> | Date | string | null
    resolutionNote?: StringNullableFilter<"AttentionFlag"> | string | null
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutContainerInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutContainerInput, ActivityLogUncheckedUpdateWithoutContainerInput>
    create: XOR<ActivityLogCreateWithoutContainerInput, ActivityLogUncheckedCreateWithoutContainerInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutContainerInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutContainerInput, ActivityLogUncheckedUpdateWithoutContainerInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutContainerInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutContainerInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    containerId?: StringNullableFilter<"ActivityLog"> | string | null
    shipmentId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    actor?: StringNullableFilter<"ActivityLog"> | string | null
    detail?: StringNullableFilter<"ActivityLog"> | string | null
    source?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type StatusOverrideUpsertWithWhereUniqueWithoutContainerInput = {
    where: StatusOverrideWhereUniqueInput
    update: XOR<StatusOverrideUpdateWithoutContainerInput, StatusOverrideUncheckedUpdateWithoutContainerInput>
    create: XOR<StatusOverrideCreateWithoutContainerInput, StatusOverrideUncheckedCreateWithoutContainerInput>
  }

  export type StatusOverrideUpdateWithWhereUniqueWithoutContainerInput = {
    where: StatusOverrideWhereUniqueInput
    data: XOR<StatusOverrideUpdateWithoutContainerInput, StatusOverrideUncheckedUpdateWithoutContainerInput>
  }

  export type StatusOverrideUpdateManyWithWhereWithoutContainerInput = {
    where: StatusOverrideScalarWhereInput
    data: XOR<StatusOverrideUpdateManyMutationInput, StatusOverrideUncheckedUpdateManyWithoutContainerInput>
  }

  export type StatusOverrideScalarWhereInput = {
    AND?: StatusOverrideScalarWhereInput | StatusOverrideScalarWhereInput[]
    OR?: StatusOverrideScalarWhereInput[]
    NOT?: StatusOverrideScalarWhereInput | StatusOverrideScalarWhereInput[]
    id?: StringFilter<"StatusOverride"> | string
    containerNumber?: StringFilter<"StatusOverride"> | string
    previousStatus?: StringNullableFilter<"StatusOverride"> | string | null
    newStatus?: StringFilter<"StatusOverride"> | string
    reason?: StringFilter<"StatusOverride"> | string
    overriddenBy?: StringNullableFilter<"StatusOverride"> | string | null
    overriddenAt?: DateTimeFilter<"StatusOverride"> | Date | string
  }

  export type RiskAssessmentUpsertWithoutContainerInput = {
    update: XOR<RiskAssessmentUpdateWithoutContainerInput, RiskAssessmentUncheckedUpdateWithoutContainerInput>
    create: XOR<RiskAssessmentCreateWithoutContainerInput, RiskAssessmentUncheckedCreateWithoutContainerInput>
    where?: RiskAssessmentWhereInput
  }

  export type RiskAssessmentUpdateToOneWithWhereWithoutContainerInput = {
    where?: RiskAssessmentWhereInput
    data: XOR<RiskAssessmentUpdateWithoutContainerInput, RiskAssessmentUncheckedUpdateWithoutContainerInput>
  }

  export type RiskAssessmentUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    riskFactors?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerCreateWithoutShipmentContainersInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutShipmentContainersInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutShipmentContainersInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutShipmentContainersInput, ContainerUncheckedCreateWithoutShipmentContainersInput>
  }

  export type ShipmentCreateWithoutShipmentContainersInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutShipmentInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutShipmentContainersInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutShipmentInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutShipmentContainersInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutShipmentContainersInput, ShipmentUncheckedCreateWithoutShipmentContainersInput>
  }

  export type ContainerUpsertWithoutShipmentContainersInput = {
    update: XOR<ContainerUpdateWithoutShipmentContainersInput, ContainerUncheckedUpdateWithoutShipmentContainersInput>
    create: XOR<ContainerCreateWithoutShipmentContainersInput, ContainerUncheckedCreateWithoutShipmentContainersInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutShipmentContainersInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutShipmentContainersInput, ContainerUncheckedUpdateWithoutShipmentContainersInput>
  }

  export type ContainerUpdateWithoutShipmentContainersInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutShipmentContainersInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ShipmentUpsertWithoutShipmentContainersInput = {
    update: XOR<ShipmentUpdateWithoutShipmentContainersInput, ShipmentUncheckedUpdateWithoutShipmentContainersInput>
    create: XOR<ShipmentCreateWithoutShipmentContainersInput, ShipmentUncheckedCreateWithoutShipmentContainersInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutShipmentContainersInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutShipmentContainersInput, ShipmentUncheckedUpdateWithoutShipmentContainersInput>
  }

  export type ShipmentUpdateWithoutShipmentContainersInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutShipmentNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutShipmentContainersInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutShipmentNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type FacilityCreateWithoutContainerEventsInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
    port?: PortCreateNestedOneWithoutFacilitiesInput
  }

  export type FacilityUncheckedCreateWithoutContainerEventsInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    portId?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
  }

  export type FacilityCreateOrConnectWithoutContainerEventsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutContainerEventsInput, FacilityUncheckedCreateWithoutContainerEventsInput>
  }

  export type ImportLogCreateWithoutContainerEventsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutImportLogInput
    carrierFormat?: CarrierFormatCreateNestedOneWithoutImportLogsInput
    rawRows?: RawRowCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUncheckedCreateWithoutContainerEventsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    carrierFormatId?: string | null
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutImportLogInput
    rawRows?: RawRowUncheckedCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogCreateOrConnectWithoutContainerEventsInput = {
    where: ImportLogWhereUniqueInput
    create: XOR<ImportLogCreateWithoutContainerEventsInput, ImportLogUncheckedCreateWithoutContainerEventsInput>
  }

  export type TransitStageCreateWithoutPreviousEventsInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerCreateNestedManyWithoutStageInput
    containerEvents?: ContainerEventCreateNestedManyWithoutStageInput
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageUncheckedCreateWithoutPreviousEventsInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerUncheckedCreateNestedManyWithoutStageInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutStageInput
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageCreateOrConnectWithoutPreviousEventsInput = {
    where: TransitStageWhereUniqueInput
    create: XOR<TransitStageCreateWithoutPreviousEventsInput, TransitStageUncheckedCreateWithoutPreviousEventsInput>
  }

  export type TransitStageCreateWithoutContainerEventsInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerCreateNestedManyWithoutStageInput
    previousEvents?: ContainerEventCreateNestedManyWithoutPreviousStageInput
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageUncheckedCreateWithoutContainerEventsInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerUncheckedCreateNestedManyWithoutStageInput
    previousEvents?: ContainerEventUncheckedCreateNestedManyWithoutPreviousStageInput
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutTransitStageInput
  }

  export type TransitStageCreateOrConnectWithoutContainerEventsInput = {
    where: TransitStageWhereUniqueInput
    create: XOR<TransitStageCreateWithoutContainerEventsInput, TransitStageUncheckedCreateWithoutContainerEventsInput>
  }

  export type ContainerCreateWithoutEventsInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutEventsInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutEventsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutEventsInput, ContainerUncheckedCreateWithoutEventsInput>
  }

  export type FacilityUpsertWithoutContainerEventsInput = {
    update: XOR<FacilityUpdateWithoutContainerEventsInput, FacilityUncheckedUpdateWithoutContainerEventsInput>
    create: XOR<FacilityCreateWithoutContainerEventsInput, FacilityUncheckedCreateWithoutContainerEventsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutContainerEventsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutContainerEventsInput, FacilityUncheckedUpdateWithoutContainerEventsInput>
  }

  export type FacilityUpdateWithoutContainerEventsInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    port?: PortUpdateOneWithoutFacilitiesNestedInput
  }

  export type FacilityUncheckedUpdateWithoutContainerEventsInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImportLogUpsertWithoutContainerEventsInput = {
    update: XOR<ImportLogUpdateWithoutContainerEventsInput, ImportLogUncheckedUpdateWithoutContainerEventsInput>
    create: XOR<ImportLogCreateWithoutContainerEventsInput, ImportLogUncheckedCreateWithoutContainerEventsInput>
    where?: ImportLogWhereInput
  }

  export type ImportLogUpdateToOneWithWhereWithoutContainerEventsInput = {
    where?: ImportLogWhereInput
    data: XOR<ImportLogUpdateWithoutContainerEventsInput, ImportLogUncheckedUpdateWithoutContainerEventsInput>
  }

  export type ImportLogUpdateWithoutContainerEventsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutImportLogNestedInput
    carrierFormat?: CarrierFormatUpdateOneWithoutImportLogsNestedInput
    rawRows?: RawRowUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateWithoutContainerEventsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    carrierFormatId?: NullableStringFieldUpdateOperationsInput | string | null
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutImportLogNestedInput
    rawRows?: RawRowUncheckedUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutImportLogNestedInput
  }

  export type TransitStageUpsertWithoutPreviousEventsInput = {
    update: XOR<TransitStageUpdateWithoutPreviousEventsInput, TransitStageUncheckedUpdateWithoutPreviousEventsInput>
    create: XOR<TransitStageCreateWithoutPreviousEventsInput, TransitStageUncheckedCreateWithoutPreviousEventsInput>
    where?: TransitStageWhereInput
  }

  export type TransitStageUpdateToOneWithWhereWithoutPreviousEventsInput = {
    where?: TransitStageWhereInput
    data: XOR<TransitStageUpdateWithoutPreviousEventsInput, TransitStageUncheckedUpdateWithoutPreviousEventsInput>
  }

  export type TransitStageUpdateWithoutPreviousEventsInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUpdateManyWithoutStageNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutStageNestedInput
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutTransitStageNestedInput
  }

  export type TransitStageUncheckedUpdateWithoutPreviousEventsInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUncheckedUpdateManyWithoutStageNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutStageNestedInput
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutTransitStageNestedInput
  }

  export type TransitStageUpsertWithoutContainerEventsInput = {
    update: XOR<TransitStageUpdateWithoutContainerEventsInput, TransitStageUncheckedUpdateWithoutContainerEventsInput>
    create: XOR<TransitStageCreateWithoutContainerEventsInput, TransitStageUncheckedCreateWithoutContainerEventsInput>
    where?: TransitStageWhereInput
  }

  export type TransitStageUpdateToOneWithWhereWithoutContainerEventsInput = {
    where?: TransitStageWhereInput
    data: XOR<TransitStageUpdateWithoutContainerEventsInput, TransitStageUncheckedUpdateWithoutContainerEventsInput>
  }

  export type TransitStageUpdateWithoutContainerEventsInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUpdateManyWithoutStageNestedInput
    previousEvents?: ContainerEventUpdateManyWithoutPreviousStageNestedInput
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutTransitStageNestedInput
  }

  export type TransitStageUncheckedUpdateWithoutContainerEventsInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUncheckedUpdateManyWithoutStageNestedInput
    previousEvents?: ContainerEventUncheckedUpdateManyWithoutPreviousStageNestedInput
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutTransitStageNestedInput
  }

  export type ContainerUpsertWithoutEventsInput = {
    update: XOR<ContainerUpdateWithoutEventsInput, ContainerUncheckedUpdateWithoutEventsInput>
    create: XOR<ContainerCreateWithoutEventsInput, ContainerUncheckedCreateWithoutEventsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutEventsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutEventsInput, ContainerUncheckedUpdateWithoutEventsInput>
  }

  export type ContainerUpdateWithoutEventsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutEventsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ImportLogCreateWithoutShipmentEventsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventCreateNestedManyWithoutImportLogInput
    carrierFormat?: CarrierFormatCreateNestedOneWithoutImportLogsInput
    rawRows?: RawRowCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUncheckedCreateWithoutShipmentEventsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    carrierFormatId?: string | null
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutImportLogInput
    rawRows?: RawRowUncheckedCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogCreateOrConnectWithoutShipmentEventsInput = {
    where: ImportLogWhereUniqueInput
    create: XOR<ImportLogCreateWithoutShipmentEventsInput, ImportLogUncheckedCreateWithoutShipmentEventsInput>
  }

  export type ShipmentCreateWithoutShipmentEventsInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutShipmentInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutShipmentEventsInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutShipmentInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutShipmentEventsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutShipmentEventsInput, ShipmentUncheckedCreateWithoutShipmentEventsInput>
  }

  export type ImportLogUpsertWithoutShipmentEventsInput = {
    update: XOR<ImportLogUpdateWithoutShipmentEventsInput, ImportLogUncheckedUpdateWithoutShipmentEventsInput>
    create: XOR<ImportLogCreateWithoutShipmentEventsInput, ImportLogUncheckedCreateWithoutShipmentEventsInput>
    where?: ImportLogWhereInput
  }

  export type ImportLogUpdateToOneWithWhereWithoutShipmentEventsInput = {
    where?: ImportLogWhereInput
    data: XOR<ImportLogUpdateWithoutShipmentEventsInput, ImportLogUncheckedUpdateWithoutShipmentEventsInput>
  }

  export type ImportLogUpdateWithoutShipmentEventsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutImportLogNestedInput
    carrierFormat?: CarrierFormatUpdateOneWithoutImportLogsNestedInput
    rawRows?: RawRowUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateWithoutShipmentEventsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    carrierFormatId?: NullableStringFieldUpdateOperationsInput | string | null
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutImportLogNestedInput
    rawRows?: RawRowUncheckedUpdateManyWithoutImportLogNestedInput
  }

  export type ShipmentUpsertWithoutShipmentEventsInput = {
    update: XOR<ShipmentUpdateWithoutShipmentEventsInput, ShipmentUncheckedUpdateWithoutShipmentEventsInput>
    create: XOR<ShipmentCreateWithoutShipmentEventsInput, ShipmentUncheckedCreateWithoutShipmentEventsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutShipmentEventsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutShipmentEventsInput, ShipmentUncheckedUpdateWithoutShipmentEventsInput>
  }

  export type ShipmentUpdateWithoutShipmentEventsInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutShipmentNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutShipmentEventsInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutShipmentNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ImportLogCreateWithoutAceStatusLogsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    containerEvents?: ContainerEventCreateNestedManyWithoutImportLogInput
    carrierFormat?: CarrierFormatCreateNestedOneWithoutImportLogsInput
    rawRows?: RawRowCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUncheckedCreateWithoutAceStatusLogsInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    carrierFormatId?: string | null
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutImportLogInput
    rawRows?: RawRowUncheckedCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogCreateOrConnectWithoutAceStatusLogsInput = {
    where: ImportLogWhereUniqueInput
    create: XOR<ImportLogCreateWithoutAceStatusLogsInput, ImportLogUncheckedCreateWithoutAceStatusLogsInput>
  }

  export type ShipmentCreateWithoutAceStatusLogsInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutShipmentInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutAceStatusLogsInput = {
    shipmentReference: string
    hbl?: string | null
    mbl?: string | null
    bookingReference?: string | null
    shipmentType?: string | null
    carrier?: string | null
    forwarder?: string | null
    shipper?: string | null
    consignee?: string | null
    pol?: string | null
    pod?: string | null
    finalDestination?: string | null
    contents?: string | null
    supplier?: string | null
    totalWeight?: number | null
    totalPieces?: number | null
    customerReference?: string | null
    poNumber?: string | null
    incoTerms?: string | null
    expectedContainers?: number | null
    blType?: string | null
    blStatus?: string | null
    paymentStatus?: string | null
    paymentDueDate?: Date | string | null
    amountDue?: number | null
    releaseStatus?: string | null
    releaseDate?: Date | string | null
    holdReason?: string | null
    notes?: string | null
    aceEntryNumber?: string | null
    aceEntryType?: string | null
    dutyAmount?: number | null
    liquidationStatus?: string | null
    liquidationDate?: Date | string | null
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutShipmentInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutAceStatusLogsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutAceStatusLogsInput, ShipmentUncheckedCreateWithoutAceStatusLogsInput>
  }

  export type ContainerCreateWithoutAceStatusLogsInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutAceStatusLogsInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutAceStatusLogsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutAceStatusLogsInput, ContainerUncheckedCreateWithoutAceStatusLogsInput>
  }

  export type ImportLogUpsertWithoutAceStatusLogsInput = {
    update: XOR<ImportLogUpdateWithoutAceStatusLogsInput, ImportLogUncheckedUpdateWithoutAceStatusLogsInput>
    create: XOR<ImportLogCreateWithoutAceStatusLogsInput, ImportLogUncheckedCreateWithoutAceStatusLogsInput>
    where?: ImportLogWhereInput
  }

  export type ImportLogUpdateToOneWithWhereWithoutAceStatusLogsInput = {
    where?: ImportLogWhereInput
    data: XOR<ImportLogUpdateWithoutAceStatusLogsInput, ImportLogUncheckedUpdateWithoutAceStatusLogsInput>
  }

  export type ImportLogUpdateWithoutAceStatusLogsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    containerEvents?: ContainerEventUpdateManyWithoutImportLogNestedInput
    carrierFormat?: CarrierFormatUpdateOneWithoutImportLogsNestedInput
    rawRows?: RawRowUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateWithoutAceStatusLogsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    carrierFormatId?: NullableStringFieldUpdateOperationsInput | string | null
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutImportLogNestedInput
    rawRows?: RawRowUncheckedUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutImportLogNestedInput
  }

  export type ShipmentUpsertWithoutAceStatusLogsInput = {
    update: XOR<ShipmentUpdateWithoutAceStatusLogsInput, ShipmentUncheckedUpdateWithoutAceStatusLogsInput>
    create: XOR<ShipmentCreateWithoutAceStatusLogsInput, ShipmentUncheckedCreateWithoutAceStatusLogsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutAceStatusLogsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutAceStatusLogsInput, ShipmentUncheckedUpdateWithoutAceStatusLogsInput>
  }

  export type ShipmentUpdateWithoutAceStatusLogsInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipmentContainers?: ShipmentContainerUpdateManyWithoutShipmentNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutAceStatusLogsInput = {
    shipmentReference?: StringFieldUpdateOperationsInput | string
    hbl?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    bookingReference?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    forwarder?: NullableStringFieldUpdateOperationsInput | string | null
    shipper?: NullableStringFieldUpdateOperationsInput | string | null
    consignee?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    finalDestination?: NullableStringFieldUpdateOperationsInput | string | null
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPieces?: NullableIntFieldUpdateOperationsInput | number | null
    customerReference?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incoTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedContainers?: NullableIntFieldUpdateOperationsInput | number | null
    blType?: NullableStringFieldUpdateOperationsInput | string | null
    blStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseStatus?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryType?: NullableStringFieldUpdateOperationsInput | string | null
    dutyAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutShipmentNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ContainerUpsertWithoutAceStatusLogsInput = {
    update: XOR<ContainerUpdateWithoutAceStatusLogsInput, ContainerUncheckedUpdateWithoutAceStatusLogsInput>
    create: XOR<ContainerCreateWithoutAceStatusLogsInput, ContainerUncheckedCreateWithoutAceStatusLogsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutAceStatusLogsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutAceStatusLogsInput, ContainerUncheckedUpdateWithoutAceStatusLogsInput>
  }

  export type ContainerUpdateWithoutAceStatusLogsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutAceStatusLogsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ContainerEventCreateWithoutFacilityInput = {
    id?: string
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
    importLog?: ImportLogCreateNestedOneWithoutContainerEventsInput
    previousStage?: TransitStageCreateNestedOneWithoutPreviousEventsInput
    stage?: TransitStageCreateNestedOneWithoutContainerEventsInput
    container: ContainerCreateNestedOneWithoutEventsInput
  }

  export type ContainerEventUncheckedCreateWithoutFacilityInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventCreateOrConnectWithoutFacilityInput = {
    where: ContainerEventWhereUniqueInput
    create: XOR<ContainerEventCreateWithoutFacilityInput, ContainerEventUncheckedCreateWithoutFacilityInput>
  }

  export type ContainerEventCreateManyFacilityInputEnvelope = {
    data: ContainerEventCreateManyFacilityInput | ContainerEventCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type PortCreateWithoutFacilitiesInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
    demurrageRates?: DemurrageRateCreateNestedManyWithoutPortInput
  }

  export type PortUncheckedCreateWithoutFacilitiesInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
    demurrageRates?: DemurrageRateUncheckedCreateNestedManyWithoutPortInput
  }

  export type PortCreateOrConnectWithoutFacilitiesInput = {
    where: PortWhereUniqueInput
    create: XOR<PortCreateWithoutFacilitiesInput, PortUncheckedCreateWithoutFacilitiesInput>
  }

  export type ContainerEventUpsertWithWhereUniqueWithoutFacilityInput = {
    where: ContainerEventWhereUniqueInput
    update: XOR<ContainerEventUpdateWithoutFacilityInput, ContainerEventUncheckedUpdateWithoutFacilityInput>
    create: XOR<ContainerEventCreateWithoutFacilityInput, ContainerEventUncheckedCreateWithoutFacilityInput>
  }

  export type ContainerEventUpdateWithWhereUniqueWithoutFacilityInput = {
    where: ContainerEventWhereUniqueInput
    data: XOR<ContainerEventUpdateWithoutFacilityInput, ContainerEventUncheckedUpdateWithoutFacilityInput>
  }

  export type ContainerEventUpdateManyWithWhereWithoutFacilityInput = {
    where: ContainerEventScalarWhereInput
    data: XOR<ContainerEventUpdateManyMutationInput, ContainerEventUncheckedUpdateManyWithoutFacilityInput>
  }

  export type PortUpsertWithoutFacilitiesInput = {
    update: XOR<PortUpdateWithoutFacilitiesInput, PortUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<PortCreateWithoutFacilitiesInput, PortUncheckedCreateWithoutFacilitiesInput>
    where?: PortWhereInput
  }

  export type PortUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: PortWhereInput
    data: XOR<PortUpdateWithoutFacilitiesInput, PortUncheckedUpdateWithoutFacilitiesInput>
  }

  export type PortUpdateWithoutFacilitiesInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    demurrageRates?: DemurrageRateUpdateManyWithoutPortNestedInput
  }

  export type PortUncheckedUpdateWithoutFacilitiesInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    demurrageRates?: DemurrageRateUncheckedUpdateManyWithoutPortNestedInput
  }

  export type CarrierFormatCreateWithoutCarrierInput = {
    formatName: string
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
    importLogs?: ImportLogCreateNestedManyWithoutCarrierFormatInput
  }

  export type CarrierFormatUncheckedCreateWithoutCarrierInput = {
    formatName: string
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutCarrierFormatInput
  }

  export type CarrierFormatCreateOrConnectWithoutCarrierInput = {
    where: CarrierFormatWhereUniqueInput
    create: XOR<CarrierFormatCreateWithoutCarrierInput, CarrierFormatUncheckedCreateWithoutCarrierInput>
  }

  export type CarrierFormatCreateManyCarrierInputEnvelope = {
    data: CarrierFormatCreateManyCarrierInput | CarrierFormatCreateManyCarrierInput[]
    skipDuplicates?: boolean
  }

  export type DCSAEventMapCreateWithoutCarrierInput = {
    name: string
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
    transitStage?: TransitStageCreateNestedOneWithoutDcsaEventMapsInput
  }

  export type DCSAEventMapUncheckedCreateWithoutCarrierInput = {
    name: string
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    transitStageName?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
  }

  export type DCSAEventMapCreateOrConnectWithoutCarrierInput = {
    where: DCSAEventMapWhereUniqueInput
    create: XOR<DCSAEventMapCreateWithoutCarrierInput, DCSAEventMapUncheckedCreateWithoutCarrierInput>
  }

  export type DCSAEventMapCreateManyCarrierInputEnvelope = {
    data: DCSAEventMapCreateManyCarrierInput | DCSAEventMapCreateManyCarrierInput[]
    skipDuplicates?: boolean
  }

  export type DemurrageRateCreateWithoutCarrierInput = {
    name: string
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    port?: PortCreateNestedOneWithoutDemurrageRatesInput
  }

  export type DemurrageRateUncheckedCreateWithoutCarrierInput = {
    name: string
    portId?: string | null
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
  }

  export type DemurrageRateCreateOrConnectWithoutCarrierInput = {
    where: DemurrageRateWhereUniqueInput
    create: XOR<DemurrageRateCreateWithoutCarrierInput, DemurrageRateUncheckedCreateWithoutCarrierInput>
  }

  export type DemurrageRateCreateManyCarrierInputEnvelope = {
    data: DemurrageRateCreateManyCarrierInput | DemurrageRateCreateManyCarrierInput[]
    skipDuplicates?: boolean
  }

  export type CarrierFormatUpsertWithWhereUniqueWithoutCarrierInput = {
    where: CarrierFormatWhereUniqueInput
    update: XOR<CarrierFormatUpdateWithoutCarrierInput, CarrierFormatUncheckedUpdateWithoutCarrierInput>
    create: XOR<CarrierFormatCreateWithoutCarrierInput, CarrierFormatUncheckedCreateWithoutCarrierInput>
  }

  export type CarrierFormatUpdateWithWhereUniqueWithoutCarrierInput = {
    where: CarrierFormatWhereUniqueInput
    data: XOR<CarrierFormatUpdateWithoutCarrierInput, CarrierFormatUncheckedUpdateWithoutCarrierInput>
  }

  export type CarrierFormatUpdateManyWithWhereWithoutCarrierInput = {
    where: CarrierFormatScalarWhereInput
    data: XOR<CarrierFormatUpdateManyMutationInput, CarrierFormatUncheckedUpdateManyWithoutCarrierInput>
  }

  export type CarrierFormatScalarWhereInput = {
    AND?: CarrierFormatScalarWhereInput | CarrierFormatScalarWhereInput[]
    OR?: CarrierFormatScalarWhereInput[]
    NOT?: CarrierFormatScalarWhereInput | CarrierFormatScalarWhereInput[]
    formatName?: StringFilter<"CarrierFormat"> | string
    carrierId?: StringNullableFilter<"CarrierFormat"> | string | null
    formatType?: StringNullableFilter<"CarrierFormat"> | string | null
    columnMapping?: StringNullableFilter<"CarrierFormat"> | string | null
    sampleHeaders?: StringNullableFilter<"CarrierFormat"> | string | null
    isActive?: BoolFilter<"CarrierFormat"> | boolean
    notes?: StringNullableFilter<"CarrierFormat"> | string | null
  }

  export type DCSAEventMapUpsertWithWhereUniqueWithoutCarrierInput = {
    where: DCSAEventMapWhereUniqueInput
    update: XOR<DCSAEventMapUpdateWithoutCarrierInput, DCSAEventMapUncheckedUpdateWithoutCarrierInput>
    create: XOR<DCSAEventMapCreateWithoutCarrierInput, DCSAEventMapUncheckedCreateWithoutCarrierInput>
  }

  export type DCSAEventMapUpdateWithWhereUniqueWithoutCarrierInput = {
    where: DCSAEventMapWhereUniqueInput
    data: XOR<DCSAEventMapUpdateWithoutCarrierInput, DCSAEventMapUncheckedUpdateWithoutCarrierInput>
  }

  export type DCSAEventMapUpdateManyWithWhereWithoutCarrierInput = {
    where: DCSAEventMapScalarWhereInput
    data: XOR<DCSAEventMapUpdateManyMutationInput, DCSAEventMapUncheckedUpdateManyWithoutCarrierInput>
  }

  export type DemurrageRateUpsertWithWhereUniqueWithoutCarrierInput = {
    where: DemurrageRateWhereUniqueInput
    update: XOR<DemurrageRateUpdateWithoutCarrierInput, DemurrageRateUncheckedUpdateWithoutCarrierInput>
    create: XOR<DemurrageRateCreateWithoutCarrierInput, DemurrageRateUncheckedCreateWithoutCarrierInput>
  }

  export type DemurrageRateUpdateWithWhereUniqueWithoutCarrierInput = {
    where: DemurrageRateWhereUniqueInput
    data: XOR<DemurrageRateUpdateWithoutCarrierInput, DemurrageRateUncheckedUpdateWithoutCarrierInput>
  }

  export type DemurrageRateUpdateManyWithWhereWithoutCarrierInput = {
    where: DemurrageRateScalarWhereInput
    data: XOR<DemurrageRateUpdateManyMutationInput, DemurrageRateUncheckedUpdateManyWithoutCarrierInput>
  }

  export type DemurrageRateScalarWhereInput = {
    AND?: DemurrageRateScalarWhereInput | DemurrageRateScalarWhereInput[]
    OR?: DemurrageRateScalarWhereInput[]
    NOT?: DemurrageRateScalarWhereInput | DemurrageRateScalarWhereInput[]
    name?: StringFilter<"DemurrageRate"> | string
    carrierId?: StringNullableFilter<"DemurrageRate"> | string | null
    portId?: StringNullableFilter<"DemurrageRate"> | string | null
    containerType?: StringNullableFilter<"DemurrageRate"> | string | null
    freeDays?: IntNullableFilter<"DemurrageRate"> | number | null
    dailyRate?: FloatNullableFilter<"DemurrageRate"> | number | null
    effectiveFrom?: DateTimeNullableFilter<"DemurrageRate"> | Date | string | null
    effectiveTo?: DateTimeNullableFilter<"DemurrageRate"> | Date | string | null
    notes?: StringNullableFilter<"DemurrageRate"> | string | null
  }

  export type DemurrageRateCreateWithoutPortInput = {
    name: string
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    carrier?: CarrierCreateNestedOneWithoutDemurrageRatesInput
  }

  export type DemurrageRateUncheckedCreateWithoutPortInput = {
    name: string
    carrierId?: string | null
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
  }

  export type DemurrageRateCreateOrConnectWithoutPortInput = {
    where: DemurrageRateWhereUniqueInput
    create: XOR<DemurrageRateCreateWithoutPortInput, DemurrageRateUncheckedCreateWithoutPortInput>
  }

  export type DemurrageRateCreateManyPortInputEnvelope = {
    data: DemurrageRateCreateManyPortInput | DemurrageRateCreateManyPortInput[]
    skipDuplicates?: boolean
  }

  export type FacilityCreateWithoutPortInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
    containerEvents?: ContainerEventCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutPortInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutPortInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutPortInput, FacilityUncheckedCreateWithoutPortInput>
  }

  export type FacilityCreateManyPortInputEnvelope = {
    data: FacilityCreateManyPortInput | FacilityCreateManyPortInput[]
    skipDuplicates?: boolean
  }

  export type DemurrageRateUpsertWithWhereUniqueWithoutPortInput = {
    where: DemurrageRateWhereUniqueInput
    update: XOR<DemurrageRateUpdateWithoutPortInput, DemurrageRateUncheckedUpdateWithoutPortInput>
    create: XOR<DemurrageRateCreateWithoutPortInput, DemurrageRateUncheckedCreateWithoutPortInput>
  }

  export type DemurrageRateUpdateWithWhereUniqueWithoutPortInput = {
    where: DemurrageRateWhereUniqueInput
    data: XOR<DemurrageRateUpdateWithoutPortInput, DemurrageRateUncheckedUpdateWithoutPortInput>
  }

  export type DemurrageRateUpdateManyWithWhereWithoutPortInput = {
    where: DemurrageRateScalarWhereInput
    data: XOR<DemurrageRateUpdateManyMutationInput, DemurrageRateUncheckedUpdateManyWithoutPortInput>
  }

  export type FacilityUpsertWithWhereUniqueWithoutPortInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutPortInput, FacilityUncheckedUpdateWithoutPortInput>
    create: XOR<FacilityCreateWithoutPortInput, FacilityUncheckedCreateWithoutPortInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutPortInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutPortInput, FacilityUncheckedUpdateWithoutPortInput>
  }

  export type FacilityUpdateManyWithWhereWithoutPortInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutPortInput>
  }

  export type FacilityScalarWhereInput = {
    AND?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    OR?: FacilityScalarWhereInput[]
    NOT?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    facilityName?: StringFilter<"Facility"> | string
    facilityCode?: StringNullableFilter<"Facility"> | string | null
    facilityType?: StringNullableFilter<"Facility"> | string | null
    portId?: StringNullableFilter<"Facility"> | string | null
    address?: StringNullableFilter<"Facility"> | string | null
    unLocationCode?: StringNullableFilter<"Facility"> | string | null
    isActive?: BoolFilter<"Facility"> | boolean
  }

  export type PortCreateWithoutDemurrageRatesInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
    facilities?: FacilityCreateNestedManyWithoutPortInput
  }

  export type PortUncheckedCreateWithoutDemurrageRatesInput = {
    portName: string
    portCode?: string | null
    country?: string | null
    countryCode?: string | null
    region?: string | null
    defaultFreeDays?: number | null
    isActive?: boolean
    acePortCode?: string | null
    cbpDistrict?: string | null
    facilities?: FacilityUncheckedCreateNestedManyWithoutPortInput
  }

  export type PortCreateOrConnectWithoutDemurrageRatesInput = {
    where: PortWhereUniqueInput
    create: XOR<PortCreateWithoutDemurrageRatesInput, PortUncheckedCreateWithoutDemurrageRatesInput>
  }

  export type CarrierCreateWithoutDemurrageRatesInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    carrierFormats?: CarrierFormatCreateNestedManyWithoutCarrierInput
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutCarrierInput
  }

  export type CarrierUncheckedCreateWithoutDemurrageRatesInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    carrierFormats?: CarrierFormatUncheckedCreateNestedManyWithoutCarrierInput
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutCarrierInput
  }

  export type CarrierCreateOrConnectWithoutDemurrageRatesInput = {
    where: CarrierWhereUniqueInput
    create: XOR<CarrierCreateWithoutDemurrageRatesInput, CarrierUncheckedCreateWithoutDemurrageRatesInput>
  }

  export type PortUpsertWithoutDemurrageRatesInput = {
    update: XOR<PortUpdateWithoutDemurrageRatesInput, PortUncheckedUpdateWithoutDemurrageRatesInput>
    create: XOR<PortCreateWithoutDemurrageRatesInput, PortUncheckedCreateWithoutDemurrageRatesInput>
    where?: PortWhereInput
  }

  export type PortUpdateToOneWithWhereWithoutDemurrageRatesInput = {
    where?: PortWhereInput
    data: XOR<PortUpdateWithoutDemurrageRatesInput, PortUncheckedUpdateWithoutDemurrageRatesInput>
  }

  export type PortUpdateWithoutDemurrageRatesInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    facilities?: FacilityUpdateManyWithoutPortNestedInput
  }

  export type PortUncheckedUpdateWithoutDemurrageRatesInput = {
    portName?: StringFieldUpdateOperationsInput | string
    portCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFreeDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acePortCode?: NullableStringFieldUpdateOperationsInput | string | null
    cbpDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    facilities?: FacilityUncheckedUpdateManyWithoutPortNestedInput
  }

  export type CarrierUpsertWithoutDemurrageRatesInput = {
    update: XOR<CarrierUpdateWithoutDemurrageRatesInput, CarrierUncheckedUpdateWithoutDemurrageRatesInput>
    create: XOR<CarrierCreateWithoutDemurrageRatesInput, CarrierUncheckedCreateWithoutDemurrageRatesInput>
    where?: CarrierWhereInput
  }

  export type CarrierUpdateToOneWithWhereWithoutDemurrageRatesInput = {
    where?: CarrierWhereInput
    data: XOR<CarrierUpdateWithoutDemurrageRatesInput, CarrierUncheckedUpdateWithoutDemurrageRatesInput>
  }

  export type CarrierUpdateWithoutDemurrageRatesInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    carrierFormats?: CarrierFormatUpdateManyWithoutCarrierNestedInput
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutCarrierNestedInput
  }

  export type CarrierUncheckedUpdateWithoutDemurrageRatesInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    carrierFormats?: CarrierFormatUncheckedUpdateManyWithoutCarrierNestedInput
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutCarrierNestedInput
  }

  export type CarrierCreateWithoutCarrierFormatsInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    dcsaEventMaps?: DCSAEventMapCreateNestedManyWithoutCarrierInput
    demurrageRates?: DemurrageRateCreateNestedManyWithoutCarrierInput
  }

  export type CarrierUncheckedCreateWithoutCarrierFormatsInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    dcsaEventMaps?: DCSAEventMapUncheckedCreateNestedManyWithoutCarrierInput
    demurrageRates?: DemurrageRateUncheckedCreateNestedManyWithoutCarrierInput
  }

  export type CarrierCreateOrConnectWithoutCarrierFormatsInput = {
    where: CarrierWhereUniqueInput
    create: XOR<CarrierCreateWithoutCarrierFormatsInput, CarrierUncheckedCreateWithoutCarrierFormatsInput>
  }

  export type ImportLogCreateWithoutCarrierFormatInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventCreateNestedManyWithoutImportLogInput
    rawRows?: RawRowCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogUncheckedCreateWithoutCarrierFormatInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutImportLogInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutImportLogInput
    rawRows?: RawRowUncheckedCreateNestedManyWithoutImportLogInput
    shipmentEvents?: ShipmentEventUncheckedCreateNestedManyWithoutImportLogInput
  }

  export type ImportLogCreateOrConnectWithoutCarrierFormatInput = {
    where: ImportLogWhereUniqueInput
    create: XOR<ImportLogCreateWithoutCarrierFormatInput, ImportLogUncheckedCreateWithoutCarrierFormatInput>
  }

  export type ImportLogCreateManyCarrierFormatInputEnvelope = {
    data: ImportLogCreateManyCarrierFormatInput | ImportLogCreateManyCarrierFormatInput[]
    skipDuplicates?: boolean
  }

  export type CarrierUpsertWithoutCarrierFormatsInput = {
    update: XOR<CarrierUpdateWithoutCarrierFormatsInput, CarrierUncheckedUpdateWithoutCarrierFormatsInput>
    create: XOR<CarrierCreateWithoutCarrierFormatsInput, CarrierUncheckedCreateWithoutCarrierFormatsInput>
    where?: CarrierWhereInput
  }

  export type CarrierUpdateToOneWithWhereWithoutCarrierFormatsInput = {
    where?: CarrierWhereInput
    data: XOR<CarrierUpdateWithoutCarrierFormatsInput, CarrierUncheckedUpdateWithoutCarrierFormatsInput>
  }

  export type CarrierUpdateWithoutCarrierFormatsInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventMaps?: DCSAEventMapUpdateManyWithoutCarrierNestedInput
    demurrageRates?: DemurrageRateUpdateManyWithoutCarrierNestedInput
  }

  export type CarrierUncheckedUpdateWithoutCarrierFormatsInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventMaps?: DCSAEventMapUncheckedUpdateManyWithoutCarrierNestedInput
    demurrageRates?: DemurrageRateUncheckedUpdateManyWithoutCarrierNestedInput
  }

  export type ImportLogUpsertWithWhereUniqueWithoutCarrierFormatInput = {
    where: ImportLogWhereUniqueInput
    update: XOR<ImportLogUpdateWithoutCarrierFormatInput, ImportLogUncheckedUpdateWithoutCarrierFormatInput>
    create: XOR<ImportLogCreateWithoutCarrierFormatInput, ImportLogUncheckedCreateWithoutCarrierFormatInput>
  }

  export type ImportLogUpdateWithWhereUniqueWithoutCarrierFormatInput = {
    where: ImportLogWhereUniqueInput
    data: XOR<ImportLogUpdateWithoutCarrierFormatInput, ImportLogUncheckedUpdateWithoutCarrierFormatInput>
  }

  export type ImportLogUpdateManyWithWhereWithoutCarrierFormatInput = {
    where: ImportLogScalarWhereInput
    data: XOR<ImportLogUpdateManyMutationInput, ImportLogUncheckedUpdateManyWithoutCarrierFormatInput>
  }

  export type ImportLogScalarWhereInput = {
    AND?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
    OR?: ImportLogScalarWhereInput[]
    NOT?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
    fileName?: StringFilter<"ImportLog"> | string
    fileURL?: StringNullableFilter<"ImportLog"> | string | null
    importedBy?: StringNullableFilter<"ImportLog"> | string | null
    importedOn?: DateTimeFilter<"ImportLog"> | Date | string
    rowsProcessed?: IntFilter<"ImportLog"> | number
    rowsSucceeded?: IntFilter<"ImportLog"> | number
    rowsFailed?: IntFilter<"ImportLog"> | number
    carrierFormatId?: StringNullableFilter<"ImportLog"> | string | null
    importType?: StringNullableFilter<"ImportLog"> | string | null
    status?: StringFilter<"ImportLog"> | string
    errorLog?: StringNullableFilter<"ImportLog"> | string | null
    aiAnalysis?: JsonNullableFilter<"ImportLog">
    aiAnalyzedAt?: DateTimeNullableFilter<"ImportLog"> | Date | string | null
  }

  export type TransitStageCreateWithoutDcsaEventMapsInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerCreateNestedManyWithoutStageInput
    previousEvents?: ContainerEventCreateNestedManyWithoutPreviousStageInput
    containerEvents?: ContainerEventCreateNestedManyWithoutStageInput
  }

  export type TransitStageUncheckedCreateWithoutDcsaEventMapsInput = {
    stageName: string
    stageCode?: string | null
    sequence: number
    category?: string | null
    expectedDays?: number | null
    alertAfterDays?: number | null
    responsibleTeam?: string | null
    isActive?: boolean
    dcsaEventType?: string | null
    dcsaEventCategory?: string | null
    dcsaFacilityType?: string | null
    containers?: ContainerUncheckedCreateNestedManyWithoutStageInput
    previousEvents?: ContainerEventUncheckedCreateNestedManyWithoutPreviousStageInput
    containerEvents?: ContainerEventUncheckedCreateNestedManyWithoutStageInput
  }

  export type TransitStageCreateOrConnectWithoutDcsaEventMapsInput = {
    where: TransitStageWhereUniqueInput
    create: XOR<TransitStageCreateWithoutDcsaEventMapsInput, TransitStageUncheckedCreateWithoutDcsaEventMapsInput>
  }

  export type CarrierCreateWithoutDcsaEventMapsInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    carrierFormats?: CarrierFormatCreateNestedManyWithoutCarrierInput
    demurrageRates?: DemurrageRateCreateNestedManyWithoutCarrierInput
  }

  export type CarrierUncheckedCreateWithoutDcsaEventMapsInput = {
    carrierName: string
    scac?: string | null
    shortName?: string | null
    trackingURL?: string | null
    isActive?: boolean
    dcsaCompliant?: boolean | null
    apiEndpoint?: string | null
    apiCredentialRef?: string | null
    carrierFormats?: CarrierFormatUncheckedCreateNestedManyWithoutCarrierInput
    demurrageRates?: DemurrageRateUncheckedCreateNestedManyWithoutCarrierInput
  }

  export type CarrierCreateOrConnectWithoutDcsaEventMapsInput = {
    where: CarrierWhereUniqueInput
    create: XOR<CarrierCreateWithoutDcsaEventMapsInput, CarrierUncheckedCreateWithoutDcsaEventMapsInput>
  }

  export type TransitStageUpsertWithoutDcsaEventMapsInput = {
    update: XOR<TransitStageUpdateWithoutDcsaEventMapsInput, TransitStageUncheckedUpdateWithoutDcsaEventMapsInput>
    create: XOR<TransitStageCreateWithoutDcsaEventMapsInput, TransitStageUncheckedCreateWithoutDcsaEventMapsInput>
    where?: TransitStageWhereInput
  }

  export type TransitStageUpdateToOneWithWhereWithoutDcsaEventMapsInput = {
    where?: TransitStageWhereInput
    data: XOR<TransitStageUpdateWithoutDcsaEventMapsInput, TransitStageUncheckedUpdateWithoutDcsaEventMapsInput>
  }

  export type TransitStageUpdateWithoutDcsaEventMapsInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUpdateManyWithoutStageNestedInput
    previousEvents?: ContainerEventUpdateManyWithoutPreviousStageNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutStageNestedInput
  }

  export type TransitStageUncheckedUpdateWithoutDcsaEventMapsInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    stageCode?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDays?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    responsibleTeam?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaFacilityType?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUncheckedUpdateManyWithoutStageNestedInput
    previousEvents?: ContainerEventUncheckedUpdateManyWithoutPreviousStageNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutStageNestedInput
  }

  export type CarrierUpsertWithoutDcsaEventMapsInput = {
    update: XOR<CarrierUpdateWithoutDcsaEventMapsInput, CarrierUncheckedUpdateWithoutDcsaEventMapsInput>
    create: XOR<CarrierCreateWithoutDcsaEventMapsInput, CarrierUncheckedCreateWithoutDcsaEventMapsInput>
    where?: CarrierWhereInput
  }

  export type CarrierUpdateToOneWithWhereWithoutDcsaEventMapsInput = {
    where?: CarrierWhereInput
    data: XOR<CarrierUpdateWithoutDcsaEventMapsInput, CarrierUncheckedUpdateWithoutDcsaEventMapsInput>
  }

  export type CarrierUpdateWithoutDcsaEventMapsInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    carrierFormats?: CarrierFormatUpdateManyWithoutCarrierNestedInput
    demurrageRates?: DemurrageRateUpdateManyWithoutCarrierNestedInput
  }

  export type CarrierUncheckedUpdateWithoutDcsaEventMapsInput = {
    carrierName?: StringFieldUpdateOperationsInput | string
    scac?: NullableStringFieldUpdateOperationsInput | string | null
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    trackingURL?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dcsaCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredentialRef?: NullableStringFieldUpdateOperationsInput | string | null
    carrierFormats?: CarrierFormatUncheckedUpdateManyWithoutCarrierNestedInput
    demurrageRates?: DemurrageRateUncheckedUpdateManyWithoutCarrierNestedInput
  }

  export type ContainerCreateWithoutAttentionFlagsInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutAttentionFlagsInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutAttentionFlagsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutAttentionFlagsInput, ContainerUncheckedCreateWithoutAttentionFlagsInput>
  }

  export type ContainerUpsertWithoutAttentionFlagsInput = {
    update: XOR<ContainerUpdateWithoutAttentionFlagsInput, ContainerUncheckedUpdateWithoutAttentionFlagsInput>
    create: XOR<ContainerCreateWithoutAttentionFlagsInput, ContainerUncheckedCreateWithoutAttentionFlagsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutAttentionFlagsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutAttentionFlagsInput, ContainerUncheckedUpdateWithoutAttentionFlagsInput>
  }

  export type ContainerUpdateWithoutAttentionFlagsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutAttentionFlagsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ContainerCreateWithoutActivityLogsInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutActivityLogsInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutActivityLogsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutActivityLogsInput, ContainerUncheckedCreateWithoutActivityLogsInput>
  }

  export type ContainerUpsertWithoutActivityLogsInput = {
    update: XOR<ContainerUpdateWithoutActivityLogsInput, ContainerUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<ContainerCreateWithoutActivityLogsInput, ContainerUncheckedCreateWithoutActivityLogsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutActivityLogsInput, ContainerUncheckedUpdateWithoutActivityLogsInput>
  }

  export type ContainerUpdateWithoutActivityLogsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutActivityLogsInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ContainerCreateWithoutStatusOverridesInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutStatusOverridesInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutStatusOverridesInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutStatusOverridesInput, ContainerUncheckedCreateWithoutStatusOverridesInput>
  }

  export type ContainerUpsertWithoutStatusOverridesInput = {
    update: XOR<ContainerUpdateWithoutStatusOverridesInput, ContainerUncheckedUpdateWithoutStatusOverridesInput>
    create: XOR<ContainerCreateWithoutStatusOverridesInput, ContainerUncheckedCreateWithoutStatusOverridesInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutStatusOverridesInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutStatusOverridesInput, ContainerUncheckedUpdateWithoutStatusOverridesInput>
  }

  export type ContainerUpdateWithoutStatusOverridesInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutStatusOverridesInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ContainerCreateWithoutRiskAssessmentInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogCreateNestedManyWithoutContainerInput
    stage?: TransitStageCreateNestedOneWithoutContainersInput
    events?: ContainerEventCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutRiskAssessmentInput = {
    containerNumber: string
    containerType?: string | null
    currentStatus?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aceStatusLogs?: ACEStatusLogUncheckedCreateNestedManyWithoutContainerInput
    events?: ContainerEventUncheckedCreateNestedManyWithoutContainerInput
    shipmentContainers?: ShipmentContainerUncheckedCreateNestedManyWithoutContainerInput
    attentionFlags?: AttentionFlagUncheckedCreateNestedManyWithoutContainerInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutContainerInput
    statusOverrides?: StatusOverrideUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutRiskAssessmentInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutRiskAssessmentInput, ContainerUncheckedCreateWithoutRiskAssessmentInput>
  }

  export type ContainerUpsertWithoutRiskAssessmentInput = {
    update: XOR<ContainerUpdateWithoutRiskAssessmentInput, ContainerUncheckedUpdateWithoutRiskAssessmentInput>
    create: XOR<ContainerCreateWithoutRiskAssessmentInput, ContainerUncheckedCreateWithoutRiskAssessmentInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutRiskAssessmentInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutRiskAssessmentInput, ContainerUncheckedUpdateWithoutRiskAssessmentInput>
  }

  export type ContainerUpdateWithoutRiskAssessmentInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    stage?: TransitStageUpdateOneWithoutContainersNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutRiskAssessmentInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ACEStatusLogCreateManyImportLogInput = {
    id?: string
    containerId?: string | null
    shipmentId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ContainerEventCreateManyImportLogInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type RawRowCreateManyImportLogInput = {
    id?: string
    rowNumber: number
    data: string
  }

  export type ShipmentEventCreateManyImportLogInput = {
    id?: string
    shipmentId: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
  }

  export type ACEStatusLogUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shipment?: ShipmentUpdateOneWithoutAceStatusLogsNestedInput
    container?: ContainerUpdateOneWithoutAceStatusLogsNestedInput
  }

  export type ACEStatusLogUncheckedUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogUncheckedUpdateManyWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutContainerEventsNestedInput
    previousStage?: TransitStageUpdateOneWithoutPreviousEventsNestedInput
    stage?: TransitStageUpdateOneWithoutContainerEventsNestedInput
    container?: ContainerUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContainerEventUncheckedUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUncheckedUpdateManyWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RawRowUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type RawRowUncheckedUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type RawRowUncheckedUpdateManyWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type ShipmentEventUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    shipment?: ShipmentUpdateOneRequiredWithoutShipmentEventsNestedInput
  }

  export type ShipmentEventUncheckedUpdateWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentEventUncheckedUpdateManyWithoutImportLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerCreateManyStageInput = {
    containerNumber: string
    containerType?: string | null
    currentLocation?: string | null
    currentVessel?: string | null
    currentVoyage?: string | null
    mbl?: string | null
    carrier?: string | null
    pol?: string | null
    pod?: string | null
    etd?: Date | string | null
    atd?: Date | string | null
    eta?: Date | string | null
    ata?: Date | string | null
    lastFreeDay?: Date | string | null
    detentionFreeDay?: Date | string | null
    statusLastUpdated?: Date | string | null
    hasException?: boolean
    exceptionType?: string | null
    exceptionOwner?: string | null
    exceptionNotes?: string | null
    exceptionDate?: Date | string | null
    manualPriority?: string | null
    priorityReason?: string | null
    prioritySetBy?: string | null
    prioritySetDate?: Date | string | null
    notes?: string | null
    emptyIndicator?: boolean | null
    sealNumber?: string | null
    grossWeight?: number | null
    carrierEventId?: string | null
    aceEntryNumber?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    aceLastUpdated?: Date | string | null
    pgaHold?: boolean | null
    pgaAgency?: string | null
    pgaHoldReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerEventCreateManyPreviousStageInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventCreateManyStageInput = {
    id?: string
    containerId: string
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type DCSAEventMapCreateManyTransitStageInput = {
    name: string
    carrierId?: string | null
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
  }

  export type ContainerUpdateWithoutStageInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutStageInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutContainerNestedInput
    events?: ContainerEventUncheckedUpdateManyWithoutContainerNestedInput
    shipmentContainers?: ShipmentContainerUncheckedUpdateManyWithoutContainerNestedInput
    attentionFlags?: AttentionFlagUncheckedUpdateManyWithoutContainerNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutContainerNestedInput
    statusOverrides?: StatusOverrideUncheckedUpdateManyWithoutContainerNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateManyWithoutStageInput = {
    containerNumber?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    currentVessel?: NullableStringFieldUpdateOperationsInput | string | null
    currentVoyage?: NullableStringFieldUpdateOperationsInput | string | null
    mbl?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    pol?: NullableStringFieldUpdateOperationsInput | string | null
    pod?: NullableStringFieldUpdateOperationsInput | string | null
    etd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ata?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    detentionFreeDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasException?: BoolFieldUpdateOperationsInput | boolean
    exceptionType?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionOwner?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manualPriority?: NullableStringFieldUpdateOperationsInput | string | null
    priorityReason?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetBy?: NullableStringFieldUpdateOperationsInput | string | null
    prioritySetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sealNumber?: NullableStringFieldUpdateOperationsInput | string | null
    grossWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    aceEntryNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    aceLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pgaHold?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    pgaHoldReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerEventUpdateWithoutPreviousStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutContainerEventsNestedInput
    importLog?: ImportLogUpdateOneWithoutContainerEventsNestedInput
    stage?: TransitStageUpdateOneWithoutContainerEventsNestedInput
    container?: ContainerUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContainerEventUncheckedUpdateWithoutPreviousStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUncheckedUpdateManyWithoutPreviousStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutContainerEventsNestedInput
    importLog?: ImportLogUpdateOneWithoutContainerEventsNestedInput
    previousStage?: TransitStageUpdateOneWithoutPreviousEventsNestedInput
    container?: ContainerUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContainerEventUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DCSAEventMapUpdateWithoutTransitStageInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    carrier?: CarrierUpdateOneWithoutDcsaEventMapsNestedInput
  }

  export type DCSAEventMapUncheckedUpdateWithoutTransitStageInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DCSAEventMapUncheckedUpdateManyWithoutTransitStageInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ACEStatusLogCreateManyShipmentInput = {
    id?: string
    containerId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    sourceFileId?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ShipmentContainerCreateManyShipmentInput = {
    id?: string
    containerId: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
  }

  export type ShipmentEventCreateManyShipmentInput = {
    id?: string
    eventType: string
    eventDateTime: Date | string
    documentType?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousBLStatus?: string | null
    newBLStatus?: string | null
    notes?: string | null
    dcsaEventType?: string | null
    carrierEventId?: string | null
  }

  export type ACEStatusLogUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importLog?: ImportLogUpdateOneWithoutAceStatusLogsNestedInput
    container?: ContainerUpdateOneWithoutAceStatusLogsNestedInput
  }

  export type ACEStatusLogUncheckedUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogUncheckedUpdateManyWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentContainerUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutShipmentContainersNestedInput
  }

  export type ShipmentContainerUncheckedUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentContainerUncheckedUpdateManyWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentEventUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    importLog?: ImportLogUpdateOneWithoutShipmentEventsNestedInput
  }

  export type ShipmentEventUncheckedUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentEventUncheckedUpdateManyWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newBLStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogCreateManyContainerInput = {
    id?: string
    shipmentId?: string | null
    aceDisposition?: string | null
    aceStatus?: string | null
    previousACEStatus?: string | null
    holdType?: string | null
    pgaAgency?: string | null
    holdReason?: string | null
    eventDateTime?: Date | string | null
    source?: string | null
    sourceFileId?: string | null
    updatedOn?: Date | string | null
    notes?: string | null
  }

  export type ContainerEventCreateManyContainerInput = {
    id?: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    facilityId?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ShipmentContainerCreateManyContainerInput = {
    id?: string
    shipmentId: string
    piecesInContainer?: number | null
    weightInContainer?: number | null
    notes?: string | null
  }

  export type AttentionFlagCreateManyContainerInput = {
    id?: string
    reason: string
    priority: string
    flaggedBy?: string | null
    flaggedOn?: Date | string
    owner?: string | null
    notes?: string | null
    resolved?: boolean
    resolvedBy?: string | null
    resolvedDate?: Date | string | null
    resolutionNote?: string | null
  }

  export type ActivityLogCreateManyContainerInput = {
    id?: string
    shipmentId?: string | null
    action: string
    actor?: string | null
    detail?: string | null
    source?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type StatusOverrideCreateManyContainerInput = {
    id?: string
    previousStatus?: string | null
    newStatus: string
    reason: string
    overriddenBy?: string | null
    overriddenAt?: Date | string
  }

  export type ACEStatusLogUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importLog?: ImportLogUpdateOneWithoutAceStatusLogsNestedInput
    shipment?: ShipmentUpdateOneWithoutAceStatusLogsNestedInput
  }

  export type ACEStatusLogUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ACEStatusLogUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    aceDisposition?: NullableStringFieldUpdateOperationsInput | string | null
    aceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    previousACEStatus?: NullableStringFieldUpdateOperationsInput | string | null
    holdType?: NullableStringFieldUpdateOperationsInput | string | null
    pgaAgency?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutContainerEventsNestedInput
    importLog?: ImportLogUpdateOneWithoutContainerEventsNestedInput
    previousStage?: TransitStageUpdateOneWithoutPreviousEventsNestedInput
    stage?: TransitStageUpdateOneWithoutContainerEventsNestedInput
  }

  export type ContainerEventUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentContainerUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shipment?: ShipmentUpdateOneRequiredWithoutShipmentContainersNestedInput
  }

  export type ShipmentContainerUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentContainerUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: StringFieldUpdateOperationsInput | string
    piecesInContainer?: NullableIntFieldUpdateOperationsInput | number | null
    weightInContainer?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttentionFlagUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttentionFlagUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttentionFlagUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    flaggedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    actor?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusOverrideUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusOverrideUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusOverrideUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    overriddenBy?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerEventCreateManyFacilityInput = {
    id?: string
    containerId: string
    stageName?: string | null
    eventDateTime: Date | string
    location?: string | null
    vessel?: string | null
    voyage?: string | null
    source?: string | null
    sourceFileId?: string | null
    updatedBy?: string | null
    updatedOn?: Date | string | null
    previousStatus?: string | null
    exceptionCleared?: boolean | null
    notes?: string | null
    eventCategory?: string | null
    eventClassifier?: string | null
    dcsaEventType?: string | null
    transportMode?: string | null
    facilityType?: string | null
    emptyIndicator?: boolean | null
    carrierEventId?: string | null
  }

  export type ContainerEventUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
    importLog?: ImportLogUpdateOneWithoutContainerEventsNestedInput
    previousStage?: TransitStageUpdateOneWithoutPreviousEventsNestedInput
    stage?: TransitStageUpdateOneWithoutContainerEventsNestedInput
    container?: ContainerUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContainerEventUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerEventUncheckedUpdateManyWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    containerId?: StringFieldUpdateOperationsInput | string
    stageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    vessel?: NullableStringFieldUpdateOperationsInput | string | null
    voyage?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceFileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionCleared?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    eventClassifier?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transportMode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    emptyIndicator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    carrierEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarrierFormatCreateManyCarrierInput = {
    formatName: string
    formatType?: string | null
    columnMapping?: string | null
    sampleHeaders?: string | null
    isActive?: boolean
    notes?: string | null
  }

  export type DCSAEventMapCreateManyCarrierInput = {
    name: string
    sourceEventCode?: string | null
    sourceEventName?: string | null
    dcsaEventType?: string | null
    transitStageName?: string | null
    eventCategory?: string | null
    notes?: string | null
    isActive?: boolean
  }

  export type DemurrageRateCreateManyCarrierInput = {
    name: string
    portId?: string | null
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
  }

  export type CarrierFormatUpdateWithoutCarrierInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importLogs?: ImportLogUpdateManyWithoutCarrierFormatNestedInput
  }

  export type CarrierFormatUncheckedUpdateWithoutCarrierInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    importLogs?: ImportLogUncheckedUpdateManyWithoutCarrierFormatNestedInput
  }

  export type CarrierFormatUncheckedUpdateManyWithoutCarrierInput = {
    formatName?: StringFieldUpdateOperationsInput | string
    formatType?: NullableStringFieldUpdateOperationsInput | string | null
    columnMapping?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DCSAEventMapUpdateWithoutCarrierInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    transitStage?: TransitStageUpdateOneWithoutDcsaEventMapsNestedInput
  }

  export type DCSAEventMapUncheckedUpdateWithoutCarrierInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transitStageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DCSAEventMapUncheckedUpdateManyWithoutCarrierInput = {
    name?: StringFieldUpdateOperationsInput | string
    sourceEventCode?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEventName?: NullableStringFieldUpdateOperationsInput | string | null
    dcsaEventType?: NullableStringFieldUpdateOperationsInput | string | null
    transitStageName?: NullableStringFieldUpdateOperationsInput | string | null
    eventCategory?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DemurrageRateUpdateWithoutCarrierInput = {
    name?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    port?: PortUpdateOneWithoutDemurrageRatesNestedInput
  }

  export type DemurrageRateUncheckedUpdateWithoutCarrierInput = {
    name?: StringFieldUpdateOperationsInput | string
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DemurrageRateUncheckedUpdateManyWithoutCarrierInput = {
    name?: StringFieldUpdateOperationsInput | string
    portId?: NullableStringFieldUpdateOperationsInput | string | null
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DemurrageRateCreateManyPortInput = {
    name: string
    carrierId?: string | null
    containerType?: string | null
    freeDays?: number | null
    dailyRate?: number | null
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
  }

  export type FacilityCreateManyPortInput = {
    facilityName: string
    facilityCode?: string | null
    facilityType?: string | null
    address?: string | null
    unLocationCode?: string | null
    isActive?: boolean
  }

  export type DemurrageRateUpdateWithoutPortInput = {
    name?: StringFieldUpdateOperationsInput | string
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: CarrierUpdateOneWithoutDemurrageRatesNestedInput
  }

  export type DemurrageRateUncheckedUpdateWithoutPortInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DemurrageRateUncheckedUpdateManyWithoutPortInput = {
    name?: StringFieldUpdateOperationsInput | string
    carrierId?: NullableStringFieldUpdateOperationsInput | string | null
    containerType?: NullableStringFieldUpdateOperationsInput | string | null
    freeDays?: NullableIntFieldUpdateOperationsInput | number | null
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityUpdateWithoutPortInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    containerEvents?: ContainerEventUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutPortInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutPortInput = {
    facilityName?: StringFieldUpdateOperationsInput | string
    facilityCode?: NullableStringFieldUpdateOperationsInput | string | null
    facilityType?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unLocationCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImportLogCreateManyCarrierFormatInput = {
    fileName: string
    fileURL?: string | null
    importedBy?: string | null
    importedOn?: Date | string
    rowsProcessed?: number
    rowsSucceeded?: number
    rowsFailed?: number
    importType?: string | null
    status?: string
    errorLog?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: Date | string | null
  }

  export type ImportLogUpdateWithoutCarrierFormatInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUpdateManyWithoutImportLogNestedInput
    rawRows?: RawRowUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateWithoutCarrierFormatInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aceStatusLogs?: ACEStatusLogUncheckedUpdateManyWithoutImportLogNestedInput
    containerEvents?: ContainerEventUncheckedUpdateManyWithoutImportLogNestedInput
    rawRows?: RawRowUncheckedUpdateManyWithoutImportLogNestedInput
    shipmentEvents?: ShipmentEventUncheckedUpdateManyWithoutImportLogNestedInput
  }

  export type ImportLogUncheckedUpdateManyWithoutCarrierFormatInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileURL?: NullableStringFieldUpdateOperationsInput | string | null
    importedBy?: NullableStringFieldUpdateOperationsInput | string | null
    importedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    rowsProcessed?: IntFieldUpdateOperationsInput | number
    rowsSucceeded?: IntFieldUpdateOperationsInput | number
    rowsFailed?: IntFieldUpdateOperationsInput | number
    importType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ImportLogCountOutputTypeDefaultArgs instead
     */
    export type ImportLogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportLogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransitStageCountOutputTypeDefaultArgs instead
     */
    export type TransitStageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransitStageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentCountOutputTypeDefaultArgs instead
     */
    export type ShipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContainerCountOutputTypeDefaultArgs instead
     */
    export type ContainerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContainerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityCountOutputTypeDefaultArgs instead
     */
    export type FacilityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarrierCountOutputTypeDefaultArgs instead
     */
    export type CarrierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarrierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortCountOutputTypeDefaultArgs instead
     */
    export type PortCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarrierFormatCountOutputTypeDefaultArgs instead
     */
    export type CarrierFormatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarrierFormatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportLogDefaultArgs instead
     */
    export type ImportLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RawRowDefaultArgs instead
     */
    export type RawRowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RawRowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransitStageDefaultArgs instead
     */
    export type TransitStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransitStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentDefaultArgs instead
     */
    export type ShipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContainerDefaultArgs instead
     */
    export type ContainerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContainerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentContainerDefaultArgs instead
     */
    export type ShipmentContainerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentContainerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContainerEventDefaultArgs instead
     */
    export type ContainerEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContainerEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentEventDefaultArgs instead
     */
    export type ShipmentEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ACEStatusLogDefaultArgs instead
     */
    export type ACEStatusLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ACEStatusLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityDefaultArgs instead
     */
    export type FacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarrierDefaultArgs instead
     */
    export type CarrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarrierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortDefaultArgs instead
     */
    export type PortArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForwarderDefaultArgs instead
     */
    export type ForwarderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForwarderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DemurrageRateDefaultArgs instead
     */
    export type DemurrageRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DemurrageRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarrierFormatDefaultArgs instead
     */
    export type CarrierFormatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarrierFormatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DCSAEventMapDefaultArgs instead
     */
    export type DCSAEventMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DCSAEventMapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttentionFlagDefaultArgs instead
     */
    export type AttentionFlagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttentionFlagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusOverrideDefaultArgs instead
     */
    export type StatusOverrideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusOverrideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskAssessmentDefaultArgs instead
     */
    export type RiskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskAssessmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}